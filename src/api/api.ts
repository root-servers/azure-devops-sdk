import * as querystring from 'query-string';
import fetch from 'cross-fetch';
import { assign } from '../helpers/assign';

export type ERRORUNKNOWN = any;

/**
 * 
 */
export interface AadOauthTokenRequest {
    "refresh"?: boolean;
    "resource"?: string;
    "tenantId"?: string;
    "token"?: string;
}

/**
 * 
 */
export interface AadOauthTokenResult {
    "accessToken"?: string;
    "refreshTokenCache"?: string;
}

/**
 * 
 */
export interface AbortTestRunRequest {
    "options"?: number;
    "projectName"?: string;
    "revision"?: number;
    "testRunId"?: number;
}

/**
 * Class for encapsulating the allowed and denied permissions for a given IdentityDescriptor.
 */
export interface AccessControlEntry {

    /**
     * The set of permission bits that represent the actions that the associated descriptor is allowed to perform.
     */
    "allow"?: number;

    /**
     * The set of permission bits that represent the actions that the associated descriptor is not allowed to perform.
     */
    "deny"?: number;

    /**
     * The descriptor for the user this AccessControlEntry applies to.
     */
    "descriptor"?: IdentityDescriptor;

    /**
     * This value, when set, reports the inherited and effective information for the associated descriptor. This value is only set on AccessControlEntries returned by the QueryAccessControlList(s) call when its includeExtendedInfo parameter is set to true.
     */
    "extendedInfo"?: AceExtendedInformation;
}

/**
 * The AccessControlList class is meant to associate a set of AccessControlEntries with a security token and its inheritance settings.
 */
export interface AccessControlList {

    /**
     * Storage of permissions keyed on the identity the permission is for.
     */
    "acesDictionary"?: { [key: string]: AccessControlEntry; };

    /**
     * True if this ACL holds ACEs that have extended information.
     */
    "includeExtendedInfo"?: boolean;

    /**
     * True if the given token inherits permissions from parents.
     */
    "inheritPermissions"?: boolean;

    /**
     * The token that this AccessControlList is for.
     */
    "token"?: string;
}

/**
 * A list of AccessControlList. An AccessControlList is meant to associate a set of AccessControlEntries with a security token and its inheritance settings.
 */
export interface AccessControlListsCollection extends Array<AccessControlList> {
}

/**
 * License assigned to a user
 */
export interface AccessLevel {

    /**
     * Display name of the License
     */
    "licenseDisplayName"?: string;

    /**
     * Status message.
     */
    "statusMessage"?: string;
}

/**
 * 
 */
export interface Account {

    /**
     * Identifier for an Account
     */
    "accountId"?: string;

    /**
     * Name for an account
     */
    "accountName"?: string;

    /**
     * Owner of account
     */
    "accountOwner"?: string;

    /**
     * Uri for an account
     */
    "accountUri"?: string;

    /**
     * Who created the account
     */
    "createdBy"?: string;

    /**
     * Date account was created
     */
    "createdDate"?: Date;
    "hasMoved"?: boolean;

    /**
     * Identity of last person to update the account
     */
    "lastUpdatedBy"?: string;

    /**
     * Date account was last updated
     */
    "lastUpdatedDate"?: Date;

    /**
     * Namespace for an account
     */
    "namespaceId"?: string;
    "newCollectionId"?: string;

    /**
     * Organization that created the account
     */
    "organizationName"?: string;

    /**
     * Extended properties
     */
    "properties"?: PropertiesCollection;

    /**
     * Reason for current status
     */
    "statusReason"?: string;
}

/**
 * 
 */
export interface AccountCreateInfoInternal {
    "accountName"?: string;
    "creator"?: string;
    "organization"?: string;
    "preferences"?: AccountPreferencesInternal;
    "properties"?: PropertiesCollection;
    "serviceDefinitions"?: Array<any>;
}

/**
 * 
 */
export interface AccountMyWorkResult {

    /**
     * True, when length of WorkItemDetails is same as the limit
     */
    "querySizeLimitExceeded"?: boolean;

    /**
     * WorkItem Details
     */
    "workItemDetails"?: Array<AccountWorkWorkItemModel>;
}

/**
 * 
 */
export interface AccountPreferencesInternal {
    "culture"?: string;
    "language"?: string;
    "timeZone"?: string;
}

/**
 * Represents Work Item Recent Activity
 */
export interface AccountRecentActivityWorkItemModel extends AccountRecentActivityWorkItemModelBase {
}

/**
 * Represents Work Item Recent Activity
 */
export interface AccountRecentActivityWorkItemModel2 extends AccountRecentActivityWorkItemModelBase {
}

/**
 * Represents Work Item Recent Activity
 */
export interface AccountRecentActivityWorkItemModelBase {

    /**
     * Date of the last Activity by the user
     */
    "activityDate"?: Date;

    /**
     * Last changed date of the work item
     */
    "changedDate"?: Date;

    /**
     * Work Item Id
     */
    "id"?: number;

    /**
     * TeamFoundationId of the user this activity belongs to
     */
    "identityId"?: string;

    /**
     * State of the work item
     */
    "state"?: string;

    /**
     * Team project the work item belongs to
     */
    "teamProject"?: string;

    /**
     * Title of the work item
     */
    "title"?: string;

    /**
     * Type of Work Item
     */
    "workItemType"?: string;
}

/**
 * Represents Recent Mention Work Item
 */
export interface AccountRecentMentionWorkItemModel {

    /**
     * Assigned To
     */
    "assignedTo"?: string;

    /**
     * Work Item Id
     */
    "id"?: number;

    /**
     * Lastest date that the user were mentioned
     */
    "mentionedDateField"?: Date;

    /**
     * State of the work item
     */
    "state"?: string;

    /**
     * Team project the work item belongs to
     */
    "teamProject"?: string;

    /**
     * Title of the work item
     */
    "title"?: string;

    /**
     * Type of Work Item
     */
    "workItemType"?: string;
}

/**
 * 
 */
export interface AccountWorkWorkItemModel {
    "assignedTo"?: string;
    "changedDate"?: Date;
    "id"?: number;
    "state"?: string;
    "teamProject"?: string;
    "title"?: string;
    "workItemType"?: string;
}

/**
 * Holds the inherited and effective permission information for a given AccessControlEntry.
 */
export interface AceExtendedInformation {

    /**
     * This is the combination of all of the explicit and inherited permissions for this identity on this token.  These are the permissions used when determining if a given user has permission to perform an action.
     */
    "effectiveAllow"?: number;

    /**
     * This is the combination of all of the explicit and inherited permissions for this identity on this token.  These are the permissions used when determining if a given user has permission to perform an action.
     */
    "effectiveDeny"?: number;

    /**
     * These are the permissions that are inherited for this identity on this token.  If the token does not inherit permissions this will be 0.  Note that any permissions that have been explicitly set on this token for this identity, or any groups that this identity is a part of, are not included here.
     */
    "inheritedAllow"?: number;

    /**
     * These are the permissions that are inherited for this identity on this token.  If the token does not inherit permissions this will be 0.  Note that any permissions that have been explicitly set on this token for this identity, or any groups that this identity is a part of, are not included here.
     */
    "inheritedDeny"?: number;
}

/**
 * 
 */
export interface AcquisitionOperation {

    /**
     * Optional reason to justify current state. Typically used with Disallow state.
     */
    "reason"?: string;

    /**
     * List of reasons indicating why the operation is not allowed.
     */
    "reasons"?: Array<AcquisitionOperationDisallowReason>;
}

/**
 * 
 */
export interface AcquisitionOperationDisallowReason {

    /**
     * User-friendly message clarifying the reason for disallowance
     */
    "message"?: string;

    /**
     * Type of reason for disallowance - AlreadyInstalled, UnresolvedDemand, etc.
     */
    "type"?: string;
}

/**
 * Market item acquisition options (install, buy, etc) for an installation target.
 */
export interface AcquisitionOptions {

    /**
     * Default Operation for the ItemId in this target
     */
    "defaultOperation"?: AcquisitionOperation;

    /**
     * The item id that this options refer to
     */
    "itemId"?: string;

    /**
     * Operations allowed for the ItemId in this target
     */
    "operations"?: Array<AcquisitionOperation>;

    /**
     * Additional properties which can be added to the request.
     */
    "properties"?: JObject;

    /**
     * The target that this options refer to
     */
    "target"?: string;
}

/**
 * 
 */
export interface ActionDefinition {

    /**
     * The bit mask integer for this action. Must be a power of 2.
     */
    "bit"?: number;

    /**
     * The localized display name for this action.
     */
    "displayName"?: string;

    /**
     * The non-localized name for this action.
     */
    "name"?: string;

    /**
     * The namespace that this action belongs to.  This will only be used for reading from the database.
     */
    "namespaceId"?: string;
}

/**
 * 
 */
export interface Activity {
    "capacityPerDay"?: string;
    "name"?: string;
}

/**
 * 
 */
export interface ActorFilter extends RoleBasedFilter {
}

/**
 * 
 */
export interface ActorNotificationReason extends NotificationReason {
}

/**
 * Class that describes a request to add a field in a work item type.
 */
export interface AddProcessWorkItemTypeFieldRequest {

    /**
     * Allow setting field value to a group identity. Only applies to identity fields.
     */
    "allowGroups"?: boolean;

    /**
     * The default value of the field.
     */
    "defaultValue"?: any;

    /**
     * If true the field cannot be edited.
     */
    "readOnly"?: boolean;

    /**
     * Reference name of the field.
     */
    "referenceName"?: string;

    /**
     * If true the field cannot be empty.
     */
    "required"?: boolean;
}

/**
 * Describes an admin behavior for a process.
 */
export interface AdminBehavior {

    /**
     * Is the behavior abstract (i.e. can not be associated with any work item type).
     */
    "abstract"?: boolean;

    /**
     * The color associated with the behavior.
     */
    "color"?: string;

    /**
     * Indicates if the behavior is custom.
     */
    "custom"?: boolean;

    /**
     * The description of the behavior.
     */
    "description"?: string;

    /**
     * List of behavior fields.
     */
    "fields"?: Array<AdminBehaviorField>;

    /**
     * Behavior ID.
     */
    "id"?: string;

    /**
     * Parent behavior reference.
     */
    "inherits"?: string;

    /**
     * The behavior name.
     */
    "name"?: string;

    /**
     * Is the behavior overrides a behavior from system process.
     */
    "overriden"?: boolean;

    /**
     * The rank.
     */
    "rank"?: number;
}

/**
 * Describes an admin behavior field.
 */
export interface AdminBehaviorField {

    /**
     * The behavior field identifier.
     */
    "behaviorFieldId"?: string;

    /**
     * The behavior ID.
     */
    "id"?: string;

    /**
     * The behavior name.
     */
    "name"?: string;
}

/**
 * 
 */
export interface AfnStrip {

    /**
     * Auxiliary Url to be consumed by MTM
     */
    "auxiliaryUrl"?: string;

    /**
     * Creation date of the AfnStrip
     */
    "creationDate"?: Date;

    /**
     * File name of the attachment created
     */
    "fileName"?: string;

    /**
     * ID of AfnStrip. This is same as the attachment ID.
     */
    "id"?: number;

    /**
     * Project identifier which contains AfnStrip
     */
    "project"?: string;

    /**
     * Service in which this attachment is stored in
     */
    "storedIn"?: string;

    /**
     * Afn strip stream.
     */
    "stream"?: string;

    /**
     * ID of the testcase.
     */
    "testCaseId"?: number;

    /**
     * Backing test result id.
     */
    "testResultId"?: number;

    /**
     * Backing test run id.
     */
    "testRunId"?: number;

    /**
     * Byte stream (uncompressed) length of Afn strip.
     */
    "unCompressedStreamLength"?: number;

    /**
     * Url of the attachment created.
     */
    "url"?: string;
}

/**
 * 
 */
export interface AgentArtifactDefinition {

    /**
     * Gets or sets the artifact definition alias.
     */
    "alias"?: string;

    /**
     * Gets or sets the artifact definition details.
     */
    "details"?: string;

    /**
     * Gets or sets the name of artifact definition.
     */
    "name"?: string;

    /**
     * Gets or sets the version of artifact definition.
     */
    "version"?: string;
}

/**
 * 
 */
export interface AgentBasedDeployPhase extends DeployPhase {
}

/**
 * 
 */
export interface AgentChangeEvent {
    "agent"?: TaskAgent;
    "eventType"?: string;
    "pool"?: TaskAgentPoolReference;
}

/**
 * 
 */
export interface AgentDeploymentInput extends DeploymentInput {
}

/**
 * 
 */
export interface AgentGroup {
    "createdBy"?: string;
    "creationTime"?: Date;
    "groupId"?: string;
    "groupName"?: string;
    "machineAccessData"?: Array<AgentGroupAccessData>;
    "machineConfiguration"?: WebApiUserLoadTestMachineInput;
    "tenantId"?: string;
}

/**
 * 
 */
export interface AgentGroupAccessData {
    "details"?: string;
    "storageConnectionString"?: string;
    "storageEndPoint"?: string;
    "storageName"?: string;
    "storageType"?: string;
}

/**
 * 
 */
export interface AgentJobRequestMessage extends JobRequestMessage {
}

/**
 * 
 */
export interface AgentMigrationMessage {
    "accessToken"?: string;
}

/**
 * 
 */
export interface AgentPoolEvent {
    "eventType"?: string;
    "pool"?: TaskAgentPool;
}

/**
 * Represents a queue for running builds.
 */
export interface AgentPoolQueue {
    "links"?: ReferenceLinks;

    /**
     * The ID of the queue.
     */
    "id"?: number;

    /**
     * The name of the queue.
     */
    "name"?: string;

    /**
     * The pool used by this queue.
     */
    "pool"?: TaskAgentPoolReference;

    /**
     * The full http link to the resource.
     */
    "url"?: string;
}

/**
 * Represents a reference to an agent queue.
 */
export interface AgentPoolQueueReference extends ResourceReference {
}

/**
 * Describes how a phase should run against an agent queue.
 */
export interface AgentPoolQueueTarget extends PhaseTarget {
}

/**
 * 
 */
export interface AgentQueueEvent {
    "eventType"?: string;
    "queue"?: TaskAgentQueue;
}

/**
 * 
 */
export interface AgentQueuesEvent {
    "eventType"?: string;
    "queues"?: Array<TaskAgentQueue>;
}

/**
 * 
 */
export interface AgentRefreshMessage {
    "agentId"?: number;
    "targetVersion"?: string;
    "timeout"?: string;
}

/**
 * Specification of the agent defined by the pool provider.
 */
export interface AgentSpecification {

    /**
     * Agent specification unique identifier.
     */
    "identifier"?: string;
}

/**
 * Additional options for running phases against an agent queue.
 */
export interface AgentTargetExecutionOptions {

    /**
     * Indicates the type of execution options.
     */
    "type"?: number;
}

/**
 * 
 */
export interface AggregatedDataForResultTrend {

    /**
     * This is tests execution duration.
     */
    "duration"?: string;
    "resultsByOutcome"?: { [key: string]: AggregatedResultsByOutcome; };
    "runSummaryByState"?: { [key: string]: AggregatedRunsByState; };
    "testResultsContext"?: TestResultsContext;
    "totalTests"?: number;
}

/**
 * 
 */
export interface AggregatedResultsAnalysis {
    "duration"?: string;
    "notReportedResultsByOutcome"?: { [key: string]: AggregatedResultsByOutcome; };
    "previousContext"?: TestResultsContext;
    "resultsByOutcome"?: { [key: string]: AggregatedResultsByOutcome; };
    "resultsDifference"?: AggregatedResultsDifference;
    "runSummaryByOutcome"?: { [key: string]: AggregatedRunsByOutcome; };
    "runSummaryByState"?: { [key: string]: AggregatedRunsByState; };
    "totalTests"?: number;
}

/**
 * 
 */
export interface AggregatedResultsByOutcome {
    "count"?: number;
    "duration"?: string;
    "groupByField"?: string;
    "groupByValue"?: any;
    "rerunResultCount"?: number;
}

/**
 * 
 */
export interface AggregatedResultsDifference {
    "increaseInDuration"?: string;
    "increaseInFailures"?: number;
    "increaseInOtherTests"?: number;
    "increaseInPassedTests"?: number;
    "increaseInTotalTests"?: number;
}

/**
 * 
 */
export interface AggregatedRunsByOutcome {
    "runsCount"?: number;
}

/**
 * 
 */
export interface AggregatedRunsByState {
    "resultsByOutcome"?: { [key: string]: AggregatedResultsByOutcome; };
    "runsCount"?: number;
}

/**
 * 
 */
export interface Application {
    "applicationId"?: string;
    "description"?: string;
    "name"?: string;
    "path"?: string;
    "pathSeperator"?: string;
    "type"?: string;
    "version"?: string;
}

/**
 * 
 */
export interface ApplicationCounters {
    "applicationId"?: string;
    "description"?: string;
    "id"?: string;
    "isDefault"?: boolean;
    "name"?: string;
    "path"?: string;
}

/**
 * 
 */
export interface ApplicationType {
    "actionUriLink"?: string;
    "autPortalLink"?: string;
    "isEnabled"?: boolean;
    "maxComponentsAllowedForCollection"?: number;
    "maxCountersAllowed"?: number;
    "type"?: string;
}

/**
 * 
 */
export interface ApprovalOptions {

    /**
     * Specify whether the approval can be skipped if the same approver approved the previous stage.
     */
    "autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped"?: boolean;

    /**
     * Specify whether revalidate identity of approver before completing the approval.
     */
    "enforceIdentityRevalidation"?: boolean;

    /**
     * Specify whether the user requesting a release or deployment should allow to approver.
     */
    "releaseCreatorCanBeApprover"?: boolean;

    /**
     * The number of approvals required to move release forward. '0' means all approvals required.
     */
    "requiredApproverCount"?: number;

    /**
     * Approval timeout. Approval default timeout is 30 days. Maximum allowed timeout is 365 days. '0' means default timeout i.e 30 days.
     */
    "timeoutInMinutes"?: number;
}

/**
 * 
 */
export interface Artifact {

    /**
     * Gets or sets alias.
     */
    "alias"?: string;

    /**
     * Gets or sets definition reference. e.g. {"project":{"id":"fed755ea-49c5-4399-acea-fd5b5aa90a6c","name":"myProject"},"definition":{"id":"1","name":"mybuildDefinition"},"connection":{"id":"1","name":"myConnection"}}.
     */
    "definitionReference"?: { [key: string]: ArtifactSourceReference; };

    /**
     * Indicates whether artifact is primary or not.
     */
    "isPrimary"?: boolean;

    /**
     * Indicates whether artifact is retained by release or not.
     */
    "isRetained"?: boolean;

    /**
     * Gets or sets type. It can have value as 'Build', 'Jenkins', 'GitHub', 'Nuget', 'Team Build (external)', 'ExternalTFSBuild', 'Git', 'TFVC', 'ExternalTfsXamlBuild'.
     */
    "type"?: string;
}

/**
 * 
 */
export interface ArtifactContributionDefinition {
    "artifactTriggerConfiguration"?: ArtifactTriggerConfiguration;
    "artifactType"?: string;
    "artifactTypeStreamMapping"?: { [key: string]: string; };
    "browsableArtifactTypeMapping"?: { [key: string]: string; };
    "dataSourceBindings"?: Array<DataSourceBinding>;
    "displayName"?: string;
    "downloadTaskId"?: string;
    "endpointTypeId"?: string;
    "inputDescriptors"?: Array<InputDescriptor>;
    "name"?: string;
    "taskInputMapping"?: { [key: string]: string; };
    "uniqueSourceIdentifier"?: string;
}

/**
 * 
 */
export interface ArtifactDownloadInputBase {

    /**
     * Gets or sets the alias of artifact.
     */
    "alias"?: string;

    /**
     * Gets or sets the name of artifact definition. Valid values are 'Skip', 'Selective', 'All'.
     */
    "artifactDownloadMode"?: string;

    /**
     * Gets or sets the type of artifact.
     */
    "artifactType"?: string;
}

/**
 * 
 */
export interface ArtifactFilter extends BaseSubscriptionFilter {
}

/**
 * 
 */
export interface ArtifactInstanceData {
    "accountName"?: string;
    "authenticationToken"?: string;
    "tfsUrl"?: string;
    "version"?: string;
}

/**
 * 
 */
export interface ArtifactMetadata {

    /**
     * Sets alias of artifact.
     */
    "alias"?: string;

    /**
     * Sets instance reference of artifact. e.g. for build artifact it is build number.
     */
    "instanceReference"?: BuildVersion;
}

/**
 * 
 */
export interface ArtifactProvider {

    /**
     * Gets or sets the id of artifact provider.
     */
    "id"?: number;

    /**
     * Gets or sets the name of artifact provider.
     */
    "name"?: string;

    /**
     * Gets or sets the link of artifact provider.
     */
    "sourceUri"?: string;

    /**
     * Gets or sets the version of artifact provider.
     */
    "version"?: string;
}

/**
 * 
 */
export interface ArtifactResource {
    "links"?: ReferenceLinks;

    /**
     * Type-specific data about the artifact.
     */
    "data"?: string;

    /**
     * A link to download the resource.
     */
    "downloadUrl"?: string;

    /**
     * Type-specific properties of the artifact.
     */
    "properties"?: { [key: string]: string; };

    /**
     * The type of the resource: File container, version control folder, UNC path, etc.
     */
    "type"?: string;

    /**
     * The full http link to the resource.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ArtifactSourceId {

    /**
     * Gets or sets the artifact type of artifact source.
     */
    "artifactTypeId"?: string;

    /**
     * Gets or sets the list of sourceIdInput of artifact source.
     */
    "sourceIdInputs"?: Array<SourceIdInput>;
}

/**
 * 
 */
export interface ArtifactSourceIdsQueryResult {

    /**
     * Gets or sets the list of artifactsourceIds.
     */
    "artifactSourceIds"?: Array<ArtifactSourceId>;
}

/**
 * 
 */
export interface ArtifactSourceReference {

    /**
     * ID of the artifact source.
     */
    "id"?: string;

    /**
     * Name of the artifact source.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ArtifactSourceTrigger extends ReleaseTriggerBase {
}

/**
 * 
 */
export interface ArtifactTriggerConfiguration {

    /**
     * Gets or sets the whether trigger is supported or not.
     */
    "isTriggerSupported"?: boolean;

    /**
     * Gets or sets the whether trigger is supported only on hosted environment.
     */
    "isTriggerSupportedOnlyInHosted"?: boolean;

    /**
     * Gets or sets the whether webhook is supported at server level.
     */
    "isWebhookSupportedAtServerLevel"?: boolean;

    /**
     * Gets or sets the payload hash header name for the artifact trigger configuration.
     */
    "payloadHashHeaderName"?: string;

    /**
     * Gets or sets the resources for artifact trigger configuration.
     */
    "resources"?: { [key: string]: string; };

    /**
     * Gets or sets the webhook payload mapping for artifact trigger configuration.
     */
    "webhookPayloadMapping"?: { [key: string]: string; };
}

/**
 * 
 */
export interface ArtifactTypeDefinition {

    /**
     * Gets or sets the artifact trigger configuration of artifact type defintion.
     */
    "artifactTriggerConfiguration"?: ArtifactTriggerConfiguration;

    /**
     * Gets or sets the artifact type of artifact type defintion. Valid values are 'Build', 'Package', 'Source' or 'ContainerImage'.
     */
    "artifactType"?: string;

    /**
     * Gets or sets the display name of artifact type defintion.
     */
    "displayName"?: string;

    /**
     * Gets or sets the endpoint type id of artifact type defintion.
     */
    "endpointTypeId"?: string;

    /**
     * Gets or sets the input descriptors of artifact type defintion.
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets the name of artifact type defintion.
     */
    "name"?: string;

    /**
     * Gets or sets the unique source identifier of artifact type defintion.
     */
    "uniqueSourceIdentifier"?: string;
}

/**
 * Contains criteria for querying work items based on artifact URI.
 */
export interface ArtifactUriQuery {

    /**
     * List of artifact URIs to use for querying work items.
     */
    "artifactUris"?: Array<string>;
}

/**
 * Defines result of artifact URI query on work items. Contains mapping of work item IDs to artifact URI.
 */
export interface ArtifactUriQueryResult {

    /**
     * A Dictionary that maps a list of work item references to the given list of artifact URI.
     */
    "artifactUrisQueryResult"?: { [key: string]: Array<WorkItemReference>; };
}

/**
 * 
 */
export interface ArtifactVersion {

    /**
     * Gets or sets the alias of artifact.
     */
    "alias"?: string;

    /**
     * Gets or sets the default version of artifact.
     */
    "defaultVersion"?: BuildVersion;

    /**
     * Gets or sets the error message encountered during quering of versions for artifact.
     */
    "errorMessage"?: string;

    /**
     * Gets or sets the list of build versions of artifact.
     */
    "versions"?: Array<BuildVersion>;
}

/**
 * 
 */
export interface ArtifactVersionQueryResult {

    /**
     * Gets or sets the list for artifact versions of artifact version query result.
     */
    "artifactVersions"?: Array<ArtifactVersion>;
}

/**
 * 
 */
export interface ArtifactsDownloadInput {
    "downloadInputs"?: Array<ArtifactDownloadInputBase>;
}

/**
 * 
 */
export interface AssociatedWorkItem {
    "assignedTo"?: string;

    /**
     * Id of associated the work item.
     */
    "id"?: number;
    "state"?: string;
    "title"?: string;

    /**
     * REST Url of the work item.
     */
    "url"?: string;
    "webUrl"?: string;
    "workItemType"?: string;
}

/**
 * 
 */
export interface AsyncGitOperationNotification {
    "operationId"?: number;
}

/**
 * 
 */
export interface AsyncRefOperationCommitLevelEventNotification extends AsyncGitOperationNotification {
}

/**
 * 
 */
export interface AsyncRefOperationCompletedNotification extends AsyncGitOperationNotification {
}

/**
 * 
 */
export interface AsyncRefOperationConflictNotification extends AsyncRefOperationCommitLevelEventNotification {
}

/**
 * 
 */
export interface AsyncRefOperationGeneralFailureNotification extends AsyncGitOperationNotification {
}

/**
 * 
 */
export interface AsyncRefOperationProgressNotification extends AsyncRefOperationCommitLevelEventNotification {
}

/**
 * 
 */
export interface AsyncRefOperationTimeoutNotification extends AsyncGitOperationNotification {
}

/**
 * Meta data for a file attached to an artifact.
 */
export interface Attachment {

    /**
     * Links to other related objects.
     */
    "links"?: ReferenceLinks;

    /**
     * The name of the attachment.
     */
    "name"?: string;

    /**
     * The person that uploaded this attachment.
     */
    "author"?: IdentityRef;

    /**
     * Content hash of on-disk representation of file content. Its calculated by the server by using SHA1 hash function.
     */
    "contentHash"?: string;

    /**
     * The time the attachment was uploaded.
     */
    "createdDate"?: Date;

    /**
     * The description of the attachment.
     */
    "description"?: string;

    /**
     * The display name of the attachment. Can't be null or empty.
     */
    "displayName"?: string;

    /**
     * Id of the attachment.
     */
    "id"?: number;

    /**
     * Extended properties.
     */
    "properties"?: PropertiesCollection;

    /**
     * The url to download the content of the attachment.
     */
    "url"?: string;
}

/**
 * 
 */
export interface AttachmentReference {
    "id"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface Attribute {
}

/**
 * Identifies an attribute with a name and a container.
 */
export interface AttributeDescriptor {

    /**
     * The name of the attribute.
     */
    "attributeName"?: string;

    /**
     * The container the attribute resides in.
     */
    "containerName"?: string;
}

/**
 * Stores a set of named profile attributes.
 */
export interface AttributesContainer {

    /**
     * The attributes stored by the container.
     */
    "attributes"?: { [key: string]: ProfileAttribute; };

    /**
     * The name of the container.
     */
    "containerName"?: string;

    /**
     * The maximum revision number of any attribute within the container.
     */
    "revision"?: number;
}

/**
 * 
 */
export interface AuthenticationSchemeReference {
    "inputs"?: { [key: string]: string; };
    "type"?: string;
}

/**
 * 
 */
export interface AuthorizationHeader {

    /**
     * Gets or sets the name of authorization header.
     */
    "name"?: string;

    /**
     * Gets or sets the value of authorization header.
     */
    "value"?: string;
}

/**
 * Real time event (SignalR) for an auto-complete update on a pull request
 */
export interface AutoCompleteUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface AutoTriggerIssue {
    "issue"?: Issue;
    "project"?: ProjectReference;
    "releaseDefinitionReference"?: ReleaseDefinitionShallowReference;
}

/**
 * 
 */
export interface Avatar {
    "isAutoGenerated"?: boolean;
    "timeStamp"?: Date;
    "value"?: Array<string>;
}

/**
 * 
 */
export interface AzureKeyVaultPermission extends AzureResourcePermission {
}

/**
 * 
 */
export interface AzureKeyVaultVariableGroupProviderData extends VariableGroupProviderData {
}

/**
 * 
 */
export interface AzureKeyVaultVariableValue extends VariableValue {
}

/**
 * Azure Management Group
 */
export interface AzureManagementGroup {

    /**
     * Display name of azure management group
     */
    "displayName"?: string;

    /**
     * Id of azure management group
     */
    "id"?: string;

    /**
     * Azure management group name
     */
    "name"?: string;

    /**
     * Id of tenant from which azure management group belogs
     */
    "tenantId"?: string;
}

/**
 * Azure management group query result
 */
export interface AzureManagementGroupQueryResult {

    /**
     * Error message in case of an exception
     */
    "errorMessage"?: string;

    /**
     * List of azure management groups
     */
    "value"?: Array<AzureManagementGroup>;
}

/**
 * 
 */
export interface AzurePermission {
    "provisioned"?: boolean;
    "resourceProvider"?: string;
}

/**
 * 
 */
export interface AzureResourcePermission extends AzurePermission {
}

/**
 * 
 */
export interface AzureRoleAssignmentPermission extends AzurePermission {
}

/**
 * 
 */
export interface AzureSpnOperationStatus {
    "state"?: string;
    "statusMessage"?: string;
}

/**
 * 
 */
export interface AzureSubscription {
    "displayName"?: string;
    "subscriptionId"?: string;
    "subscriptionTenantId"?: string;
    "subscriptionTenantName"?: string;
}

/**
 * 
 */
export interface AzureSubscriptionQueryResult {
    "errorMessage"?: string;
    "value"?: Array<AzureSubscription>;
}

/**
 * 
 */
export interface BacklogColumn {
    "columnFieldReference"?: WorkItemFieldReference;
    "width"?: number;
}

/**
 * 
 */
export interface BacklogConfiguration {

    /**
     * Behavior/type field mapping
     */
    "backlogFields"?: BacklogFields;

    /**
     * Hidden Backlog
     */
    "hiddenBacklogs"?: Array<string>;

    /**
     * Is BugsBehavior Configured in the process
     */
    "isBugsBehaviorConfigured"?: boolean;

    /**
     * Portfolio backlog descriptors
     */
    "portfolioBacklogs"?: Array<BacklogLevelConfiguration>;

    /**
     * Requirement backlog
     */
    "requirementBacklog"?: BacklogLevelConfiguration;

    /**
     * Task backlog
     */
    "taskBacklog"?: BacklogLevelConfiguration;
    "url"?: string;

    /**
     * Mapped states for work item types
     */
    "workItemTypeMappedStates"?: Array<WorkItemTypeStateInfo>;
}

/**
 * 
 */
export interface BacklogFields {

    /**
     * Field Type (e.g. Order, Activity) to Field Reference Name map
     */
    "typeFields"?: { [key: string]: string; };
}

/**
 * Contract representing a backlog level
 */
export interface BacklogLevel {

    /**
     * Reference name of the corresponding WIT category
     */
    "categoryReferenceName"?: string;

    /**
     * Plural name for the backlog level
     */
    "pluralName"?: string;

    /**
     * Collection of work item states that are included in the plan. The server will filter to only these work item types.
     */
    "workItemStates"?: Array<string>;

    /**
     * Collection of valid workitem type names for the given backlog level
     */
    "workItemTypes"?: Array<string>;
}

/**
 * 
 */
export interface BacklogLevelConfiguration {

    /**
     * List of fields to include in Add Panel
     */
    "addPanelFields"?: Array<WorkItemFieldReference>;

    /**
     * Color for the backlog level
     */
    "color"?: string;

    /**
     * Default list of columns for the backlog
     */
    "columnFields"?: Array<BacklogColumn>;

    /**
     * Defaulst Work Item Type for the backlog
     */
    "defaultWorkItemType"?: WorkItemTypeReference;

    /**
     * Backlog Id (for Legacy Backlog Level from process config it can be categoryref name)
     */
    "id"?: string;

    /**
     * Indicates whether the backlog level is hidden
     */
    "isHidden"?: boolean;

    /**
     * Backlog Name
     */
    "name"?: string;

    /**
     * Backlog Rank (Taskbacklog is 0)
     */
    "rank"?: number;

    /**
     * Max number of work items to show in the given backlog
     */
    "workItemCountLimit"?: number;

    /**
     * Work Item types participating in this backlog as known by the project/Process, can be overridden by team settings for bugs
     */
    "workItemTypes"?: Array<WorkItemTypeReference>;
}

/**
 * Represents work items in a backlog level
 */
export interface BacklogLevelWorkItems {

    /**
     * A list of work items within a backlog level
     */
    "workItems"?: Array<WorkItemLink>;
}

/**
 * 
 */
export interface BaseDeploymentInput {

    /**
     * Gets or sets the job condition.
     */
    "condition"?: string;

    /**
     * Gets or sets the job cancel timeout in minutes for deployment which are cancelled by user for this release environment.
     */
    "jobCancelTimeoutInMinutes"?: number;

    /**
     * Gets or sets the override inputs.
     */
    "overrideInputs"?: { [key: string]: string; };

    /**
     * Gets or sets the job execution timeout in minutes for deployment which are queued against this release environment.
     */
    "timeoutInMinutes"?: number;
}

/**
 * 
 */
export interface BaseOperationResult {

    /**
     * List of error codes paired with their corresponding error messages
     */
    "errors"?: Array<{ [key: string]: string; }>;

    /**
     * Success status of the operation
     */
    "isSuccess"?: boolean;
}

/**
 * 
 */
export interface BaseSubscriptionFilter {
    "eventType"?: string;
    "type"?: string;
}

/**
 * Data required to deprecate multiple package versions. Pass this while performing NpmBatchOperationTypes.Deprecate batch operation.
 */
export interface BatchDeprecateData extends BatchOperationData {
}

/**
 * Data required to unlist or relist multiple package versions. Pass this while performing NuGetBatchOperationTypes.List batch operation.
 */
export interface BatchListData extends BatchOperationData {
}

/**
 * 
 */
export interface BatchNotificationOperation {
    "notificationQueryConditions"?: Array<NotificationQueryCondition>;
}

/**
 * Do not attempt to use this type to create a new BatchOperationData. This type does not contain sufficient fields to create a new batch operation data.
 */
export interface BatchOperationData {
}

/**
 * 
 */
export interface BatchResponse {
    "error"?: string;
    "responses"?: Array<Response>;
}

/**
 * 
 */
export interface BehaviorCreateModel {

    /**
     * Color
     */
    "color"?: string;

    /**
     * Parent behavior id
     */
    "inherits"?: string;

    /**
     * Name of the behavior
     */
    "name"?: string;
}

/**
 * 
 */
export interface BehaviorModel {

    /**
     * Is the behavior abstract (i.e. can not be associated with any work item type)
     */
    "abstract"?: boolean;

    /**
     * Color
     */
    "color"?: string;

    /**
     * Description
     */
    "description"?: string;

    /**
     * Behavior Id
     */
    "id"?: string;

    /**
     * Parent behavior reference
     */
    "inherits"?: WorkItemBehaviorReference;

    /**
     * Behavior Name
     */
    "name"?: string;

    /**
     * Is the behavior overrides a behavior from system process
     */
    "overridden"?: boolean;

    /**
     * Rank
     */
    "rank"?: number;

    /**
     * Url of the behavior
     */
    "url"?: string;
}

/**
 * 
 */
export interface BehaviorReplaceModel {

    /**
     * Color
     */
    "color"?: string;

    /**
     * Behavior Name
     */
    "name"?: string;
}

/**
 * 
 */
export interface BlockFilter extends RoleBasedFilter {
}

/**
 * 
 */
export interface BlockSubscriptionChannel {
    "type"?: string;
}

/**
 * 
 */
export interface Board extends BoardReference {
}

/**
 * 
 */
export interface BoardCardRuleSettings {
    "links"?: ReferenceLinks;
    "rules"?: { [key: string]: Array<Rule>; };
    "url"?: string;
}

/**
 * 
 */
export interface BoardCardSettings {
    "cards"?: { [key: string]: Array<FieldSetting>; };
}

/**
 * 
 */
export interface BoardChart extends BoardChartReference {
}

/**
 * 
 */
export interface BoardChartReference {

    /**
     * Name of the resource
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface BoardColumn {
    "description"?: string;
    "id"?: string;
    "isSplit"?: boolean;
    "itemLimit"?: number;
    "name"?: string;
    "stateMappings"?: { [key: string]: string; };
}

/**
 * 
 */
export interface BoardFields {
    "columnField"?: FieldReference;
    "doneField"?: FieldReference;
    "rowField"?: FieldReference;
}

/**
 * 
 */
export interface BoardReference {

    /**
     * Id of the resource
     */
    "id"?: string;

    /**
     * Name of the resource
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface BoardRow {
    "id"?: string;
    "name"?: string;
}

/**
 * 
 */
export interface BoardSuggestedValue {
    "name"?: string;
}

/**
 * 
 */
export interface BoardUserSettings {
    "autoRefreshState"?: boolean;
}

/**
 * Real time event (SignalR) for a source/target branch update on a pull request
 */
export interface BranchUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface BrowserMix {
    "browserName"?: string;
    "browserPercentage"?: string;
}

/**
 * Data representation of a build.
 */
export interface Build {
    "links"?: ReferenceLinks;

    /**
     * The build number/name of the build.
     */
    "buildNumber"?: string;

    /**
     * The build number revision.
     */
    "buildNumberRevision"?: number;

    /**
     * The build controller. This is only set if the definition type is Xaml.
     */
    "controller"?: BuildController;

    /**
     * The definition associated with the build.
     */
    "definition"?: DefinitionReference;

    /**
     * Indicates whether the build has been deleted.
     */
    "deleted"?: boolean;

    /**
     * The identity of the process or person that deleted the build.
     */
    "deletedBy"?: IdentityRef;

    /**
     * The date the build was deleted.
     */
    "deletedDate"?: Date;

    /**
     * The description of how the build was deleted.
     */
    "deletedReason"?: string;

    /**
     * A list of demands that represents the agent capabilities required by this build.
     */
    "demands"?: Array<Demand>;

    /**
     * The time that the build was completed.
     */
    "finishTime"?: Date;

    /**
     * The ID of the build.
     */
    "id"?: number;

    /**
     * Indicates whether the build should be skipped by retention policies.
     */
    "keepForever"?: boolean;

    /**
     * The identity representing the process or person that last changed the build.
     */
    "lastChangedBy"?: IdentityRef;

    /**
     * The date the build was last changed.
     */
    "lastChangedDate"?: Date;

    /**
     * Information about the build logs.
     */
    "logs"?: BuildLogReference;

    /**
     * The orchestration plan for the build.
     */
    "orchestrationPlan"?: TaskOrchestrationPlanReference;

    /**
     * The parameters for the build.
     */
    "parameters"?: string;

    /**
     * Orchestration plans associated with the build (build, cleanup)
     */
    "plans"?: Array<TaskOrchestrationPlanReference>;

    /**
     * The team project.
     */
    "project"?: TeamProjectReference;
    "properties"?: PropertiesCollection;

    /**
     * The quality of the xaml build (good, bad, etc.)
     */
    "quality"?: string;

    /**
     * The queue. This is only set if the definition type is Build.
     */
    "queue"?: AgentPoolQueue;

    /**
     * The current position of the build in the queue.
     */
    "queuePosition"?: number;

    /**
     * The time that the build was queued.
     */
    "queueTime"?: Date;

    /**
     * The repository.
     */
    "repository"?: BuildRepository;

    /**
     * The identity that queued the build.
     */
    "requestedBy"?: IdentityRef;

    /**
     * The identity on whose behalf the build was queued.
     */
    "requestedFor"?: IdentityRef;

    /**
     * Indicates whether the build is retained by a release.
     */
    "retainedByRelease"?: boolean;

    /**
     * The source branch.
     */
    "sourceBranch"?: string;

    /**
     * The source version.
     */
    "sourceVersion"?: string;

    /**
     * The time that the build was started.
     */
    "startTime"?: Date;
    "tags"?: Array<string>;

    /**
     * The build that triggered this build via a Build completion trigger.
     */
    "triggeredByBuild"?: Build;

    /**
     * Sourceprovider-specific information about what triggered the build
     */
    "triggerInfo"?: { [key: string]: string; };

    /**
     * The URI of the build.
     */
    "uri"?: string;

    /**
     * The REST URL of the build.
     */
    "url"?: string;
    "validationResults"?: Array<BuildRequestValidationResult>;
}

/**
 * 
 */
export interface BuildAgent {
    "buildDirectory"?: string;
    "controller"?: XamlBuildControllerReference;
    "createdDate"?: Date;
    "description"?: string;
    "enabled"?: boolean;
    "id"?: number;
    "messageQueueUrl"?: string;
    "name"?: string;
    "reservedForBuild"?: string;
    "server"?: XamlBuildServerReference;
    "statusMessage"?: string;
    "updatedDate"?: Date;
    "uri"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface BuildAgentReference {

    /**
     * Id of the resource
     */
    "id"?: number;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * Represents an artifact produced by a build.
 */
export interface BuildArtifact {

    /**
     * The artifact ID.
     */
    "id"?: number;

    /**
     * The name of the artifact.
     */
    "name"?: string;

    /**
     * The actual resource.
     */
    "resource"?: ArtifactResource;
}

/**
 * 
 */
export interface BuildArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * Represents a build badge.
 */
export interface BuildBadge {

    /**
     * The ID of the build represented by this badge.
     */
    "buildId"?: number;

    /**
     * A link to the SVG resource.
     */
    "imageUrl"?: string;
}

/**
 * 
 */
export interface BuildCompletedEvent extends BuildUpdatedEvent {
}

/**
 * Represents a build completion trigger.
 */
export interface BuildCompletionTrigger extends BuildTrigger {
}

/**
 * 
 */
export interface BuildConfiguration {
    "branchName"?: string;
    "buildDefinitionId"?: number;
    "buildSystem"?: string;
    "creationDate"?: Date;
    "flavor"?: string;
    "id"?: number;
    "number"?: string;
    "platform"?: string;
    "project"?: ShallowReference;
    "repositoryGuid"?: string;
    "repositoryType"?: string;
    "sourceVersion"?: string;
    "uri"?: string;
}

/**
 * 
 */
export interface BuildController extends XamlBuildControllerReference {
}

/**
 * Build Coverage Detail
 */
export interface BuildCoverage {

    /**
     * Code Coverage File Url
     */
    "codeCoverageFileUrl"?: string;

    /**
     * Build Configuration
     */
    "configuration"?: BuildConfiguration;

    /**
     * Last Error
     */
    "lastError"?: string;

    /**
     * List of Modules
     */
    "modules"?: Array<ModuleCoverage>;

    /**
     * State
     */
    "state"?: string;
}

/**
 * Represents a build definition.
 */
export interface BuildDefinition extends BuildDefinitionReference {
}

/**
 * For back-compat with extensions that use the old Steps format instead of Process and Phases
 */
export interface BuildDefinition32 extends BuildDefinitionReference32 {
}

/**
 * The build definition reference resource
 */
export interface BuildDefinitionReference extends DefinitionReference {
}

/**
 * For back-compat with extensions that use the old Steps format instead of Process and Phases
 */
export interface BuildDefinitionReference32 extends DefinitionReference {
}

/**
 * Represents a revision of a build definition.
 */
export interface BuildDefinitionRevision {

    /**
     * The identity of the person or process that changed the definition.
     */
    "changedBy"?: IdentityRef;

    /**
     * The date and time that the definition was changed.
     */
    "changedDate"?: Date;

    /**
     * The comment associated with the change.
     */
    "comment"?: string;

    /**
     * A link to the definition at this revision.
     */
    "definitionUrl"?: string;

    /**
     * The name of the definition.
     */
    "name"?: string;

    /**
     * The revision number.
     */
    "revision"?: number;
}

/**
 * 
 */
export interface BuildDefinitionSourceProvider {

    /**
     * Uri of the associated definition
     */
    "definitionUri"?: string;

    /**
     * fields associated with this build definition
     */
    "fields"?: { [key: string]: string; };

    /**
     * Id of this source provider
     */
    "id"?: number;

    /**
     * The lst time this source provider was modified
     */
    "lastModified"?: Date;

    /**
     * Name of the source provider
     */
    "name"?: string;
}

/**
 * Represents a step in a build phase.
 */
export interface BuildDefinitionStep {

    /**
     * Indicates whether this step should run even if a previous step fails.
     */
    "alwaysRun"?: boolean;

    /**
     * A condition that determines whether this step should run.
     */
    "condition"?: string;

    /**
     * Indicates whether the phase should continue even if this step fails.
     */
    "continueOnError"?: boolean;

    /**
     * The display name for this step.
     */
    "displayName"?: string;

    /**
     * Indicates whether the step is enabled.
     */
    "enabled"?: boolean;
    "environment"?: { [key: string]: string; };
    "inputs"?: { [key: string]: string; };

    /**
     * The reference name for this step.
     */
    "refName"?: string;

    /**
     * The task associated with this step.
     */
    "task"?: TaskDefinitionReference;

    /**
     * The time, in minutes, that this step is allowed to run.
     */
    "timeoutInMinutes"?: number;
}

/**
 * Represents a template from which new build definitions can be created.
 */
export interface BuildDefinitionTemplate {

    /**
     * Indicates whether the template can be deleted.
     */
    "canDelete"?: boolean;

    /**
     * The template category.
     */
    "category"?: string;

    /**
     * An optional hosted agent queue for the template to use by default.
     */
    "defaultHostedQueue"?: string;

    /**
     * A description of the template.
     */
    "description"?: string;
    "icons"?: { [key: string]: string; };

    /**
     * The ID of the task whose icon is used when showing this template in the UI.
     */
    "iconTaskId"?: string;

    /**
     * The ID of the template.
     */
    "id"?: string;

    /**
     * The name of the template.
     */
    "name"?: string;

    /**
     * The actual template.
     */
    "template"?: BuildDefinition;
}

/**
 * For back-compat with extensions that use the old Steps format instead of Process and Phases
 */
export interface BuildDefinitionTemplate32 {
    "canDelete"?: boolean;
    "category"?: string;
    "defaultHostedQueue"?: string;
    "description"?: string;
    "icons"?: { [key: string]: string; };
    "iconTaskId"?: string;
    "id"?: string;
    "name"?: string;
    "template"?: BuildDefinition32;
}

/**
 * Represents a variable used by a build definition.
 */
export interface BuildDefinitionVariable {

    /**
     * Indicates whether the value can be set at queue time.
     */
    "allowOverride"?: boolean;

    /**
     * Indicates whether the variable's value is a secret.
     */
    "isSecret"?: boolean;

    /**
     * The value of the variable.
     */
    "value"?: string;
}

/**
 * 
 */
export interface BuildDeletedEvent extends RealtimeBuildEvent {
}

/**
 * 
 */
export interface BuildDeployment {
    "deployment"?: BuildSummary;
    "sourceBuild"?: XamlBuildReference;
}

/**
 * 
 */
export interface BuildEvent {
    "data"?: Array<string>;
    "identifier"?: string;
}

/**
 * Represents a build log.
 */
export interface BuildLog extends BuildLogReference {
}

/**
 * Represents a reference to a build log.
 */
export interface BuildLogReference {

    /**
     * The ID of the log.
     */
    "id"?: number;

    /**
     * The type of the log location.
     */
    "type"?: string;

    /**
     * A full link to the log resource.
     */
    "url"?: string;
}

/**
 * Represents metadata about builds in the system.
 */
export interface BuildMetric {

    /**
     * The date for the scope.
     */
    "date"?: Date;

    /**
     * The value.
     */
    "intValue"?: number;

    /**
     * The name of the metric.
     */
    "name"?: string;

    /**
     * The scope.
     */
    "scope"?: string;
}

/**
 * Represents the application of an optional behavior to a build definition.
 */
export interface BuildOption {

    /**
     * A reference to the build option.
     */
    "definition"?: BuildOptionDefinitionReference;

    /**
     * Indicates whether the behavior is enabled.
     */
    "enabled"?: boolean;
    "inputs"?: { [key: string]: string; };
}

/**
 * Represents an optional behavior that can be applied to a build definition.
 */
export interface BuildOptionDefinition extends BuildOptionDefinitionReference {
}

/**
 * Represents a reference to a build option definition.
 */
export interface BuildOptionDefinitionReference {

    /**
     * The ID of the referenced build option.
     */
    "id"?: string;
}

/**
 * Represents a group of inputs for a build option.
 */
export interface BuildOptionGroupDefinition {

    /**
     * The name of the group to display in the UI.
     */
    "displayName"?: string;

    /**
     * Indicates whether the group is initially displayed as expanded in the UI.
     */
    "isExpanded"?: boolean;

    /**
     * The internal name of the group.
     */
    "name"?: string;
}

/**
 * Represents an input for a build option.
 */
export interface BuildOptionInputDefinition {

    /**
     * The default value.
     */
    "defaultValue"?: string;

    /**
     * The name of the input group that this input belongs to.
     */
    "groupName"?: string;
    "help"?: { [key: string]: string; };

    /**
     * The label for the input.
     */
    "label"?: string;

    /**
     * The name of the input.
     */
    "name"?: string;
    "options"?: { [key: string]: string; };

    /**
     * Indicates whether the input is required to have a value.
     */
    "required"?: boolean;

    /**
     * The rule that is applied to determine whether the input is visible in the UI.
     */
    "visibleRule"?: string;
}

/**
 * Represents a build process.
 */
export interface BuildProcess {

    /**
     * The type of the process.
     */
    "type"?: number;
}

/**
 * Represents resources used by a build process.
 */
export interface BuildProcessResources {
    "endpoints"?: Array<ServiceEndpointReference>;
    "files"?: Array<SecureFileReference>;
    "queues"?: Array<AgentPoolQueueReference>;
    "variableGroups"?: Array<VariableGroupReference>;
}

/**
 * 
 */
export interface BuildProcessTemplate {
    "description"?: string;
    "fileExists"?: boolean;
    "id"?: number;
    "parameters"?: string;
    "serverPath"?: string;
    "teamProject"?: string;
    "url"?: string;
    "version"?: string;
}

/**
 * 
 */
export interface BuildQueuedEvent extends BuildUpdatedEvent {
}

/**
 * Reference to a build.
 */
export interface BuildReference {
    "links"?: ReferenceLinks;

    /**
     * The build number.
     */
    "buildNumber"?: string;

    /**
     * Indicates whether the build has been deleted.
     */
    "deleted"?: boolean;

    /**
     * The time that the build was completed.
     */
    "finishTime"?: Date;

    /**
     * Build ID.
     */
    "id"?: number;

    /**
     * The time that the build was queued.
     */
    "queueTime"?: Date;

    /**
     * The identity on whose behalf the build was queued.
     */
    "requestedFor"?: IdentityRef;

    /**
     * The time that the build was started.
     */
    "startTime"?: Date;

    /**
     * Branch name.
     */
    "branchName"?: string;

    /**
     * Build system.
     */
    "buildSystem"?: string;

    /**
     * Build Definition ID.
     */
    "definitionId"?: number;

    /**
     * Build Number.
     */
    "number"?: string;

    /**
     * Repository ID.
     */
    "repositoryId"?: string;

    /**
     * Build URI.
     */
    "uri"?: string;
}

/**
 * 
 */
export interface BuildReference2 {
    "branchName"?: string;
    "buildConfigurationId"?: number;
    "buildDefinitionId"?: number;
    "buildDeleted"?: boolean;
    "buildFlavor"?: string;
    "buildId"?: number;
    "buildNumber"?: string;
    "buildPlatform"?: string;
    "buildSystem"?: string;
    "buildUri"?: string;
    "coverageId"?: number;
    "createdDate"?: Date;
    "projectId"?: string;
    "repoId"?: string;
    "repoType"?: string;
    "sourceVersion"?: string;
}

/**
 * Represents information about a build report.
 */
export interface BuildReportMetadata {

    /**
     * The Id of the build.
     */
    "buildId"?: number;

    /**
     * The content of the report.
     */
    "content"?: string;

    /**
     * The type of the report.
     */
    "type"?: string;
}

/**
 * Represents a repository used by a build definition.
 */
export interface BuildRepository {

    /**
     * Indicates whether to checkout submodules.
     */
    "checkoutSubmodules"?: boolean;

    /**
     * Indicates whether to clean the target folder when getting code from the repository.
     */
    "clean"?: string;

    /**
     * The name of the default branch.
     */
    "defaultBranch"?: string;

    /**
     * The ID of the repository.
     */
    "id"?: string;

    /**
     * The friendly name of the repository.
     */
    "name"?: string;
    "properties"?: { [key: string]: string; };

    /**
     * The root folder.
     */
    "rootFolder"?: string;

    /**
     * The type of the repository.
     */
    "type"?: string;

    /**
     * The URL of the repository.
     */
    "url"?: string;
}

/**
 * Represents the result of validating a build request.
 */
export interface BuildRequestValidationResult {

    /**
     * The message associated with the result.
     */
    "message"?: string;
}

/**
 * Represents information about resources used by builds in the system.
 */
export interface BuildResourceUsage {

    /**
     * The number of build agents.
     */
    "distributedTaskAgents"?: number;

    /**
     * The number of paid private agent slots.
     */
    "paidPrivateAgentSlots"?: number;

    /**
     * The total usage.
     */
    "totalUsage"?: number;

    /**
     * The number of XAML controllers.
     */
    "xamlControllers"?: number;
}

/**
 * 
 */
export interface BuildServer {
    "agents"?: Array<BuildAgentReference>;
    "controller"?: XamlBuildControllerReference;
    "id"?: number;
    "isVirtual"?: boolean;
    "messageQueueUrl"?: string;
    "name"?: string;
    "requireClientCertificates"?: boolean;
    "statusChangedDate"?: Date;
    "uri"?: string;
    "url"?: string;
    "version"?: number;
}

/**
 * Represents system-wide build settings.
 */
export interface BuildSettings {

    /**
     * The number of days to keep records of deleted builds.
     */
    "daysToKeepDeletedBuildsBeforeDestroy"?: number;

    /**
     * The default retention policy.
     */
    "defaultRetentionPolicy"?: RetentionPolicy;

    /**
     * The maximum retention policy.
     */
    "maximumRetentionPolicy"?: RetentionPolicy;
}

/**
 * 
 */
export interface BuildSummary {
    "build"?: XamlBuildReference;
    "finishTime"?: Date;
    "keepForever"?: boolean;
    "quality"?: string;
    "requestedFor"?: IdentityRef;
    "startTime"?: Date;
}

/**
 * 
 */
export interface BuildTagsAddedEvent extends BuildUpdatedEvent {
}

/**
 * Represents a trigger for a buld definition.
 */
export interface BuildTrigger {
}

/**
 * 
 */
export interface BuildUpdatedEvent extends RealtimeBuildEvent {
}

/**
 * 
 */
export interface BuildVersion {

    /**
     * Gets or sets the commit message for the artifact.
     */
    "commitMessage"?: string;

    /**
     * Gets or sets the definition id.
     */
    "definitionId"?: string;

    /**
     * Gets or sets the definition name.
     */
    "definitionName"?: string;

    /**
     * Gets or sets the build id.
     */
    "id"?: string;

    /**
     * Gets or sets if the artifact supports multiple definitions.
     */
    "isMultiDefinitionType"?: boolean;

    /**
     * Gets or sets the build number.
     */
    "name"?: string;

    /**
     * Gets or sets the source branch for the artifact.
     */
    "sourceBranch"?: string;

    /**
     * Gets or sets the source pull request version for the artifact.
     */
    "sourcePullRequestVersion"?: SourcePullRequestVersion;

    /**
     * Gets or sets the repository id for the artifact.
     */
    "sourceRepositoryId"?: string;

    /**
     * Gets or sets the repository type for the artifact.
     */
    "sourceRepositoryType"?: string;

    /**
     * Gets or sets the source version for the artifact.
     */
    "sourceVersion"?: string;
}

/**
 * Represents a workspace mapping.
 */
export interface BuildWorkspace {
    "mappings"?: Array<MappingDetails>;
}

/**
 * 
 */
export interface BuildsDeletedEvent extends BuildsDeletedEvent1 {
}

/**
 * 
 */
export interface BuildsDeletedEvent1 {
    "buildIds"?: Array<number>;

    /**
     * The ID of the definition.
     */
    "definitionId"?: number;

    /**
     * The ID of the project.
     */
    "projectId"?: string;
}

/**
 * 
 */
export interface BulkResultUpdateRequest {
    "projectName"?: string;
    "requests"?: Array<ResultUpdateRequest>;
}

/**
 * Expected data from PATCH
 */
export interface CapacityPatch {
    "activities"?: Array<Activity>;
    "daysOff"?: Array<DateRange>;
}

/**
 * Card settings, such as fields and rules
 */
export interface CardFieldSettings {

    /**
     * A collection of field information of additional fields on cards. The index in the collection signifies the order of the field among the additional fields. Currently unused. Should be used with User Story 691539: Card setting: additional fields
     */
    "additionalFields"?: Array<FieldInfo>;

    /**
     * A collection of field information of rendered core fields on cards.
     */
    "coreFields"?: Array<FieldInfo>;

    /**
     * Flag indicating whether to show assigned to field on cards. When true, AssignedToDisplayFormat will determine how the field will be displayed
     */
    "showAssignedTo"?: boolean;

    /**
     * Flag indicating whether to show empty fields on cards
     */
    "showEmptyFields"?: boolean;

    /**
     * Flag indicating whether to show ID on cards
     */
    "showId"?: boolean;

    /**
     * Flag indicating whether to show state field on cards
     */
    "showState"?: boolean;

    /**
     * Flag indicating whether to show tags on cards
     */
    "showTags"?: boolean;
}

/**
 * Card settings, such as fields and rules
 */
export interface CardSettings {

    /**
     * A collection of settings related to rendering of fields on cards
     */
    "fields"?: CardFieldSettings;
}

/**
 * Details about a given backlog category
 */
export interface CategoryConfiguration {

    /**
     * Name
     */
    "name"?: string;

    /**
     * Category Reference Name
     */
    "referenceName"?: string;

    /**
     * Work item types for the backlog category
     */
    "workItemTypes"?: Array<WorkItemTypeReference>;
}

/**
 * 
 */
export interface Change {

    /**
     * The author of the change.
     */
    "author"?: IdentityRef;

    /**
     * The location of a user-friendly representation of the resource.
     */
    "displayUri"?: string;

    /**
     * Something that identifies the change. For a commit, this would be the SHA1. For a TFVC changeset, this would be the changeset id.
     */
    "id"?: string;

    /**
     * The location of the full representation of the resource.
     */
    "location"?: string;

    /**
     * A description of the change. This might be a commit message or changeset description.
     */
    "message"?: string;

    /**
     * Indicates whether the message was truncated.
     */
    "messageTruncated"?: boolean;

    /**
     * The person or process that pushed the change.
     */
    "pusher"?: string;

    /**
     * A timestamp for the change.
     */
    "timestamp"?: Date;

    /**
     * The type of change. "commit", "changeset", etc.
     */
    "type"?: string;

    /**
     * The type of change that was made to the item.
     */
    "changeType"?: Change.ChangeTypeEnum;

    /**
     * Current version.
     */
    "item"?: string;

    /**
     * Content of the item after the change.
     */
    "newContent"?: ItemContent;

    /**
     * Path of the item on the server.
     */
    "sourceServerItem"?: string;

    /**
     * URL to retrieve the item.
     */
    "url"?: string;

    /**
     * The person or process that pushed the change.
     */
    "pushedBy"?: IdentityRef;
}

export namespace Change {

export type ChangeTypeEnum = 'none' | 'add' | 'edit' | 'encoding' | 'rename' | 'delete' | 'undelete' | 'branch' | 'merge' | 'lock' | 'rollback' | 'sourceRename' | 'targetRename' | 'property' | 'all';
}
/**
 * 
 */
export interface ChangeCountDictionary {
}

/**
 * 
 */
export interface ChangeList {
    "allChangesIncluded"?: boolean;
    "changeCounts"?: { [key: string]: number; };
    "changes"?: Array<Change>;
    "comment"?: string;
    "commentTruncated"?: boolean;
    "creationDate"?: Date;
    "notes"?: Array<CheckinNote>;
    "owner"?: string;
    "ownerDisplayName"?: string;
    "ownerId"?: string;
    "sortDate"?: Date;
    "version"?: string;
}

/**
 * Criteria used in a search for change lists
 */
export interface ChangeListSearchCriteria {

    /**
     * If provided, a version descriptor to compare against base
     */
    "compareVersion"?: string;

    /**
     * If true, don't include delete history entries
     */
    "excludeDeletes"?: boolean;

    /**
     * Whether or not to follow renames for the given item being queried
     */
    "followRenames"?: boolean;

    /**
     * If provided, only include history entries created after this date (string)
     */
    "fromDate"?: string;

    /**
     * If provided, a version descriptor for the earliest change list to include
     */
    "fromVersion"?: string;

    /**
     * Path of item to search under. If the itemPaths memebr is used then it will take precedence over this.
     */
    "itemPath"?: string;

    /**
     * List of item paths to search under. If this member is used then itemPath will be ignored.
     */
    "itemPaths"?: Array<string>;

    /**
     * Version of the items to search
     */
    "itemVersion"?: string;

    /**
     * Number of results to skip (used when clicking more...)
     */
    "skip"?: number;

    /**
     * If provided, only include history entries created before this date (string)
     */
    "toDate"?: string;

    /**
     * If provided, the maximum number of history entries to return
     */
    "top"?: number;

    /**
     * If provided, a version descriptor for the latest change list to include
     */
    "toVersion"?: string;

    /**
     * Alias or display name of user who made the changes
     */
    "user"?: string;
}

/**
 * Describes result of a check template existence request.
 */
export interface CheckTemplateExistenceResult {

    /**
     * Indicates whether a template exists.
     */
    "doesTemplateExist"?: boolean;

    /**
     * The name of the existing template.
     */
    "existingTemplateName"?: string;

    /**
     * The existing template type identifier.
     */
    "existingTemplateTypeId"?: string;

    /**
     * The name of the requested template.
     */
    "requestedTemplateName"?: string;
}

/**
 * 
 */
export interface CheckinNote {
    "name"?: string;
    "value"?: string;
}

/**
 * 
 */
export interface ClientCertificate {

    /**
     * Gets or sets the value of client certificate.
     */
    "value"?: string;
}

/**
 * Representaion of a ContributionNode that can be used for serialized to clients.
 */
export interface ClientContribution {

    /**
     * Description of the contribution/type
     */
    "description"?: string;

    /**
     * Fully qualified identifier of the contribution/type
     */
    "id"?: string;

    /**
     * Includes is a set of contributions that should have this contribution included in their targets list.
     */
    "includes"?: Array<string>;

    /**
     * Properties/attributes of this contribution
     */
    "properties"?: JObject;

    /**
     * The ids of the contribution(s) that this contribution targets. (parent contributions)
     */
    "targets"?: Array<string>;

    /**
     * Id of the Contribution Type
     */
    "type"?: string;
}

/**
 * Representaion of a ContributionNode that can be used for serialized to clients.
 */
export interface ClientContributionNode {

    /**
     * List of ids for contributions which are children to the current contribution.
     */
    "children"?: Array<string>;

    /**
     * Contribution associated with this node.
     */
    "contribution"?: ClientContribution;

    /**
     * List of ids for contributions which are parents to the current contribution.
     */
    "parents"?: Array<string>;
}

/**
 * 
 */
export interface ClientContributionProviderDetails {

    /**
     * Friendly name for the provider.
     */
    "displayName"?: string;

    /**
     * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
     */
    "name"?: string;

    /**
     * Properties associated with the provider
     */
    "properties"?: { [key: string]: string; };

    /**
     * Version of contributions assoicated with this contribution provider.
     */
    "version"?: string;
}

/**
 * A client data provider are the details needed to make the data provider request from the client.
 */
export interface ClientDataProviderQuery extends DataProviderQuery {
}

/**
 * Common Response for clone operation
 */
export interface CloneOperationCommonResponse {

    /**
     * Various statistics related to the clone operation
     */
    "cloneStatistics"?: CloneStatistics;

    /**
     * Completion data of the operation
     */
    "completionDate"?: Date;

    /**
     * Creation data of the operation
     */
    "creationDate"?: Date;

    /**
     * Reference links
     */
    "links"?: ReferenceLinks;

    /**
     * Message related to the job
     */
    "message"?: string;

    /**
     * Clone operation Id
     */
    "opId"?: number;
}

/**
 * Detail About Clone Operation.
 */
export interface CloneOperationInformation {

    /**
     * Clone Statistics
     */
    "cloneStatistics"?: CloneStatistics;

    /**
     * If the operation is complete, the DateTime of completion. If operation is not complete, this is DateTime.MaxValue
     */
    "completionDate"?: Date;

    /**
     * DateTime when the operation was started
     */
    "creationDate"?: Date;

    /**
     * Shallow reference of the destination
     */
    "destinationObject"?: ShallowReference;

    /**
     * Shallow reference of the destination
     */
    "destinationPlan"?: ShallowReference;

    /**
     * Shallow reference of the destination
     */
    "destinationProject"?: ShallowReference;

    /**
     * If the operation has Failed, Message contains the reason for failure. Null otherwise.
     */
    "message"?: string;

    /**
     * The ID of the operation
     */
    "opId"?: number;

    /**
     * Shallow reference of the source
     */
    "sourceObject"?: ShallowReference;

    /**
     * Shallow reference of the source
     */
    "sourcePlan"?: ShallowReference;

    /**
     * Shallow reference of the source
     */
    "sourceProject"?: ShallowReference;

    /**
     * Url for geting the clone information
     */
    "url"?: string;
}

/**
 * 
 */
export interface CloneOptions {

    /**
     * If set to true requirements will be cloned
     */
    "cloneRequirements"?: boolean;

    /**
     * copy all suites from a source plan
     */
    "copyAllSuites"?: boolean;

    /**
     * copy ancestor hieracrchy
     */
    "copyAncestorHierarchy"?: boolean;

    /**
     * Name of the workitem type of the clone
     */
    "destinationWorkItemType"?: string;

    /**
     * Key value pairs where the key value is overridden by the value.
     */
    "overrideParameters"?: { [key: string]: string; };

    /**
     * Comment on the link that will link the new clone  test case to the original Set null for no comment
     */
    "relatedLinkComment"?: string;
}

/**
 * 
 */
export interface CloneStatistics {

    /**
     * Number of Requirments cloned so far.
     */
    "clonedRequirementsCount"?: number;

    /**
     * Number of shared steps cloned so far.
     */
    "clonedSharedStepsCount"?: number;

    /**
     * Number of test cases cloned so far
     */
    "clonedTestCasesCount"?: number;

    /**
     * Total number of requirements to be cloned
     */
    "totalRequirementsCount"?: number;

    /**
     * Total number of test cases to be cloned
     */
    "totalTestCasesCount"?: number;
}

/**
 * Response for Test Plan clone operation
 */
export interface CloneTestPlanOperationInformation {

    /**
     * Various information related to the clone
     */
    "cloneOperationResponse"?: CloneOperationCommonResponse;

    /**
     * Test Plan Clone create parameters
     */
    "cloneOptions"?: CloneOptions;

    /**
     * Information of destination Test Plan
     */
    "destinationTestPlan"?: TestPlan;

    /**
     * Information of source Test Plan
     */
    "sourceTestPlan"?: SourceTestplanResponse;
}

/**
 * Parameters for Test Plan clone operation
 */
export interface CloneTestPlanParams {

    /**
     * Test Plan Clone create parameters
     */
    "cloneOptions"?: CloneOptions;

    /**
     * Information about destination Test Plan
     */
    "destinationTestPlan"?: DestinationTestPlanCloneParams;

    /**
     * Information about source Test Plan
     */
    "sourceTestPlan"?: SourceTestPlanInfo;
}

/**
 * Response for Test Suite clone operation
 */
export interface CloneTestSuiteOperationInformation {

    /**
     * Information of newly cloned Test Suite
     */
    "clonedTestSuite"?: TestSuiteReferenceWithProject;

    /**
     * Various information related to the clone
     */
    "cloneOperationResponse"?: CloneOperationCommonResponse;

    /**
     * Test Plan Clone create parameters
     */
    "cloneOptions"?: CloneOptions;

    /**
     * Information of destination Test Suite
     */
    "destinationTestSuite"?: TestSuiteReferenceWithProject;

    /**
     * Information of source Test Suite
     */
    "sourceTestSuite"?: TestSuiteReferenceWithProject;
}

/**
 * Parameters for Test Suite clone operation
 */
export interface CloneTestSuiteParams {

    /**
     * Test Plan Clone create parameters
     */
    "cloneOptions"?: CloneOptions;

    /**
     * Information about destination Test Suite
     */
    "destinationTestSuite"?: DestinationTestSuiteInfo;

    /**
     * Information about source Test Suite
     */
    "sourceTestSuite"?: SourceTestSuiteInfo;
}

/**
 * 
 */
export interface CltCustomerIntelligenceData {
    "area"?: string;
    "feature"?: string;
    "properties"?: { [key: string]: any; };
}

/**
 * Represents the build configuration (platform, flavor) and coverage data for the build
 */
export interface CodeCoverageData {

    /**
     * Flavor of build for which data is retrieved/published
     */
    "buildFlavor"?: string;

    /**
     * Platform of build for which data is retrieved/published
     */
    "buildPlatform"?: string;

    /**
     * List of coverage data for the build
     */
    "coverageStats"?: Array<CodeCoverageStatistics>;
}

/**
 * Represents the code coverage statistics for a particular coverage label (modules, statements, blocks, etc.)
 */
export interface CodeCoverageStatistics {

    /**
     * Covered units
     */
    "covered"?: number;

    /**
     * Delta of coverage
     */
    "delta"?: number;

    /**
     * Is delta valid
     */
    "isDeltaAvailable"?: boolean;

    /**
     * Label of coverage data ("Blocks", "Statements", "Modules", etc.)
     */
    "label"?: string;

    /**
     * Position of label
     */
    "position"?: number;

    /**
     * Total units
     */
    "total"?: number;
}

/**
 * Represents the code coverage summary results Used to publish or retrieve code coverage summary against a build
 */
export interface CodeCoverageSummary {

    /**
     * Uri of build for which data is retrieved/published
     */
    "build"?: ShallowReference;

    /**
     * List of coverage data and details for the build
     */
    "coverageData"?: Array<CodeCoverageData>;

    /**
     * Uri of build against which difference in coverage is computed
     */
    "deltaBuild"?: ShallowReference;
}

/**
 * 
 */
export interface CodeCoverageSummary2 {
    "buildConfigurationId"?: number;
    "covered"?: number;
    "label"?: string;
    "position"?: number;
    "projectId"?: string;
    "total"?: number;
}

/**
 * 
 */
export interface CodeRepositoryReference {

    /**
     * Gets and sets the repository references.
     */
    "repositoryReference"?: { [key: string]: ReleaseManagementInputValue; };
}

/**
 * Defines the code result containing information of the searched files and its metadata.
 */
export interface CodeResult {

    /**
     * Collection of the result file.
     */
    "collection"?: Collection;

    /**
     * ContentId of the result file.
     */
    "contentId"?: string;

    /**
     * Name of the result file.
     */
    "fileName"?: string;

    /**
     * Dictionary of field to hit offsets in the result file. Key identifies the area in which hits were found, for ex: file content/file name etc.
     */
    "matches"?: { [key: string]: Array<Hit>; };

    /**
     * Path at which result file is present.
     */
    "path"?: string;

    /**
     * Project of the result file.
     */
    "project"?: Project;

    /**
     * Repository of the result file.
     */
    "repository"?: Repository;

    /**
     * Versions of the result file.
     */
    "versions"?: Array<Version>;
}

/**
 * Defines a code search request.
 */
export interface CodeSearchRequest extends EntitySearchRequest {
}

/**
 * Defines a code search response item.
 */
export interface CodeSearchResponse extends EntitySearchResponse {
}

/**
 * Defines the details of the collection.
 */
export interface Collection {

    /**
     * Name of the collection.
     */
    "name"?: string;
}

/**
 * Represents a comment which is one of potentially many in a comment thread.
 */
export interface Comment {

    /**
     * Links to other related objects.
     */
    "links"?: ReferenceLinks;

    /**
     * The author of the comment.
     */
    "author"?: IdentityRef;

    /**
     * The comment content.
     */
    "content"?: string;

    /**
     * The comment ID. IDs start at 1 and are unique to a pull request.
     */
    "id"?: number;

    /**
     * Whether or not this comment was soft-deleted.
     */
    "isDeleted"?: boolean;

    /**
     * The date the comment's content was last updated.
     */
    "lastContentUpdatedDate"?: Date;

    /**
     * The date the comment was last updated.
     */
    "lastUpdatedDate"?: Date;

    /**
     * The ID of the parent comment. This is used for replies.
     */
    "parentCommentId"?: number;

    /**
     * The date the comment was first published.
     */
    "publishedDate"?: Date;

    /**
     * A list of the users who have liked this comment.
     */
    "usersLiked"?: Array<IdentityRef>;
}

/**
 * Comment iteration context is used to identify which diff was being viewed when the thread was created.
 */
export interface CommentIterationContext {

    /**
     * The iteration of the file on the left side of the diff when the thread was created. If this value is equal to SecondComparingIteration, then this version is the common commit between the source and target branches of the pull request.
     */
    "firstComparingIteration"?: number;

    /**
     * The iteration of the file on the right side of the diff when the thread was created.
     */
    "secondComparingIteration"?: number;
}

/**
 * 
 */
export interface CommentPosition {

    /**
     * The line number of a thread's position. Starts at 1.
     */
    "line"?: number;

    /**
     * The character offset of a thread's position inside of a line. Starts at 0.
     */
    "offset"?: number;
}

/**
 * Represents a comment thread of a pull request. A thread contains meta data about the file it was left on along with one or more comments (an initial comment and the subsequent replies).
 */
export interface CommentThread {

    /**
     * Links to other related objects.
     */
    "links"?: ReferenceLinks;

    /**
     * A list of the comments.
     */
    "comments"?: Array<Comment>;

    /**
     * The comment thread id.
     */
    "id"?: number;

    /**
     * Set of identities related to this thread
     */
    "identities"?: { [key: string]: IdentityRef; };

    /**
     * Specify if the thread is deleted which happens when all comments are deleted.
     */
    "isDeleted"?: boolean;

    /**
     * The time this thread was last updated.
     */
    "lastUpdatedDate"?: Date;

    /**
     * Optional properties associated with the thread as a collection of key-value pairs.
     */
    "properties"?: PropertiesCollection;

    /**
     * The time this thread was published.
     */
    "publishedDate"?: Date;

    /**
     * Specify thread context such as position in left/right file.
     */
    "threadContext"?: CommentThreadContext;
}

/**
 * 
 */
export interface CommentThreadContext {

    /**
     * File path relative to the root of the repository. It's up to the client to use any path format.
     */
    "filePath"?: string;

    /**
     * Position of last character of the thread's span in left file.
     */
    "leftFileEnd"?: CommentPosition;

    /**
     * Position of first character of the thread's span in left file.
     */
    "leftFileStart"?: CommentPosition;

    /**
     * Position of last character of the thread's span in right file.
     */
    "rightFileEnd"?: CommentPosition;

    /**
     * Position of first character of the thread's span in right file.
     */
    "rightFileStart"?: CommentPosition;
}

/**
 * Comment tracking criteria is used to identify which iteration context the thread has been tracked to (if any) along with some detail about the original position and filename.
 */
export interface CommentTrackingCriteria {

    /**
     * The iteration of the file on the left side of the diff that the thread will be tracked to. Threads were tracked if this is greater than 0.
     */
    "firstComparingIteration"?: number;

    /**
     * Original filepath the thread was created on before tracking. This will be different than the current thread filepath if the file in question was renamed in a later iteration.
     */
    "origFilePath"?: string;

    /**
     * Original position of last character of the thread's span in left file.
     */
    "origLeftFileEnd"?: CommentPosition;

    /**
     * Original position of first character of the thread's span in left file.
     */
    "origLeftFileStart"?: CommentPosition;

    /**
     * Original position of last character of the thread's span in right file.
     */
    "origRightFileEnd"?: CommentPosition;

    /**
     * Original position of first character of the thread's span in right file.
     */
    "origRightFileStart"?: CommentPosition;

    /**
     * The iteration of the file on the right side of the diff that the thread will be tracked to. Threads were tracked if this is greater than 0.
     */
    "secondComparingIteration"?: number;
}

/**
 * Real time event (SignalR) for a completion errors on a pull request
 */
export interface CompletionErrorsEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface Condition {

    /**
     * Gets or sets the name of the condition. e.g. 'ReleaseStarted'.
     */
    "name"?: string;

    /**
     * Gets or set value of the condition.
     */
    "value"?: string;
}

/**
 * Configuration of the Test Point
 */
export interface Configuration {

    /**
     * Id of the Configuration Assigned to the Test Point
     */
    "configurationId"?: number;
}

/**
 * 
 */
export interface ConfigurationVariableValue {

    /**
     * Gets and sets if a variable can be overridden at deployment time or not.
     */
    "allowOverride"?: boolean;

    /**
     * Gets or sets as variable is secret or not.
     */
    "isSecret"?: boolean;

    /**
     * Gets and sets value of the configuration variable.
     */
    "value"?: string;
}

/**
 * 
 */
export interface ConsoleLogEvent extends RealtimeBuildEvent {
}

/**
 * Defines the data contract of a consumer.
 */
export interface Consumer {

    /**
     * ID of the consumer.
     */
    "consumerId"?: number;

    /**
     * Name of the consumer.
     */
    "consumerName"?: string;

    /**
     * Reference Links
     */
    "links"?: ReferenceLinks;

    /**
     * Gets this consumer's actions.
     */
    "actions"?: Array<ConsumerAction>;

    /**
     * Gets or sets this consumer's localized description.
     */
    "description"?: string;

    /**
     * Non-null only if subscriptions for this consumer are configured externally.
     */
    "externalConfiguration"?: ExternalConfigurationDescriptor;

    /**
     * Gets or sets this consumer's identifier.
     */
    "id"?: string;

    /**
     * Gets or sets this consumer's image URL, if any.
     */
    "imageUrl"?: string;

    /**
     * Gets or sets this consumer's information URL, if any.
     */
    "informationUrl"?: string;

    /**
     * Gets or sets this consumer's input descriptors.
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets this consumer's localized name.
     */
    "name"?: string;

    /**
     * The url for this resource
     */
    "url"?: string;
}

/**
 * Defines the data contract of a consumer action.
 */
export interface ConsumerAction {

    /**
     * Reference Links
     */
    "links"?: ReferenceLinks;

    /**
     * Gets or sets the flag indicating if resource version can be overridden when creating or editing a subscription.
     */
    "allowResourceVersionOverride"?: boolean;

    /**
     * Gets or sets the identifier of the consumer to which this action belongs.
     */
    "consumerId"?: string;

    /**
     * Gets or sets this action's localized description.
     */
    "description"?: string;

    /**
     * Gets or sets this action's identifier.
     */
    "id"?: string;

    /**
     * Gets or sets this action's input descriptors.
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets this action's localized name.
     */
    "name"?: string;

    /**
     * Gets or sets this action's supported event identifiers.
     */
    "supportedEventTypes"?: Array<string>;

    /**
     * Gets or sets this action's supported resource versions.
     */
    "supportedResourceVersions"?: { [key: string]: Array<string>; };

    /**
     * The url for this resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface ContainerImageTrigger extends ReleaseTriggerBase {
}

/**
 * 
 */
export interface ContinuousDeploymentDefinition {

    /**
     * The connected service associated with the continuous deployment
     */
    "connectedService"?: WebApiConnectedServiceRef;

    /**
     * The definition associated with the continuous deployment
     */
    "definition"?: XamlDefinitionReference;
    "gitBranch"?: string;
    "hostedServiceName"?: string;
    "project"?: TeamProjectReference;
    "repositoryId"?: string;
    "storageAccountName"?: string;
    "subscriptionId"?: string;
    "website"?: string;
    "webspace"?: string;
}

/**
 * 
 */
export interface ContinuousDeploymentTriggerIssue extends AutoTriggerIssue {
}

/**
 * Represents a continuous integration (CI) trigger.
 */
export interface ContinuousIntegrationTrigger extends BuildTrigger {
}

/**
 * An individual contribution made by an extension
 */
export interface Contribution extends ContributionBase {
}

/**
 * Base class shared by contributions and contribution types
 */
export interface ContributionBase {

    /**
     * Description of the contribution/type
     */
    "description"?: string;

    /**
     * Fully qualified identifier of the contribution/type
     */
    "id"?: string;

    /**
     * VisibleTo can be used to restrict whom can reference a given contribution/type. This value should be a list of publishers or extensions access is restricted too.  Examples: "ms" - Means only the "ms" publisher can reference this. "ms.vss-web" - Means only the "vss-web" extension from the "ms" publisher can reference this.
     */
    "visibleTo"?: Array<string>;
}

/**
 * Specifies a constraint that can be used to dynamically include/exclude a given contribution
 */
export interface ContributionConstraint {

    /**
     * An optional property that can be specified to group constraints together. All constraints within a group are AND'd together (all must be evaluate to True in order for the contribution to be included). Different groups of constraints are OR'd (only one group needs to evaluate to True for the contribution to be included).
     */
    "group"?: number;

    /**
     * Fully qualified identifier of a shared constraint
     */
    "id"?: string;

    /**
     * If true, negate the result of the filter (include the contribution if the applied filter returns false instead of true)
     */
    "inverse"?: boolean;

    /**
     * Name of the IContributionFilter plugin
     */
    "name"?: string;

    /**
     * Properties that are fed to the contribution filter class
     */
    "properties"?: JObject;

    /**
     * Constraints can be optionally be applied to one or more of the relationships defined in the contribution. If no relationships are defined then all relationships are associated with the constraint. This means the default behaviour will elimiate the contribution from the tree completely if the constraint is applied.
     */
    "relationships"?: Array<string>;
}

/**
 * A query that can be issued for contribution nodes
 */
export interface ContributionNodeQuery {

    /**
     * The contribution ids of the nodes to find.
     */
    "contributionIds"?: Array<string>;

    /**
     * Contextual information that can be leveraged by contribution constraints
     */
    "dataProviderContext"?: DataProviderContext;

    /**
     * Indicator if contribution provider details should be included in the result.
     */
    "includeProviderDetails"?: boolean;
}

/**
 * Result of a contribution node query.  Wraps the resulting contribution nodes and provider details.
 */
export interface ContributionNodeQueryResult {

    /**
     * Map of contribution ids to corresponding node.
     */
    "nodes"?: { [key: string]: ClientContributionNode; };

    /**
     * Map of provder ids to the corresponding provider details object.
     */
    "providerDetails"?: { [key: string]: ClientContributionProviderDetails; };
}

/**
 * Description about a property of a contribution type
 */
export interface ContributionPropertyDescription {

    /**
     * Description of the property
     */
    "description"?: string;

    /**
     * Name of the property
     */
    "name"?: string;

    /**
     * True if this property is required
     */
    "required"?: boolean;
}

/**
 * 
 */
export interface ContributionProviderDetails {

    /**
     * Friendly name for the provider.
     */
    "displayName"?: string;

    /**
     * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
     */
    "name"?: string;

    /**
     * Properties associated with the provider
     */
    "properties"?: { [key: string]: string; };

    /**
     * Version of contributions assoicated with this contribution provider.
     */
    "version"?: string;
}

/**
 * A contribution type, given by a json schema
 */
export interface ContributionType extends ContributionBase {
}

/**
 * Represent a control in the form.
 */
export interface Control {

    /**
     * Contribution for the control.
     */
    "contribution"?: WitContribution;

    /**
     * Type of the control.
     */
    "controlType"?: string;

    /**
     * Height of the control, for html controls.
     */
    "height"?: number;

    /**
     * The id for the layout node.
     */
    "id"?: string;

    /**
     * A value indicating whether this layout node has been inherited from a parent layout.  This is expected to only be only set by the combiner.
     */
    "inherited"?: boolean;

    /**
     * A value indicating if the layout node is contribution or not.
     */
    "isContribution"?: boolean;

    /**
     * Label for the field
     */
    "label"?: string;

    /**
     * Inner text of the control.
     */
    "metadata"?: string;

    /**
     * Order in which the control should appear in its group.
     */
    "order"?: number;

    /**
     * A value indicating whether this layout node has been overridden by a child layout.
     */
    "overridden"?: boolean;

    /**
     * A value indicating if the control is readonly.
     */
    "readOnly"?: boolean;

    /**
     * A value indicating if the control should be hidden or not.
     */
    "visible"?: boolean;

    /**
     * Watermark text for the textbox.
     */
    "watermark"?: string;
}

/**
 * 
 */
export interface ControlOptions {

    /**
     * Always run the job.
     */
    "alwaysRun"?: boolean;

    /**
     * Indicates whether to continuer job on error or not.
     */
    "continueOnError"?: boolean;

    /**
     * Indicates the job enabled or not.
     */
    "enabled"?: boolean;
}

/**
 * A profile attribute which always has a value for each profile.
 */
export interface CoreProfileAttribute extends ProfileAttributeBase {
}

/**
 * 
 */
export interface CounterGroup {
    "groupName"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface CounterInstanceSamples {
    "count"?: number;
    "counterInstanceId"?: string;
    "nextRefreshTime"?: Date;
    "values"?: Array<CounterSample>;
}

/**
 * 
 */
export interface CounterSample {
    "baseValue"?: number;
    "computedValue"?: string;
    "counterFrequency"?: number;
    "counterInstanceId"?: string;
    "counterType"?: string;
    "intervalEndDate"?: Date;
    "intervalNumber"?: number;
    "rawValue"?: number;
    "systemFrequency"?: number;
    "timeStamp"?: number;
}

/**
 * 
 */
export interface CounterSampleQueryDetails {
    "counterInstanceId"?: string;
    "fromInterval"?: number;
    "toInterval"?: number;
}

/**
 * 
 */
export interface CounterSamplesResult {
    "count"?: number;
    "maxBatchSize"?: number;
    "totalSamplesCount"?: number;
    "values"?: Array<CounterInstanceSamples>;
}

/**
 * 
 */
export interface CounterVariable {
    "prefix"?: string;
    "seed"?: number;
    "value"?: number;
}

/**
 * 
 */
export interface Coverage2 {
    "coverageId"?: number;
    "dateCreated"?: Date;
    "dateModified"?: Date;
    "lastError"?: string;
    "state"?: string;
}

/**
 * 
 */
export interface CoverageStatistics {
    "blocksCovered"?: number;
    "blocksNotCovered"?: number;
    "linesCovered"?: number;
    "linesNotCovered"?: number;
    "linesPartiallyCovered"?: number;
}

/**
 * 
 */
export interface CreatePlan {

    /**
     * Description of the plan
     */
    "description"?: string;

    /**
     * Name of the plan to create.
     */
    "name"?: string;

    /**
     * Plan properties.
     */
    "properties"?: any;
}

/**
 * 
 */
export interface CreateProcessModel {

    /**
     * Description of the process
     */
    "description"?: string;

    /**
     * Name of the process
     */
    "name"?: string;

    /**
     * The ID of the parent process
     */
    "parentProcessTypeId"?: string;

    /**
     * Reference name of process being created. If not specified, server will assign a unique reference name
     */
    "referenceName"?: string;
}

/**
 * Request object/class for creating a rule on a work item type.
 */
export interface CreateProcessRuleRequest {

    /**
     * List of actions to take when the rule is triggered.
     */
    "actions"?: Array<RuleAction>;

    /**
     * List of conditions when the rule should be triggered.
     */
    "conditions"?: Array<RuleCondition>;

    /**
     * Indicates if the rule is disabled.
     */
    "isDisabled"?: boolean;

    /**
     * Name for the rule.
     */
    "name"?: string;
}

/**
 * Class for create work item type request
 */
export interface CreateProcessWorkItemTypeRequest {

    /**
     * Color hexadecimal code to represent the work item type
     */
    "color"?: string;

    /**
     * Description of the work item type
     */
    "description"?: string;

    /**
     * Icon to represent the work item type
     */
    "icon"?: string;

    /**
     * Parent work item type for work item type
     */
    "inheritsFrom"?: string;

    /**
     * True if the work item type need to be disabled
     */
    "isDisabled"?: boolean;

    /**
     * Name of work item type
     */
    "name"?: string;
}

/**
 * 
 */
export interface CreateProfileContext {
    "ciData"?: { [key: string]: any; };
    "contactWithOffers"?: boolean;
    "countryName"?: string;
    "displayName"?: string;
    "emailAddress"?: string;
    "hasAccount"?: boolean;
    "language"?: string;
    "phoneNumber"?: string;
}

/**
 * 
 */
export interface CreateTestMessageLogEntryRequest {
    "projectName"?: string;
    "testMessageLogEntry"?: Array<TestMessageLogEntry>;
    "testRunId"?: number;
}

/**
 * 
 */
export interface CreateTestResultsRequest {
    "projectName"?: string;
    "results"?: Array<LegacyTestCaseResult>;
}

/**
 * 
 */
export interface CreateTestRunRequest {
    "projectName"?: string;
    "results"?: Array<LegacyTestCaseResult>;
    "testRun"?: LegacyTestRun;
    "testSettings"?: LegacyTestSettings;
}

/**
 * 
 */
export interface CustomArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * A custom field information.
 */
export interface CustomTestField {

    /**
     * Field Name.
     */
    "fieldName"?: string;

    /**
     * Field value.
     */
    "value"?: any;
}

/**
 * 
 */
export interface CustomTestFieldDefinition {
    "fieldId"?: number;
    "fieldName"?: string;
}

/**
 * Model of a Dashboard.
 */
export interface Dashboard {
    "links"?: ReferenceLinks;

    /**
     * Description of the dashboard.
     */
    "description"?: string;

    /**
     * Server defined version tracking value, used for edit collision detection.
     */
    "eTag"?: string;

    /**
     * ID of the Dashboard. Provided by service at creation time.
     */
    "id"?: string;

    /**
     * Name of the Dashboard.
     */
    "name"?: string;

    /**
     * ID of the Owner for a dashboard. For any legacy dashboards, this would be the unique identifier for the team associated with the dashboard.
     */
    "ownerId"?: string;

    /**
     * Position of the dashboard, within a dashboard group. If unset at creation time, position is decided by the service.
     */
    "position"?: number;

    /**
     * Interval for client to automatically refresh the dashboard. Expressed in minutes.
     */
    "refreshInterval"?: number;
    "url"?: string;

    /**
     * The set of Widgets on the dashboard.
     */
    "widgets"?: Array<Widget>;
}

/**
 * Describes a list of dashboards associated to an owner. Currently, teams own dashboard groups.
 */
export interface DashboardGroup {
    "links"?: ReferenceLinks;

    /**
     * A list of Dashboards held by the Dashboard Group
     */
    "dashboardEntries"?: Array<DashboardGroupEntry>;
    "url"?: string;
}

/**
 * Dashboard group entry, wraping around Dashboard (needed?)
 */
export interface DashboardGroupEntry extends Dashboard {
}

/**
 * Response from RestAPI when saving and editing DashboardGroupEntry
 */
export interface DashboardGroupEntryResponse extends DashboardGroupEntry {
}

/**
 * 
 */
export interface DashboardResponse extends DashboardGroupEntry {
}

/**
 * Contextual information that data providers can examine when populating their data
 */
export interface DataProviderContext {

    /**
     * Generic property bag that contains context-specific properties that data providers can use when populating their data dictionary
     */
    "properties"?: { [key: string]: any; };
}

/**
 * 
 */
export interface DataProviderExceptionDetails {

    /**
     * The type of the exception that was thrown.
     */
    "exceptionType"?: string;

    /**
     * Message that is associated with the exception.
     */
    "message"?: string;

    /**
     * The StackTrace from the exception turned into a string.
     */
    "stackTrace"?: string;
}

/**
 * A query that can be issued for data provider data
 */
export interface DataProviderQuery {

    /**
     * Contextual information to pass to the data providers
     */
    "context"?: DataProviderContext;

    /**
     * The contribution ids of the data providers to resolve
     */
    "contributionIds"?: Array<string>;
}

/**
 * Result structure from calls to GetDataProviderData
 */
export interface DataProviderResult {

    /**
     * This is the set of data providers that were requested, but either they were defined as client providers, or as remote providers that failed and may be retried by the client.
     */
    "clientProviders"?: { [key: string]: ClientDataProviderQuery; };

    /**
     * Property bag of data keyed off of the data provider contribution id
     */
    "data"?: { [key: string]: any; };

    /**
     * Set of exceptions that occurred resolving the data providers.
     */
    "exceptions"?: { [key: string]: DataProviderExceptionDetails; };

    /**
     * List of data providers resolved in the data-provider query
     */
    "resolvedProviders"?: Array<ResolvedDataProvider>;

    /**
     * Scope name applied to this data provider result.
     */
    "scopeName"?: string;

    /**
     * Scope value applied to this data provider result.
     */
    "scopeValue"?: string;

    /**
     * Property bag of shared data that was contributed to by any of the individual data providers
     */
    "sharedData"?: { [key: string]: any; };
}

/**
 * Data bag that any data provider can contribute to. This shared dictionary is returned in the data provider result.
 */
export interface DataProviderSharedData {
    "additionalProperties"?: any;
}

/**
 * 
 */
export interface DataSource {
    "authenticationScheme"?: AuthenticationSchemeReference;
    "callbackContextTemplate"?: string;
    "callbackRequiredTemplate"?: string;
    "endpointUrl"?: string;
    "headers"?: Array<AuthorizationHeader>;
    "initialContextTemplate"?: string;
    "name"?: string;
    "requestContent"?: string;
    "requestVerb"?: string;
    "resourceUrl"?: string;
    "resultSelector"?: string;
}

/**
 * 
 */
export interface DataSourceBinding extends DataSourceBindingBase {
}

/**
 * Represents binding of data source for the service endpoint request.
 */
export interface DataSourceBindingBase {

    /**
     * Pagination format supported by this data source(ContinuationToken/SkipTop).
     */
    "callbackContextTemplate"?: string;

    /**
     * Subsequent calls needed?
     */
    "callbackRequiredTemplate"?: string;

    /**
     * Gets or sets the name of the data source.
     */
    "dataSourceName"?: string;

    /**
     * Gets or sets the endpoint Id.
     */
    "endpointId"?: string;

    /**
     * Gets or sets the url of the service endpoint.
     */
    "endpointUrl"?: string;

    /**
     * Gets or sets the authorization headers.
     */
    "headers"?: Array<AuthorizationHeader>;

    /**
     * Defines the initial value of the query params
     */
    "initialContextTemplate"?: string;

    /**
     * Gets or sets the parameters for the data source.
     */
    "parameters"?: { [key: string]: string; };

    /**
     * Gets or sets http request body
     */
    "requestContent"?: string;

    /**
     * Gets or sets http request verb
     */
    "requestVerb"?: string;

    /**
     * Gets or sets the result selector.
     */
    "resultSelector"?: string;

    /**
     * Gets or sets the result template.
     */
    "resultTemplate"?: string;

    /**
     * Gets or sets the target of the data source.
     */
    "target"?: string;
}

/**
 * 
 */
export interface DataSourceDetails {

    /**
     * Gets or sets the data source name.
     */
    "dataSourceName"?: string;

    /**
     * Gets or sets the data source url.
     */
    "dataSourceUrl"?: string;

    /**
     * Gets or sets the request headers.
     */
    "headers"?: Array<AuthorizationHeader>;

    /**
     * Gets or sets the initialization context used for the initial call to the data source
     */
    "initialContextTemplate"?: string;

    /**
     * Gets the parameters of data source.
     */
    "parameters"?: { [key: string]: string; };

    /**
     * Gets or sets the data source request content.
     */
    "requestContent"?: string;

    /**
     * Gets or sets the data source request verb. Get/Post are the only implemented types
     */
    "requestVerb"?: string;

    /**
     * Gets or sets the resource url of data source.
     */
    "resourceUrl"?: string;

    /**
     * Gets or sets the result selector.
     */
    "resultSelector"?: string;
}

/**
 * 
 */
export interface DateRange {

    /**
     * End of the date range.
     */
    "end"?: Date;

    /**
     * Start of the date range.
     */
    "start"?: Date;
}

/**
 * 
 */
export interface DatedTestFieldData {
    "date"?: Date;
    "value"?: TestFieldData;
}

/**
 * A dual-purpose data object, the debug entry is used by the client to publish the symbol file (with file's blob identifier, which can be calculated from VSTS hashing algorithm) or query the file (with a client key). Since the symbol server tries to return a matched symbol file with the richest information level, it may not always point to the same symbol file for different queries with same client key.
 */
export interface DebugEntry extends ResourceBase {
}

/**
 * A batch of debug entry to create.
 */
export interface DebugEntryCreateBatch {

    /**
     * The debug entries.
     */
    "debugEntries"?: Array<DebugEntry>;
}

/**
 * 
 */
export interface DefaultAfnStripBinding {
    "testCaseId"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface DefinitionEnvironmentReference {

    /**
     * Definition environment ID.
     */
    "definitionEnvironmentId"?: number;

    /**
     * Definition environment name.
     */
    "definitionEnvironmentName"?: string;

    /**
     * ReleaseDefinition ID.
     */
    "releaseDefinitionId"?: number;

    /**
     * ReleaseDefinition name.
     */
    "releaseDefinitionName"?: string;
}

/**
 * Represents a reference to a definition.
 */
export interface DefinitionReference {

    /**
     * The date this version of the definition was created.
     */
    "createdDate"?: Date;

    /**
     * The ID of the referenced definition.
     */
    "id"?: number;

    /**
     * The name of the referenced definition.
     */
    "name"?: string;

    /**
     * The folder path of the definition.
     */
    "path"?: string;

    /**
     * A reference to the project.
     */
    "project"?: TeamProjectReference;

    /**
     * The definition revision number.
     */
    "revision"?: number;

    /**
     * The definition's URI.
     */
    "uri"?: string;

    /**
     * The REST URL of the definition.
     */
    "url"?: string;
}

/**
 * 
 */
export interface DefinitionResourceReference {

    /**
     * Indicates whether the resource is authorized for use.
     */
    "authorized"?: boolean;

    /**
     * The id of the resource.
     */
    "id"?: string;

    /**
     * A friendly name for the resource.
     */
    "name"?: string;

    /**
     * The type of the resource.
     */
    "type"?: string;
}

/**
 * 
 */
export interface DeleteTestRunRequest {
    "projectName"?: string;
    "testRunIds"?: Array<number>;
}

/**
 * Data contract for Data of Delivery View
 */
export interface DeliveryViewData extends PlanViewData {
}

/**
 * Collection of properties, specific to the DeliveryTimelineView
 */
export interface DeliveryViewPropertyCollection {

    /**
     * Card settings
     */
    "cardSettings"?: CardSettings;

    /**
     * Field criteria
     */
    "criteria"?: Array<FilterClause>;

    /**
     * Markers. Will be missing/null if there are no markers.
     */
    "markers"?: Array<Marker>;

    /**
     * Team backlog mappings
     */
    "teamBacklogMappings"?: Array<TeamBacklogMapping>;
}

/**
 * 
 */
export interface Demand {

    /**
     * Gets and sets the name of demand.
     */
    "name"?: string;

    /**
     * Gets and sets the value of demand.
     */
    "value"?: string;
}

/**
 * 
 */
export interface DemandEquals extends Demand {
}

/**
 * 
 */
export interface DemandExists extends Demand {
}

/**
 * 
 */
export interface DemandMinimumVersion extends Demand {
}

/**
 * Represents a dependency.
 */
export interface Dependency {

    /**
     * The event. The dependency is satisfied when the referenced object emits this event.
     */
    "event"?: string;

    /**
     * The scope. This names the object referenced by the dependency.
     */
    "scope"?: string;
}

/**
 * 
 */
export interface DependencyBinding {
    "key"?: string;
    "value"?: string;
}

/**
 * 
 */
export interface DependencyData {
    "input"?: string;
    "map"?: Array<{ [key: string]: Array<{ [key: string]: string; }>; }>;
}

/**
 * 
 */
export interface DependsOn {
    "input"?: string;
    "map"?: Array<DependencyBinding>;
}

/**
 * 
 */
export interface DeployPhase {

    /**
     * Gets and sets the name of deploy phase.
     */
    "name"?: string;

    /**
     * Gets and sets the rank of deploy phase.
     */
    "rank"?: number;

    /**
     * Gets and sets the reference name of deploy phase.
     */
    "refName"?: string;

    /**
     * Gets and sets the workflow tasks for the deploy phase.
     */
    "workflowTasks"?: Array<WorkflowTask>;
}

/**
 * 
 */
export interface Deployment {
    "type"?: string;

    /**
     * Gets attempt number.
     */
    "attempt"?: number;

    /**
     * Gets the date on which deployment is complete.
     */
    "completedOn"?: Date;

    /**
     * Gets the list of condition associated with deployment.
     */
    "conditions"?: Array<Condition>;

    /**
     * Gets release definition environment id.
     */
    "definitionEnvironmentId"?: number;

    /**
     * Gets the unique identifier for deployment.
     */
    "id"?: number;

    /**
     * Gets the identity who last modified the deployment.
     */
    "lastModifiedBy"?: IdentityRef;

    /**
     * Gets the date on which deployment is last modified.
     */
    "lastModifiedOn"?: Date;

    /**
     * Gets list of PostDeployApprovals.
     */
    "postDeployApprovals"?: Array<ReleaseApproval>;

    /**
     * Gets list of PreDeployApprovals.
     */
    "preDeployApprovals"?: Array<ReleaseApproval>;

    /**
     * Gets or sets project reference.
     */
    "projectReference"?: ProjectReference;

    /**
     * Gets the date on which deployment is queued.
     */
    "queuedOn"?: Date;

    /**
     * Gets the reference of release.
     */
    "release"?: ReleaseReference;

    /**
     * Gets releaseDefinitionReference which specifies the reference of the release definition to which the deployment is associated.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * Gets releaseEnvironmentReference which specifies the reference of the release environment to which the deployment is associated.
     */
    "releaseEnvironment"?: ReleaseEnvironmentShallowReference;

    /**
     * Gets the identity who requested.
     */
    "requestedBy"?: IdentityRef;

    /**
     * Gets the identity for whom deployment is requested.
     */
    "requestedFor"?: IdentityRef;

    /**
     * Gets the date on which deployment is scheduled.
     */
    "scheduledDeploymentTime"?: Date;

    /**
     * Gets the date on which deployment is started.
     */
    "startedOn"?: Date;
}

/**
 * 
 */
export interface DeploymentApprovalCompletedEvent {
    "approval"?: ReleaseApproval;
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * 
 */
export interface DeploymentApprovalPendingEvent {
    "approval"?: ReleaseApproval;
    "approvalOptions"?: ApprovalOptions;
    "completedApprovals"?: Array<ReleaseApproval>;
    "data"?: { [key: string]: any; };
    "deployment"?: Deployment;
    "isMultipleRankApproval"?: boolean;
    "pendingApprovals"?: Array<ReleaseApproval>;
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * 
 */
export interface DeploymentAttempt {

    /**
     * Deployment attempt.
     */
    "attempt"?: number;

    /**
     * ID of the deployment.
     */
    "deploymentId"?: number;

    /**
     * Specifies whether deployment has started or not.
     */
    "hasStarted"?: boolean;

    /**
     * ID of deployment.
     */
    "id"?: number;

    /**
     * All the issues related to the deployment.
     */
    "issues"?: Array<Issue>;

    /**
     * Identity who last modified this deployment.
     */
    "lastModifiedBy"?: IdentityRef;

    /**
     * Time when this deployment last modified.
     */
    "lastModifiedOn"?: Date;

    /**
     * Post deployment gates that executed in this deployment.
     */
    "postDeploymentGates"?: ReleaseGates;

    /**
     * Pre deployment gates that executed in this deployment.
     */
    "preDeploymentGates"?: ReleaseGates;

    /**
     * When this deployment queued on.
     */
    "queuedOn"?: Date;

    /**
     * List of release deployphases executed in this deployment.
     */
    "releaseDeployPhases"?: Array<ReleaseDeployPhase>;

    /**
     * Identity who requested this deployment.
     */
    "requestedBy"?: IdentityRef;

    /**
     * Identity for this deployment requested.
     */
    "requestedFor"?: IdentityRef;
}

/**
 * 
 */
export interface DeploymentAuthorizationInfo {

    /**
     * List of resources.
     */
    "resources"?: Array<string>;

    /**
     * ID of the tenant.
     */
    "tenantId"?: string;

    /**
     * Access token key.
     */
    "vstsAccessTokenKey"?: string;
}

/**
 * Deployment information for type "Build"
 */
export interface DeploymentBuild extends Deployment {
}

/**
 * 
 */
export interface DeploymentCompletedEvent {
    "comment"?: string;
    "data"?: { [key: string]: any; };
    "deployment"?: Deployment;
    "environment"?: ReleaseEnvironment;
    "project"?: ProjectReference;
}

/**
 * Deployment information for type "Deploy"
 */
export interface DeploymentDeploy extends Deployment {
}

/**
 * 
 */
export interface DeploymentGatesChangeEvent {
    "gateNames"?: Array<string>;
}

/**
 * Deployment group.
 */
export interface DeploymentGroup extends DeploymentGroupReference {
}

/**
 * Properties to create Deployment group.
 */
export interface DeploymentGroupCreateParameter {

    /**
     * Description of the deployment group.
     */
    "description"?: string;

    /**
     * Name of the deployment group.
     */
    "name"?: string;

    /**
     * Identifier of the deployment pool in which deployment agents are registered.
     */
    "poolId"?: number;
}

/**
 * Properties of Deployment pool to create Deployment group.
 */
export interface DeploymentGroupCreateParameterPoolProperty {

    /**
     * Deployment pool identifier.
     */
    "id"?: number;
}

/**
 * Deployment group metrics.
 */
export interface DeploymentGroupMetrics {

    /**
     * List of deployment group properties. And types of metrics provided for those properties.
     */
    "columnsHeader"?: MetricsColumnsHeader;

    /**
     * Deployment group.
     */
    "deploymentGroup"?: DeploymentGroupReference;

    /**
     * Values of properties and the metrics. E.g. 1: total count of deployment targets for which 'TargetState' is 'offline'. E.g. 2: Average time of deployment to the deployment targets for which 'LastJobStatus' is 'passed' and 'TargetState' is 'online'.
     */
    "rows"?: Array<MetricsRow>;
}

/**
 * Deployment group reference. This is useful for referring a deployment group in another object.
 */
export interface DeploymentGroupReference {

    /**
     * Deployment group identifier.
     */
    "id"?: number;

    /**
     * Name of the deployment group.
     */
    "name"?: string;

    /**
     * Deployment pool in which deployment agents are registered.
     */
    "pool"?: TaskAgentPoolReference;

    /**
     * Project to which the deployment group belongs.
     */
    "project"?: ProjectReference;
}

/**
 * Deployment group update parameter.
 */
export interface DeploymentGroupUpdateParameter {

    /**
     * Description of the deployment group.
     */
    "description"?: string;

    /**
     * Name of the deployment group.
     */
    "name"?: string;
}

/**
 * 
 */
export interface DeploymentInput extends BaseDeploymentInput {
}

/**
 * 
 */
export interface DeploymentJob {

    /**
     * Parent task of all executed tasks.
     */
    "job"?: ReleaseTask;

    /**
     * List of  executed tasks with in job.
     */
    "tasks"?: Array<ReleaseTask>;
}

/**
 * Deployment target.
 */
export interface DeploymentMachine {

    /**
     * Deployment agent.
     */
    "agent"?: TaskAgent;

    /**
     * Deployment target Identifier.
     */
    "id"?: number;

    /**
     * Properties of the deployment target.
     */
    "properties"?: PropertiesCollection;

    /**
     * Tags of the deployment target.
     */
    "tags"?: Array<string>;
}

/**
 * 
 */
export interface DeploymentMachineChangedData extends DeploymentMachine {
}

/**
 * 
 */
export interface DeploymentMachineGroup extends DeploymentMachineGroupReference {
}

/**
 * 
 */
export interface DeploymentMachineGroupReference {
    "id"?: number;
    "name"?: string;
    "pool"?: TaskAgentPoolReference;
    "project"?: ProjectReference;
}

/**
 * 
 */
export interface DeploymentMachinesChangeEvent {
    "machineGroupReference"?: DeploymentGroupReference;
    "machines"?: Array<DeploymentMachineChangedData>;
}

/**
 * 
 */
export interface DeploymentManualInterventionPendingEvent {
    "deployment"?: Deployment;
    "emailRecipients"?: Array<string>;
    "environmentOwner"?: IdentityRef;
    "manualIntervention"?: ManualIntervention;
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * Deployment pool summary.
 */
export interface DeploymentPoolSummary {

    /**
     * List of deployment groups referring to the deployment pool.
     */
    "deploymentGroups"?: Array<DeploymentGroupReference>;

    /**
     * Number of deployment agents that are offline.
     */
    "offlineAgentsCount"?: number;

    /**
     * Number of deployment agents that are online.
     */
    "onlineAgentsCount"?: number;

    /**
     * Deployment pool.
     */
    "pool"?: TaskAgentPoolReference;
}

/**
 * 
 */
export interface DeploymentQueryParameters {

    /**
     * Query deployments based specified artifact source id.
     */
    "artifactSourceId"?: string;

    /**
     * Query deployments based specified artifact type id.
     */
    "artifactTypeId"?: string;

    /**
     * Query deployments based specified artifact versions.
     */
    "artifactVersions"?: Array<string>;

    /**
     * Query deployments number of deployments per environment.
     */
    "deploymentsPerEnvironment"?: number;

    /**
     * Query deployments of specified environments.
     */
    "environments"?: Array<DefinitionEnvironmentReference>;

    /**
     * Specify deleted deployments should return or not.
     */
    "isDeleted"?: boolean;

    /**
     * Query deployments based specified source branch.
     */
    "sourceBranch"?: string;
}

/**
 * 
 */
export interface DeploymentStartedEvent {
    "environment"?: ReleaseEnvironment;
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * Deployment target update parameter.
 */
export interface DeploymentTargetUpdateParameter {

    /**
     * Identifier of the deployment target.
     */
    "id"?: number;
    "tags"?: Array<string>;
}

/**
 * Deployment information for type "Test"
 */
export interface DeploymentTest extends Deployment {
}

/**
 * Represents a build process supported by the build definition designer.
 */
export interface DesignerProcess extends BuildProcess {
}

/**
 * Represents the target for the build process.
 */
export interface DesignerProcessTarget {

    /**
     * Agent specification for the build process.
     */
    "agentSpecification"?: AgentSpecification;
}

/**
 * Destination Test Plan create parameters
 */
export interface DestinationTestPlanCloneParams extends TestPlanCreateParams {
}

/**
 * Destination Test Suite information for Test Suite clone operation
 */
export interface DestinationTestSuiteInfo {

    /**
     * Destination Suite Id
     */
    "id"?: number;

    /**
     * Destination Project Name
     */
    "project"?: string;
}

/**
 * 
 */
export interface DiagnosticIdentity {
    "displayName"?: string;
    "emailAddress"?: string;
    "id"?: string;
}

/**
 * 
 */
export interface DiagnosticLogMetadata {
    "agentId"?: number;
    "agentName"?: string;
    "fileName"?: string;
    "phaseName"?: string;
    "phaseResult"?: string;
    "poolId"?: number;
}

/**
 * 
 */
export interface DiagnosticNotification {
    "eventId"?: number;
    "eventType"?: string;
    "id"?: number;
    "messages"?: Array<NotificationDiagnosticLogMessage>;
    "recipients"?: { [key: string]: DiagnosticRecipient; };
    "result"?: string;
    "stats"?: { [key: string]: number; };
    "subscriptionId"?: string;
}

/**
 * 
 */
export interface DiagnosticRecipient {
    "recipient"?: DiagnosticIdentity;
    "status"?: string;
}

/**
 * 
 */
export interface Diagnostics {
    "diagnosticStoreConnectionString"?: string;
    "lastModifiedTime"?: Date;
    "relativePathToDiagnosticFiles"?: string;
}

/**
 * Real time event (SignalR) for a discussions update on a pull request
 */
export interface DiscussionsUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface DockerProcess extends BuildProcess {
}

/**
 * 
 */
export interface DownloadAttachmentsRequest {
    "ids"?: Array<number>;
    "lengths"?: Array<number>;
}

/**
 * 
 */
export interface DropAccessData {
    "dropContainerUrl"?: string;
    "sasKey"?: string;
}

/**
 * This is a temporary class to provide the details for the test run environment.
 */
export interface DtlEnvironmentDetails {
    "csmContent"?: string;
    "csmParameters"?: string;
    "subscriptionName"?: string;
}

/**
 * 
 */
export interface EmailHtmlSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * 
 */
export interface EmailPlaintextSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * 
 */
export interface EmailRecipients {

    /**
     * List of email addresses.
     */
    "emailAddresses"?: Array<string>;

    /**
     * List of TFS IDs guids.
     */
    "tfsIds"?: Array<string>;
}

/**
 * 
 */
export interface EndpointAuthorization {

    /**
     * Gets or sets the parameters for the selected authorization scheme.
     */
    "parameters"?: { [key: string]: string; };

    /**
     * Gets or sets the scheme used for service endpoint authentication.
     */
    "scheme"?: string;
}

/**
 * 
 */
export interface EndpointOperationStatus {
    "state"?: string;
    "statusMessage"?: string;
}

/**
 * Represents url of the service endpoint.
 */
export interface EndpointUrl {

    /**
     * Gets or sets the dependency bindings.
     */
    "dependsOn"?: DependsOn;

    /**
     * Gets or sets the display name of service endpoint url.
     */
    "displayName"?: string;

    /**
     * Gets or sets the help text of service endpoint url.
     */
    "helpText"?: string;

    /**
     * Gets or sets the visibility of service endpoint url.
     */
    "isVisible"?: string;

    /**
     * Gets or sets the value of service endpoint url.
     */
    "value"?: string;
}

/**
 * Base contract for search request types without scroll support.
 */
export interface EntitySearchRequest extends EntitySearchRequestBase {
}

/**
 * Base class for search request types.
 */
export interface EntitySearchRequestBase {

    /**
     * Filters to be applied. Set it to null if there are no filters to be applied.
     */
    "filters"?: { [key: string]: Array<string>; };

    /**
     * The search text.
     */
    "searchText"?: string;
}

/**
 * Defines the base contract for search response.
 */
export interface EntitySearchResponse {

    /**
     * A dictionary storing an array of <code>Filter</code> object against each facet.
     */
    "facets"?: { [key: string]: Array<Filter>; };

    /**
     * Numeric code indicating any additional information: 0 - Ok, 1 - Account is being reindexed, 2 - Account indexing has not started, 3 - Invalid Request, 4 - Prefix wildcard query not supported, 5 - MultiWords with code facet not supported, 6 - Account is being onboarded, 7 - Account is being onboarded or reindexed, 8 - Top value trimmed to maxresult allowed 9 - Branches are being indexed, 10 - Faceting not enabled, 11 - Work items not accessible, 19 - Phrase queries with code type filters not supported, 20 - Wildcard queries with code type filters not supported. Any other info code is used for internal purpose.
     */
    "infoCode"?: number;
}

/**
 * Properties to create Environment.
 */
export interface EnvironmentCreateParameter {

    /**
     * Description of the environment.
     */
    "description"?: string;

    /**
     * Name of the environment.
     */
    "name"?: string;
}

/**
 * EnvironmentDeploymentExecutionRecord.
 */
export interface EnvironmentDeploymentExecutionRecord {

    /**
     * Definition of the environment deployment execution owner
     */
    "definition"?: TaskOrchestrationOwner;

    /**
     * Id of the Environment
     */
    "environmentId"?: number;

    /**
     * Finish time of the environment deployment execution
     */
    "finishTime"?: Date;

    /**
     * Id of the Environment deployment execution history record
     */
    "id"?: number;

    /**
     * Owner of the environment deployment execution record
     */
    "owner"?: TaskOrchestrationOwner;

    /**
     * Plan Id
     */
    "planId"?: string;

    /**
     * Plan type of the environment deployment execution record
     */
    "planType"?: string;

    /**
     * Queue time of the environment deployment execution
     */
    "queueTime"?: Date;

    /**
     * Request identifier of the Environment deployment execution history record
     */
    "requestIdentifier"?: string;

    /**
     * Project Id
     */
    "scopeId"?: string;

    /**
     * Service group Id
     */
    "serviceGroupId"?: number;

    /**
     * Service owner Id
     */
    "serviceOwner"?: string;

    /**
     * Start time of the environment deployment execution
     */
    "startTime"?: Date;
}

/**
 * Defines policy on environment queuing at Release Management side queue. We will send to Environment Runner [creating pre-deploy and other steps] only when the policies mentioned are satisfied.
 */
export interface EnvironmentExecutionPolicy {

    /**
     * This policy decides, how many environments would be with Environment Runner.
     */
    "concurrencyCount"?: number;

    /**
     * Queue depth in the EnvironmentQueue table, this table keeps the environment entries till Environment Runner is free [as per it's policy] to take another environment for running.
     */
    "queueDepthCount"?: number;
}

/**
 * Environment.
 */
export interface EnvironmentInstance {

    /**
     * Identity reference of the user who created the Environment.
     */
    "createdBy"?: IdentityRef;

    /**
     * Creation time of the Environment
     */
    "createdOn"?: Date;

    /**
     * Description of the Environment.
     */
    "description"?: string;

    /**
     * Id of the Environment
     */
    "id"?: number;

    /**
     * Identity reference of the user who last modified the Environment.
     */
    "lastModifiedBy"?: IdentityRef;

    /**
     * Last modified time of the Environment
     */
    "lastModifiedOn"?: Date;

    /**
     * Name of the Environment.
     */
    "name"?: string;
    "serviceGroups"?: Array<ServiceGroupReference>;
}

/**
 * 
 */
export interface EnvironmentOptions {

    /**
     * Gets and sets as the auto link workitems or not.
     */
    "autoLinkWorkItems"?: boolean;

    /**
     * Gets and sets as the badge enabled or not.
     */
    "badgeEnabled"?: boolean;

    /**
     * Gets and sets as the publish deployment status or not.
     */
    "publishDeploymentStatus"?: boolean;

    /**
     * Gets and sets as the.pull request deployment enabled or not.
     */
    "pullRequestDeploymentEnabled"?: boolean;
}

/**
 * 
 */
export interface EnvironmentReference {
    "id"?: number;
    "name"?: string;
}

/**
 * 
 */
export interface EnvironmentRetentionPolicy {

    /**
     * Gets and sets the number of days to keep environment.
     */
    "daysToKeep"?: number;

    /**
     * Gets and sets the number of releases to keep.
     */
    "releasesToKeep"?: number;

    /**
     * Gets and sets as the build to be retained or not.
     */
    "retainBuild"?: boolean;
}

/**
 * 
 */
export interface EnvironmentTrigger {

    /**
     * Definition environment ID on which this trigger applicable.
     */
    "definitionEnvironmentId"?: number;

    /**
     * ReleaseDefinition ID on which this trigger applicable.
     */
    "releaseDefinitionId"?: number;

    /**
     * Gets or sets the trigger content.
     */
    "triggerContent"?: string;
}

/**
 * 
 */
export interface EnvironmentTriggerContent {

    /**
     * Gets or sets action.
     */
    "action"?: string;

    /**
     * Gets or sets list of event types.
     */
    "eventTypes"?: Array<string>;
}

/**
 * Properties to update Environment.
 */
export interface EnvironmentUpdateParameter {

    /**
     * Description of the environment.
     */
    "description"?: string;

    /**
     * Name of the environment.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ErrorDetails {
    "lastErrorDate"?: Date;
    "messageText"?: string;
    "occurrences"?: number;
    "request"?: string;
    "scenarioName"?: string;
    "stackTrace"?: string;
    "testCaseName"?: string;
}

/**
 * Encapsulates the properties of an event.
 */
export interface Event {

    /**
     * Gets or sets the UTC-based date and time that this event was created.
     */
    "createdDate"?: Date;

    /**
     * Gets or sets the detailed message associated with this event.
     */
    "detailedMessage"?: FormattedEventMessage;

    /**
     * Gets or sets the type of this event.
     */
    "eventType"?: string;

    /**
     * Gets or sets the unique identifier of this event.
     */
    "id"?: string;

    /**
     * Gets or sets the (brief) message associated with this event.
     */
    "message"?: FormattedEventMessage;

    /**
     * Gets or sets the identifier of the publisher that raised this event.
     */
    "publisherId"?: string;

    /**
     * Gets or sets the data associated with this event.
     */
    "resource"?: any;

    /**
     * Gets or sets the resource containers.
     */
    "resourceContainers"?: { [key: string]: ResourceContainer; };

    /**
     * Gets or sets the version of the data associated with this event.
     */
    "resourceVersion"?: string;

    /**
     * Gets or sets the Session Token that can be used in further interactions
     */
    "sessionToken"?: SessionToken;
}

/**
 * Defines an "actor" for an event.
 */
export interface EventActor {

    /**
     * Required: This is the identity of the user for the specified role.
     */
    "id"?: string;

    /**
     * Required: The event specific name of a role.
     */
    "role"?: string;
}

/**
 * 
 */
export interface EventBacklogStatus {
    "captureTime"?: Date;
    "jobId"?: string;
    "lastEventBatchStartTime"?: Date;
    "lastEventProcessedTime"?: Date;
    "lastJobBatchStartTime"?: Date;
    "lastJobProcessedTime"?: Date;
    "oldestPendingEventTime"?: Date;
    "publisher"?: string;
    "unprocessedEvents"?: number;
}

/**
 * 
 */
export interface EventBatch {
    "endTime"?: string;
    "eventCounts"?: { [key: string]: number; };
    "eventIds"?: string;
    "notificationCounts"?: { [key: string]: number; };
    "preProcessEndTime"?: string;
    "preProcessStartTime"?: string;
    "processEndTime"?: string;
    "processStartTime"?: string;
    "startTime"?: string;
    "subscriptionCounts"?: { [key: string]: number; };
}

/**
 * 
 */
export interface EventProcessingLog extends NotificationJobDiagnosticLog {
}

/**
 * Defines a scope for an event.
 */
export interface EventScope {

    /**
     * Required: This is the identity of the scope for the type.
     */
    "id"?: string;

    /**
     * Optional: The display name of the scope
     */
    "name"?: string;

    /**
     * Required: The event specific type of a scope.
     */
    "type"?: string;
}

/**
 * A transform request specify the properties of a notification event to be transformed.
 */
export interface EventTransformRequest {

    /**
     * Event payload.
     */
    "eventPayload"?: string;

    /**
     * Event type.
     */
    "eventType"?: string;

    /**
     * System inputs.
     */
    "systemInputs"?: { [key: string]: string; };
}

/**
 * Result of transforming a notification event.
 */
export interface EventTransformResult {

    /**
     * Transformed html content.
     */
    "content"?: string;

    /**
     * Calculated data.
     */
    "data"?: any;

    /**
     * Calculated system inputs.
     */
    "systemInputs"?: { [key: string]: string; };
}

/**
 * Describes a type of event
 */
export interface EventTypeDescriptor {

    /**
     * A localized description of the event type
     */
    "description"?: string;

    /**
     * A unique id for the event type
     */
    "id"?: string;

    /**
     * Event-specific inputs
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * A localized friendly name for the event type
     */
    "name"?: string;

    /**
     * A unique id for the publisher of this event type
     */
    "publisherId"?: string;

    /**
     * Supported versions for the event's resource payloads.
     */
    "supportedResourceVersions"?: Array<string>;

    /**
     * The url for this resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface EventsConfig {
}

/**
 * Encapsulates events result properties. It defines the total number of events used and the number of matched events.
 */
export interface EventsEvaluationResult {

    /**
     * Count of events evaluated.
     */
    "count"?: number;

    /**
     * Count of matched events.
     */
    "matchedCount"?: number;
}

/**
 * 
 */
export interface ExecutionInput {
}

/**
 * 
 */
export interface ExpressionFilter extends BaseSubscriptionFilter {
}

/**
 * Subscription Filter Clause represents a single clause in a subscription filter e.g. If the subscription has the following criteria "Project Name = [Current Project] AND Assigned To = [Me] it will be represented as two Filter Clauses Clause 1: Index = 1, Logical Operator: NULL  , FieldName = 'Project Name', Operator = '=', Value = '[Current Project]' Clause 2: Index = 2, Logical Operator: 'AND' , FieldName = 'Assigned To' , Operator = '=', Value = '[Me]'
 */
export interface ExpressionFilterClause {
    "fieldName"?: string;

    /**
     * The order in which this clause appeared in the filter query
     */
    "index"?: number;

    /**
     * Logical Operator 'AND', 'OR' or NULL (only for the first clause in the filter)
     */
    "logicalOperator"?: string;
    "operator"?: string;
    "value"?: string;
}

/**
 * Represents a hierarchy of SubscritionFilterClauses that have been grouped together through either adding a group in the WebUI or using parethesis in the Subscription condition string
 */
export interface ExpressionFilterGroup {

    /**
     * The index of the last FilterClause in this group
     */
    "end"?: number;

    /**
     * Level of the group, since groups can be nested for each nested group the level will increase by 1
     */
    "level"?: number;

    /**
     * The index of the first FilterClause in this group
     */
    "start"?: number;
}

/**
 * 
 */
export interface ExpressionFilterModel {

    /**
     * Flat list of clauses in this subscription
     */
    "clauses"?: Array<ExpressionFilterClause>;

    /**
     * Grouping of clauses in the subscription
     */
    "groups"?: Array<ExpressionFilterGroup>;

    /**
     * Max depth of the Subscription tree
     */
    "maxGroupLevel"?: number;
}

/**
 * 
 */
export interface ExpressionValidationItem extends ValidationItem {
}

/**
 * Represents the extensions part of the layout
 */
export interface Extension {

    /**
     * Id of the extension
     */
    "id"?: string;

    /**
     * Friendly name of this extension.
     */
    "name"?: string;
}

/**
 * Contract for handling the extension acquisition process
 */
export interface ExtensionAcquisitionRequest {

    /**
     * The id of the subscription used for purchase
     */
    "billingId"?: string;

    /**
     * The marketplace id (publisherName.extensionName) for the item
     */
    "itemId"?: string;

    /**
     * Additional properties which can be added to the request.
     */
    "properties"?: JObject;

    /**
     * How many licenses should be purchased
     */
    "quantity"?: number;
}

/**
 * Audit log for an extension
 */
export interface ExtensionAuditLog {

    /**
     * Collection of audit log entries
     */
    "entries"?: Array<ExtensionAuditLogEntry>;

    /**
     * Extension that the change was made for
     */
    "extensionName"?: string;

    /**
     * Publisher that the extension is part of
     */
    "publisherName"?: string;
}

/**
 * An audit log entry for an extension
 */
export interface ExtensionAuditLogEntry {

    /**
     * Change that was made to extension
     */
    "auditAction"?: string;

    /**
     * Date at which the change was made
     */
    "auditDate"?: Date;

    /**
     * Extra information about the change
     */
    "comment"?: string;

    /**
     * Represents the user who made the change
     */
    "updatedBy"?: IdentityRef;
}

/**
 * 
 */
export interface ExtensionAuthorization {
    "id"?: string;
    "scopes"?: Array<string>;
}

/**
 * 
 */
export interface ExtensionBadge {
    "description"?: string;
    "imgUri"?: string;
    "link"?: string;
}

/**
 * Represents a single collection for extension data documents
 */
export interface ExtensionDataCollection {

    /**
     * The name of the collection
     */
    "collectionName"?: string;

    /**
     * A list of documents belonging to the collection
     */
    "documents"?: Array<JObject>;

    /**
     * The type of the collection's scope, such as Default or User
     */
    "scopeType"?: string;

    /**
     * The value of the collection's scope, such as Current or Me
     */
    "scopeValue"?: string;
}

/**
 * Represents a query to receive a set of extension data collections
 */
export interface ExtensionDataCollectionQuery {

    /**
     * A list of collections to query
     */
    "collections"?: Array<ExtensionDataCollection>;
}

/**
 * 
 */
export interface ExtensionEvent {

    /**
     * The extension which has been updated
     */
    "extension"?: PublishedExtension;

    /**
     * The current version of the extension that was updated
     */
    "extensionVersion"?: string;

    /**
     * Name of the collection for which the extension was requested
     */
    "host"?: ExtensionHost;

    /**
     * Gallery host url
     */
    "links"?: ExtensionEventUrls;

    /**
     * Represents the user who initiated the update
     */
    "modifiedBy"?: IdentityRef;
}

/**
 * Base class for an event callback for an extension
 */
export interface ExtensionEventCallback {

    /**
     * The uri of the endpoint that is hit when an event occurs
     */
    "uri"?: string;
}

/**
 * Collection of event callbacks - endpoints called when particular extension events occur.
 */
export interface ExtensionEventCallbackCollection {

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension disable has occurred.
     */
    "postDisable"?: ExtensionEventCallback;

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension enable has occurred.
     */
    "postEnable"?: ExtensionEventCallback;

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install has completed.
     */
    "postInstall"?: ExtensionEventCallback;

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension uninstall has occurred.
     */
    "postUninstall"?: ExtensionEventCallback;

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension update has occurred.
     */
    "postUpdate"?: ExtensionEventCallback;

    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install is about to occur.  Response indicates whether to proceed or abort.
     */
    "preInstall"?: ExtensionEventCallback;

    /**
     * For multi-version extensions, defines an endpoint that gets called via an OPTIONS request to determine the particular version of the extension to be used
     */
    "versionCheck"?: ExtensionEventCallback;
}

/**
 * 
 */
export interface ExtensionEventUrls extends ExtensionUrls {
}

/**
 * 
 */
export interface ExtensionFile {
    "assetType"?: string;
    "language"?: string;
    "source"?: string;
}

/**
 * 
 */
export interface ExtensionHost {
    "id"?: string;
    "name"?: string;
}

/**
 * Represents the component pieces of an extensions fully qualified name, along with the fully qualified name.
 */
export interface ExtensionIdentifier {

    /**
     * The ExtensionName component part of the fully qualified ExtensionIdentifier
     */
    "extensionName"?: string;

    /**
     * The PublisherName component part of the fully qualified ExtensionIdentifier
     */
    "publisherName"?: string;
}

/**
 * How an extension should handle including contributions based on licensing
 */
export interface ExtensionLicensing {

    /**
     * A list of contributions which deviate from the default licensing behavior
     */
    "overrides"?: Array<LicensingOverride>;
}

/**
 * Base class for extension properties which are shared by the extension manifest and the extension model
 */
export interface ExtensionManifest {

    /**
     * Uri used as base for other relative uri's defined in extension
     */
    "baseUri"?: string;

    /**
     * List of shared constraints defined by this extension
     */
    "constraints"?: Array<ContributionConstraint>;

    /**
     * List of contributions made by this extension
     */
    "contributions"?: Array<Contribution>;

    /**
     * List of contribution types defined by this extension
     */
    "contributionTypes"?: Array<ContributionType>;

    /**
     * List of explicit demands required by this extension
     */
    "demands"?: Array<string>;

    /**
     * Collection of endpoints that get called when particular extension events occur
     */
    "eventCallbacks"?: ExtensionEventCallbackCollection;

    /**
     * Secondary location that can be used as base for other relative uri's defined in extension
     */
    "fallbackBaseUri"?: string;

    /**
     * Language Culture Name set by the Gallery
     */
    "language"?: string;

    /**
     * How this extension behaves with respect to licensing
     */
    "licensing"?: ExtensionLicensing;

    /**
     * Version of the extension manifest format/content
     */
    "manifestVersion"?: number;

    /**
     * Default user claims applied to all contributions (except the ones which have been speficied restrictedTo explicitly) to control the visibility of a contribution.
     */
    "restrictedTo"?: Array<string>;

    /**
     * List of all oauth scopes required by this extension
     */
    "scopes"?: Array<string>;

    /**
     * The ServiceInstanceType(Guid) of the VSTS service that must be available to an account in order for the extension to be installed
     */
    "serviceInstanceType"?: string;
}

/**
 * Policy with a set of permissions on extension operations
 */
export interface ExtensionPolicy {
}

/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface ExtensionRequest {

    /**
     * Required message supplied if the request is rejected
     */
    "rejectMessage"?: string;

    /**
     * Date at which the request was made
     */
    "requestDate"?: Date;

    /**
     * Represents the user who made the request
     */
    "requestedBy"?: IdentityRef;

    /**
     * Optional message supplied by the requester justifying the request
     */
    "requestMessage"?: string;

    /**
     * Date at which the request was resolved
     */
    "resolveDate"?: Date;

    /**
     * Represents the user who resolved the request
     */
    "resolvedBy"?: IdentityRef;
}

/**
 * 
 */
export interface ExtensionRequestEvent {

    /**
     * The extension which has been requested
     */
    "extension"?: PublishedExtension;

    /**
     * Information about the host for which this extension is requested
     */
    "host"?: ExtensionHost;

    /**
     * Name of the collection for which the extension was requested
     */
    "hostName"?: string;

    /**
     * Gallery host url
     */
    "links"?: ExtensionRequestUrls;

    /**
     * The extension request object
     */
    "request"?: ExtensionRequest;
}

/**
 * 
 */
export interface ExtensionRequestUrls extends ExtensionUrls {
}

/**
 * 
 */
export interface ExtensionRequestsEvent {

    /**
     * The extension which has been requested
     */
    "extension"?: PublishedExtension;

    /**
     * Information about the host for which this extension is requested
     */
    "host"?: ExtensionHost;

    /**
     * Gallery host url
     */
    "links"?: ExtensionRequestUrls;

    /**
     * The extension request object
     */
    "requests"?: Array<ExtensionRequest>;
}

/**
 * 
 */
export interface ExtensionShare {
    "id"?: string;
    "isOrg"?: boolean;
    "name"?: string;
    "type"?: string;
}

/**
 * The state of an extension
 */
export interface ExtensionState extends InstalledExtensionState {
}

/**
 * 
 */
export interface ExtensionStatistic {
    "statisticName"?: string;
    "value"?: number;
}

/**
 * Summary of Extensions in the organization.
 */
export interface ExtensionSummaryData extends SummaryData {
}

/**
 * 
 */
export interface ExtensionUrls {

    /**
     * Url of the extension icon
     */
    "extensionIcon"?: string;

    /**
     * Link to view the extension details page
     */
    "extensionPage"?: string;
}

/**
 * 
 */
export interface ExtensionVersion {
    "assetUri"?: string;
    "badges"?: Array<ExtensionBadge>;
    "fallbackAssetUri"?: string;
    "files"?: Array<ExtensionFile>;
    "lastUpdated"?: Date;
    "properties"?: Array<{ [key: string]: string; }>;
    "validationResultMessage"?: string;
    "version"?: string;
    "versionDescription"?: string;
}

/**
 * Describes how to configure a subscription that is managed externally.
 */
export interface ExternalConfigurationDescriptor {

    /**
     * Url of the site to create this type of subscription.
     */
    "createSubscriptionUrl"?: string;

    /**
     * The name of an input property that contains the URL to edit a subscription.
     */
    "editSubscriptionPropertyName"?: string;

    /**
     * True if the external configuration applies only to hosted.
     */
    "hostedOnly"?: boolean;
}

/**
 * Failing since information of a test result.
 */
export interface FailingSince {

    /**
     * Build reference since failing.
     */
    "build"?: BuildReference;

    /**
     * Time since failing.
     */
    "date"?: Date;

    /**
     * Release reference since failing.
     */
    "release"?: ReleaseReference;
}

/**
 * Class to represent favorite entry.
 */
export interface FavoriteItem {

    /**
     * Application specific data for the entry.
     */
    "data"?: string;

    /**
     * Unique Id of the the entry.
     */
    "id"?: string;

    /**
     * Display text for favorite entry.
     */
    "name"?: string;

    /**
     * Application specific favorite entry type. Empty or Null represents that Favorite item is a Folder.
     */
    "type"?: string;
}

/**
 * A container for artifacts.
 */
export interface Feed extends FeedCore {
}

/**
 * 
 */
export interface FeedBatchData {
    "data"?: FeedBatchOperationData;
}

/**
 * 
 */
export interface FeedBatchOperationData {
}

/**
 * A container that encapsulates the state of the feed after a create, update, or delete.
 */
export interface FeedChange {

    /**
     * The state of the feed after a after a create, update, or delete operation completed.
     */
    "feed"?: Feed;

    /**
     * A token that identifies the next change in the log of changes.
     */
    "feedContinuationToken"?: number;

    /**
     * A token that identifies the latest package change for this feed.  This can be used to quickly determine if there have been any changes to packages in a specific feed.
     */
    "latestPackageContinuationToken"?: number;
}

/**
 * A result set containing the feed changes for the range that was requested.
 */
export interface FeedChangesResponse {
    "links"?: ReferenceLinks;

    /**
     * The number of changes in this set.
     */
    "count"?: number;

    /**
     * A container that encapsulates the state of the feed after a create, update, or delete.
     */
    "feedChanges"?: Array<FeedChange>;

    /**
     * When iterating through the log of changes this value indicates the value that should be used for the next continuation token.
     */
    "nextFeedContinuationToken"?: number;
}

/**
 * An object that contains all of the settings for a specific feed.
 */
export interface FeedCore {

    /**
     * This will either be the feed GUID or the feed GUID and view GUID depending on how the feed was accessed.
     */
    "fullyQualifiedId"?: string;

    /**
     * Full name of the view, in feed@view format.
     */
    "fullyQualifiedName"?: string;

    /**
     * A GUID that uniquely identifies this feed.
     */
    "id"?: string;

    /**
     * If set, all packages in the feed are immutable.  It is important to note that feed views are immutable; therefore, this flag will always be set for views.
     */
    "isReadOnly"?: boolean;

    /**
     * A name for the feed. feed names must follow these rules: <list type="bullet"><item><description> Must not exceed 64 characters </description></item><item><description> Must not contain whitespaces </description></item><item><description> Must not start with an underscore or a period </description></item><item><description> Must not end with a period </description></item><item><description> Must not contain any of the following illegal characters: <![CDATA[ @, ~, ;, {, }, \, +, =, <, >, |, /, \\, ?, :, &, $, *, \", #, [, ] ]]></description></item></list>
     */
    "name"?: string;

    /**
     * OBSOLETE: This should always be true.  Setting to false will override all sources in UpstreamSources.
     */
    "upstreamEnabled"?: boolean;

    /**
     * A list of sources that this feed will fetch packages from.  An empty list indicates that this feed will not search any additional sources for packages.
     */
    "upstreamSources"?: Array<UpstreamSource>;

    /**
     * Definition of the view.
     */
    "view"?: FeedView;

    /**
     * View Id.
     */
    "viewId"?: string;

    /**
     * View name.
     */
    "viewName"?: string;
}

/**
 * Permissions for a feed.
 */
export interface FeedPermission {

    /**
     * Display name for the identity.
     */
    "displayName"?: string;

    /**
     * Identity associated with this role.
     */
    "identityDescriptor"?: IdentityDescriptor;

    /**
     * Id of the identity associated with this role.
     */
    "identityId"?: string;
}

/**
 * Retention policy settings.
 */
export interface FeedRetentionPolicy {

    /**
     * This attribute is deprecated and is not honoured by retention
     */
    "ageLimitInDays"?: number;

    /**
     * Maximum versions to preserve per package and package type.
     */
    "countLimit"?: number;

    /**
     * Number of days to preserve a package version after its latest download.
     */
    "daysToKeepRecentlyDownloadedPackages"?: number;
}

/**
 * Update a feed definition with these new values.
 */
export interface FeedUpdate {

    /**
     * If set, the feed will allow upload of packages that exist on the upstream
     */
    "allowUpstreamNameConflict"?: boolean;

    /**
     * If set, this feed supports generation of package badges.
     */
    "badgesEnabled"?: boolean;

    /**
     * The view that the feed administrator has indicated is the default experience for readers.
     */
    "defaultViewId"?: string;

    /**
     * A description for the feed.  Descriptions must not exceed 255 characters.
     */
    "description"?: string;

    /**
     * If set, feed will hide all deleted/unpublished versions
     */
    "hideDeletedPackageVersions"?: boolean;

    /**
     * A GUID that uniquely identifies this feed.
     */
    "id"?: string;

    /**
     * A name for the feed. feed names must follow these rules: <list type="bullet"><item><description> Must not exceed 64 characters </description></item><item><description> Must not contain whitespaces </description></item><item><description> Must not start with an underscore or a period </description></item><item><description> Must not end with a period </description></item><item><description> Must not contain any of the following illegal characters: <![CDATA[ @, ~, ;, {, }, \, +, =, <, >, |, /, \\, ?, :, &, $, *, \", #, [, ] ]]></description></item></list>
     */
    "name"?: string;

    /**
     * OBSOLETE: If set, the feed can proxy packages from an upstream feed
     */
    "upstreamEnabled"?: boolean;

    /**
     * A list of sources that this feed will fetch packages from.  An empty list indicates that this feed will not search any additional sources for packages.
     */
    "upstreamSources"?: Array<UpstreamSource>;
}

/**
 * A view on top of a feed.
 */
export interface FeedView {

    /**
     * Related REST links.
     */
    "links"?: ReferenceLinks;

    /**
     * Id of the view.
     */
    "id"?: string;

    /**
     * Name of the view.
     */
    "name"?: string;

    /**
     * Url of the view.
     */
    "url"?: string;
}

/**
 * 
 */
export interface FetchTestResultsRequest {
    "idAndRevs"?: Array<TestCaseResultIdAndRev>;
    "includeActionResults"?: boolean;
    "projectName"?: string;
}

/**
 * 
 */
export interface FetchTestResultsResponse {
    "actionResults"?: Array<TestActionResult>;
    "attachments"?: Array<TestResultAttachment>;
    "deletedIds"?: Array<LegacyTestCaseResultIdentifier>;
    "results"?: Array<LegacyTestCaseResult>;
    "testParameters"?: Array<TestResultParameter>;
}

/**
 * Describes a list of dependent fields for a rule.
 */
export interface FieldDependentRule extends WorkItemTrackingResource {
}

/**
 * 
 */
export interface FieldDetailsForTestResults {

    /**
     * Group by field name
     */
    "fieldName"?: string;

    /**
     * Group by field values
     */
    "groupsForField"?: Array<any>;
}

/**
 * Object bag storing the set of permissions relevant to this plan
 */
export interface FieldInfo {

    /**
     * The additional field display name
     */
    "displayName"?: string;

    /**
     * Indicates if the field definition is for an identity field.
     */
    "isIdentity"?: boolean;

    /**
     * The additional field reference name
     */
    "referenceName"?: string;
}

/**
 * 
 */
export interface FieldInputValues extends InputValues {
}

/**
 * 
 */
export interface FieldModel {

    /**
     * Description about field
     */
    "description"?: string;

    /**
     * ID of the field
     */
    "id"?: string;
    "isIdentity"?: boolean;

    /**
     * Name of the field
     */
    "name"?: string;

    /**
     * Url to the field
     */
    "url"?: string;

    /**
     * Reference to picklist in this field
     */
    "pickList"?: PickListMetadataModel;
}

/**
 * An abstracted reference to a field
 */
export interface FieldReference {

    /**
     * fieldRefName for the field
     */
    "referenceName"?: string;

    /**
     * Full http link to more information about the field
     */
    "url"?: string;
}

/**
 * 
 */
export interface FieldRuleModel {
    "actions"?: Array<RuleActionModel>;
    "conditions"?: Array<RuleConditionModel>;
    "friendlyName"?: string;
    "id"?: string;
    "isDisabled"?: boolean;
    "isSystem"?: boolean;
}

/**
 * 
 */
export interface FieldSetting {
}

/**
 * 
 */
export interface FieldUpdate {
    "description"?: string;
    "id"?: string;
}

/**
 * 
 */
export interface FieldValuesQuery extends InputValuesQuery {
}

/**
 * Describes a set fields for rule evaluation.
 */
export interface FieldsToEvaluate {

    /**
     * List of fields to evaluate.
     */
    "fields"?: Array<string>;

    /**
     * Updated field values to evaluate.
     */
    "fieldUpdates"?: { [key: string]: any; };

    /**
     * Initial field values.
     */
    "fieldValues"?: { [key: string]: any; };

    /**
     * URL of the work item type for which the rules need to be executed.
     */
    "rulesFrom"?: Array<string>;
}

/**
 * 
 */
export interface FileContentMetadata {
    "contentType"?: string;
    "encoding"?: number;
    "extension"?: string;
    "fileName"?: string;
    "isBinary"?: boolean;
    "isImage"?: boolean;
    "vsLink"?: string;
}

/**
 * 
 */
export interface FileCoverage {

    /**
     * List of line blocks along with their coverage status
     */
    "lineBlocksCoverage"?: Array<LineBlockCoverage>;

    /**
     * File path for which coverage information is sought for
     */
    "path"?: string;
}

/**
 * 
 */
export interface FileCoverageRequest {
    "filePath"?: string;
    "pullRequestBaseIterationId"?: number;
    "pullRequestId"?: number;
    "pullRequestIterationId"?: number;
    "repoId"?: string;
}

/**
 * Provides properties that describe file differences
 */
export interface FileDiff {

    /**
     * The collection of line diff blocks
     */
    "lineDiffBlocks"?: Array<LineDiffBlock>;

    /**
     * Original path of item if different from current path.
     */
    "originalPath"?: string;

    /**
     * Current path of item
     */
    "path"?: string;
}

/**
 * Provides parameters that describe inputs for the file diff
 */
export interface FileDiffParams {

    /**
     * Original path of the file
     */
    "originalPath"?: string;

    /**
     * Current path of the file
     */
    "path"?: string;
}

/**
 * Provides properties that describe inputs for the file diffs
 */
export interface FileDiffsCriteria {

    /**
     * Commit ID of the base version
     */
    "baseVersionCommit"?: string;

    /**
     * List of parameters for each of the files for which we need to get the file diff
     */
    "fileDiffParams"?: Array<FileDiffParams>;

    /**
     * Commit ID of the target version
     */
    "targetVersionCommit"?: string;
}

/**
 * Describes a filter bucket item representing the total matches of search result, name and id.
 */
export interface Filter {

    /**
     * Id of the filter bucket.
     */
    "id"?: string;

    /**
     * Name of the filter bucket.
     */
    "name"?: string;

    /**
     * Count of matches in the filter bucket.
     */
    "resultCount"?: number;
}

/**
 * 
 */
export interface FilterClause {
    "fieldName"?: string;
    "index"?: number;
    "logicalOperator"?: string;
    "operator"?: string;
    "value"?: string;
}

/**
 * 
 */
export interface FilterGroup {
    "end"?: number;
    "level"?: number;
    "start"?: number;
}

/**
 * 
 */
export interface FilterPointQuery {
    "planId"?: number;
    "pointIds"?: Array<number>;
    "pointOutcome"?: Array<string>;
    "resultState"?: Array<string>;
}

/**
 * 
 */
export interface Folder {

    /**
     * Identity who created this folder.
     */
    "createdBy"?: IdentityRef;

    /**
     * Time when this folder created.
     */
    "createdOn"?: Date;

    /**
     * Description of the folder.
     */
    "description"?: string;

    /**
     * Identity who last changed this folder.
     */
    "lastChangedBy"?: IdentityRef;

    /**
     * Time when this folder last changed.
     */
    "lastChangedDate"?: Date;

    /**
     * path of the folder.
     */
    "path"?: string;

    /**
     * The project.
     */
    "project"?: TeamProjectReference;
}

/**
 * Represents the ability to build forks of the selected repository.
 */
export interface Forks {

    /**
     * Indicates whether a build should use secrets when building forks of the selected repository.
     */
    "allowSecrets"?: boolean;

    /**
     * Indicates whether the trigger should queue builds for forks of the selected repository.
     */
    "enabled"?: boolean;
}

/**
 * 
 */
export interface FormLayout {

    /**
     * Gets and sets extensions list
     */
    "extensions"?: Array<Extension>;

    /**
     * Top level tabs of the layout.
     */
    "pages"?: Array<Page>;

    /**
     * Headers controls of the layout.
     */
    "systemControls"?: Array<Control>;
}

/**
 * Provides different formats of an event message
 */
export interface FormattedEventMessage {

    /**
     * Gets or sets the html format of the message
     */
    "html"?: string;

    /**
     * Gets or sets the markdown format of the message
     */
    "markdown"?: string;

    /**
     * Gets or sets the raw text of the message
     */
    "text"?: string;
}

/**
 * 
 */
export interface FunctionCoverage {
    "class"?: string;
    "name"?: string;
    "namespace"?: string;
    "sourceFile"?: string;
    "statistics"?: CoverageStatistics;
}

/**
 * 
 */
export interface FunctionCoverage2 {
    "blocksCovered"?: number;
    "blocksNotCovered"?: number;
    "class"?: string;
    "coverageId"?: number;
    "functionId"?: number;
    "linesCovered"?: number;
    "linesNotCovered"?: number;
    "linesPartiallyCovered"?: number;
    "moduleId"?: number;
    "name"?: string;
    "namespace"?: string;
    "sourceFile"?: string;
}

/**
 * 
 */
export interface GateUpdateMetadata {

    /**
     * Comment.
     */
    "comment"?: string;

    /**
     * Name of gate to be ignored.
     */
    "gatesToIgnore"?: Array<string>;
}

/**
 * Represents a gated check-in trigger.
 */
export interface GatedCheckInTrigger extends BuildTrigger {
}

/**
 * 
 */
export interface GatesDeployPhase extends DeployPhase {
}

/**
 * 
 */
export interface GatesDeploymentInput extends BaseDeploymentInput {
}

/**
 * 
 */
export interface GeneratedNotification {
    "recipients"?: Array<DiagnosticIdentity>;
}

/**
 * 
 */
export interface GeoRegion {
    "regionCode"?: string;
}

/**
 * A Git annotated tag.
 */
export interface GitAnnotatedTag {

    /**
     * The tagging Message
     */
    "message"?: string;

    /**
     * The name of the annotated tag.
     */
    "name"?: string;

    /**
     * The objectId (Sha1Id) of the tag.
     */
    "objectId"?: string;

    /**
     * User info and date of tagging.
     */
    "taggedBy"?: GitUserDate;

    /**
     * Tagged git object.
     */
    "taggedObject"?: GitObject;
    "url"?: string;
}

/**
 * 
 */
export interface GitArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * 
 */
export interface GitAsyncRefOperation {
    "links"?: ReferenceLinks;
    "detailedStatus"?: GitAsyncRefOperationDetail;
    "parameters"?: GitAsyncRefOperationParameters;

    /**
     * A URL that can be used to make further requests for status about the operation
     */
    "url"?: string;
}

/**
 * Information about the progress of a cherry pick or revert operation.
 */
export interface GitAsyncRefOperationDetail {

    /**
     * Indicates if there was a conflict generated when trying to cherry pick or revert the changes.
     */
    "conflict"?: boolean;

    /**
     * The current commit from the list of commits that are being cherry picked or reverted.
     */
    "currentCommitId"?: string;

    /**
     * Detailed information about why the cherry pick or revert failed to complete.
     */
    "failureMessage"?: string;

    /**
     * A number between 0 and 1 indicating the percent complete of the operation.
     */
    "progress"?: number;

    /**
     * Indicates if the operation went beyond the maximum time allowed for a cherry pick or revert operation.
     */
    "timedout"?: boolean;
}

/**
 * Parameters that are provided in the request body when requesting to cherry pick or revert.
 */
export interface GitAsyncRefOperationParameters {

    /**
     * Proposed target branch name for the cherry pick or revert operation.
     */
    "generatedRefName"?: string;

    /**
     * The target branch for the cherry pick or revert operation.
     */
    "ontoRefName"?: string;

    /**
     * The git repository for the cherry pick or revert operation.
     */
    "repository"?: GitRepository;

    /**
     * Details about the source of the cherry pick or revert operation (e.g. A pull request or a specific commit).
     */
    "source"?: GitAsyncRefOperationSource;
}

/**
 * GitAsyncRefOperationSource specifies the pull request or list of commits to use when making a cherry pick and revert operation request. Only one should be provided.
 */
export interface GitAsyncRefOperationSource {

    /**
     * A list of commits to cherry pick or revert
     */
    "commitList"?: Array<GitCommitRef>;

    /**
     * Id of the pull request to cherry pick or revert
     */
    "pullRequestId"?: number;
}

/**
 * 
 */
export interface GitBaseVersionDescriptor extends GitVersionDescriptor {
}

/**
 * 
 */
export interface GitBlobRef {
    "links"?: ReferenceLinks;

    /**
     * SHA1 hash of git object
     */
    "objectId"?: string;

    /**
     * Size of blob content (in bytes)
     */
    "size"?: number;
    "url"?: string;
}

/**
 * Ahead and behind counts for a particular ref.
 */
export interface GitBranchStats {

    /**
     * Number of commits ahead.
     */
    "aheadCount"?: number;

    /**
     * Number of commits behind.
     */
    "behindCount"?: number;

    /**
     * Current commit.
     */
    "commit"?: GitCommitRef;

    /**
     * True if this is the result for the base version.
     */
    "isBaseVersion"?: boolean;

    /**
     * Name of the ref.
     */
    "name"?: string;
}

/**
 * 
 */
export interface GitChange extends Change {
}

export namespace GitChange {
}
/**
 * This object is returned from Cherry Pick operations and provides the id and status of the operation
 */
export interface GitCherryPick extends GitAsyncRefOperation {
}

/**
 * 
 */
export interface GitCommit extends GitCommitRef {
}

/**
 * 
 */
export interface GitCommitChanges {
    "changeCounts"?: ChangeCountDictionary;
    "changes"?: Array<GitChange>;
}

/**
 * 
 */
export interface GitCommitDiffs {
    "aheadCount"?: number;
    "allChangesIncluded"?: boolean;
    "baseCommit"?: string;
    "behindCount"?: number;
    "changeCounts"?: { [key: string]: number; };
    "changes"?: Array<GitChange>;
    "commonCommit"?: string;
    "targetCommit"?: string;
}

/**
 * Provides properties that describe a Git commit and associated metadata.
 */
export interface GitCommitRef {

    /**
     * A collection of related REST reference links.
     */
    "links"?: ReferenceLinks;

    /**
     * Author of the commit.
     */
    "author"?: GitUserDate;

    /**
     * Counts of the types of changes (edits, deletes, etc.) included with the commit.
     */
    "changeCounts"?: ChangeCountDictionary;

    /**
     * An enumeration of the changes included with the commit.
     */
    "changes"?: Array<GitChange>;

    /**
     * Comment or message of the commit.
     */
    "comment"?: string;

    /**
     * Indicates if the comment is truncated from the full Git commit comment message.
     */
    "commentTruncated"?: boolean;

    /**
     * ID (SHA-1) of the commit.
     */
    "commitId"?: string;

    /**
     * Committer of the commit.
     */
    "committer"?: GitUserDate;

    /**
     * An enumeration of the parent commit IDs for this commit.
     */
    "parents"?: Array<string>;

    /**
     * The push associated with this commit.
     */
    "push"?: GitPushRef;

    /**
     * Remote URL path to the commit.
     */
    "remoteUrl"?: string;

    /**
     * A list of status metadata from services and extensions that may associate additional information to the commit.
     */
    "statuses"?: Array<GitStatus>;

    /**
     * REST URL for this resource.
     */
    "url"?: string;

    /**
     * A list of workitems associated with this commit.
     */
    "workItems"?: Array<ResourceRef>;
}

/**
 * 
 */
export interface GitCommitToCreate {
    "baseRef"?: GitRef;
    "comment"?: string;
    "pathActions"?: Array<GitPathAction>;
}

/**
 * 
 */
export interface GitConflict {
    "links"?: ReferenceLinks;
    "conflictId"?: number;
    "conflictPath"?: string;
    "mergeBaseCommit"?: GitCommitRef;
    "mergeOrigin"?: GitMergeOriginRef;
    "mergeSourceCommit"?: GitCommitRef;
    "mergeTargetCommit"?: GitCommitRef;
    "resolvedBy"?: IdentityRef;
    "resolvedDate"?: Date;
    "url"?: string;
}

/**
 * Data object for AddAdd conflict
 */
export interface GitConflictAddAdd extends GitConflict {
}

/**
 * Data object for RenameAdd conflict
 */
export interface GitConflictAddRename extends GitConflict {
}

/**
 * Data object for EditDelete conflict
 */
export interface GitConflictDeleteEdit extends GitConflict {
}

/**
 * Data object for RenameDelete conflict
 */
export interface GitConflictDeleteRename extends GitConflict {
}

/**
 * Data object for FileDirectory conflict
 */
export interface GitConflictDirectoryFile extends GitConflict {
}

/**
 * Data object for DeleteEdit conflict
 */
export interface GitConflictEditDelete extends GitConflict {
}

/**
 * Data object for EditEdit conflict
 */
export interface GitConflictEditEdit extends GitConflict {
}

/**
 * Data object for DirectoryFile conflict
 */
export interface GitConflictFileDirectory extends GitConflict {
}

/**
 * Data object for Rename1to2 conflict
 */
export interface GitConflictRename1to2 extends GitConflict {
}

/**
 * Data object for Rename2to1 conflict
 */
export interface GitConflictRename2to1 extends GitConflict {
}

/**
 * Data object for AddRename conflict
 */
export interface GitConflictRenameAdd extends GitConflict {
}

/**
 * Data object for DeleteRename conflict
 */
export interface GitConflictRenameDelete extends GitConflict {
}

/**
 * Data object for RenameRename conflict
 */
export interface GitConflictRenameRename extends GitConflict {
}

/**
 * 
 */
export interface GitConflictUpdateResult {

    /**
     * Conflict ID that was provided by input
     */
    "conflictId"?: number;

    /**
     * Reason for failing
     */
    "customMessage"?: string;

    /**
     * New state of the conflict after updating
     */
    "updatedConflict"?: GitConflict;
}

/**
 * 
 */
export interface GitDeletedRepository {
    "createdDate"?: Date;
    "deletedBy"?: IdentityRef;
    "deletedDate"?: Date;
    "id"?: string;
    "name"?: string;
    "project"?: TeamProjectReference;
}

/**
 * 
 */
export interface GitFilePathsCollection {
    "commitId"?: string;
    "paths"?: Array<string>;
    "url"?: string;
}

/**
 * Status information about a requested fork operation.
 */
export interface GitForkOperationStatusDetail {

    /**
     * All valid steps for the forking process
     */
    "allSteps"?: Array<string>;

    /**
     * Index into AllSteps for the current step
     */
    "currentStep"?: number;

    /**
     * Error message if the operation failed.
     */
    "errorMessage"?: string;
}

/**
 * Information about a fork ref.
 */
export interface GitForkRef extends GitRef {
}

/**
 * Request to sync data between two forks.
 */
export interface GitForkSyncRequest {

    /**
     * Collection of related links
     */
    "links"?: ReferenceLinks;
    "detailedStatus"?: GitForkOperationStatusDetail;

    /**
     * Unique identifier for the operation.
     */
    "operationId"?: number;

    /**
     * Fully-qualified identifier for the source repository.
     */
    "source"?: GlobalGitRepositoryKey;

    /**
     * If supplied, the set of ref mappings to use when performing a "sync" or create. If missing, all refs will be synchronized.
     */
    "sourceToTargetRefs"?: Array<SourceToTargetRef>;
}

/**
 * Parameters for creating a fork request
 */
export interface GitForkSyncRequestParameters {

    /**
     * Fully-qualified identifier for the source repository.
     */
    "source"?: GlobalGitRepositoryKey;

    /**
     * If supplied, the set of ref mappings to use when performing a "sync" or create. If missing, all refs will be synchronized.
     */
    "sourceToTargetRefs"?: Array<SourceToTargetRef>;
}

/**
 * 
 */
export interface GitForkTeamProjectReference extends TeamProjectReference {
}

/**
 * 
 */
export interface GitHubArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * 
 */
export interface GitImportFailedEvent {
    "sourceRepositoryName"?: string;
    "targetRepository"?: GitRepository;
}

/**
 * Parameter for creating a git import request when source is Git version control
 */
export interface GitImportGitSource {

    /**
     * Tells if this is a sync request or not
     */
    "overwrite"?: boolean;

    /**
     * Url for the source repo
     */
    "url"?: string;
}

/**
 * A request to import data from a remote source control system.
 */
export interface GitImportRequest {

    /**
     * Links to related resources.
     */
    "links"?: ReferenceLinks;

    /**
     * Detailed status of the import, including the current step and an error message, if applicable.
     */
    "detailedStatus"?: GitImportStatusDetail;

    /**
     * The unique identifier for this import request.
     */
    "importRequestId"?: number;

    /**
     * Parameters for creating the import request.
     */
    "parameters"?: GitImportRequestParameters;

    /**
     * The target repository for this import.
     */
    "repository"?: GitRepository;

    /**
     * A link back to this import request resource.
     */
    "url"?: string;
}

/**
 * Parameters for creating an import request
 */
export interface GitImportRequestParameters {

    /**
     * Option to delete service endpoint when import is done
     */
    "deleteServiceEndpointAfterImportIsDone"?: boolean;

    /**
     * Source for importing git repository
     */
    "gitSource"?: GitImportGitSource;

    /**
     * Service Endpoint for connection to external endpoint
     */
    "serviceEndpointId"?: string;

    /**
     * Source for importing tfvc repository
     */
    "tfvcSource"?: GitImportTfvcSource;
}

/**
 * Additional status information about an import request.
 */
export interface GitImportStatusDetail {

    /**
     * All valid steps for the import process
     */
    "allSteps"?: Array<string>;

    /**
     * Index into AllSteps for the current step
     */
    "currentStep"?: number;

    /**
     * Error message if the operation failed.
     */
    "errorMessage"?: string;
}

/**
 * 
 */
export interface GitImportSucceededEvent {
    "sourceRepositoryName"?: string;
    "targetRepository"?: GitRepository;
}

/**
 * Parameter for creating a git import request when source is tfvc version control
 */
export interface GitImportTfvcSource {

    /**
     * Set true to import History, false otherwise
     */
    "importHistory"?: boolean;

    /**
     * Get history for last n days (max allowed value is 180 days)
     */
    "importHistoryDurationInDays"?: number;

    /**
     * Path which we want to import (this can be copied from Path Control in Explorer)
     */
    "path"?: string;
}

/**
 * 
 */
export interface GitItem extends ItemModel {
}

/**
 * 
 */
export interface GitItemDescriptor {

    /**
     * Path to item
     */
    "path"?: string;

    /**
     * Version string (interpretation based on VersionType defined in subclass
     */
    "version"?: string;
}

/**
 * 
 */
export interface GitItemRequestData {

    /**
     * Whether to include metadata for all items
     */
    "includeContentMetadata"?: boolean;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;

    /**
     * Collection of items to fetch, including path, version, and recursion level
     */
    "itemDescriptors"?: Array<GitItemDescriptor>;

    /**
     * Whether to include shallow ref to commit that last changed each item
     */
    "latestProcessedChange"?: boolean;
}

/**
 * 
 */
export interface GitLastChangeItem {

    /**
     * Gets or sets the commit Id this item was modified most recently for the provided version.
     */
    "commitId"?: string;

    /**
     * Gets or sets the path of the item.
     */
    "path"?: string;
}

/**
 * 
 */
export interface GitLastChangeTreeItems {

    /**
     * The list of commits referenced by Items, if they were requested.
     */
    "commits"?: Array<GitCommitRef>;

    /**
     * The last change of items.
     */
    "items"?: Array<GitLastChangeItem>;

    /**
     * The last explored time, in case the result is not comprehensive. Null otherwise.
     */
    "lastExploredTime"?: Date;
}

/**
 * 
 */
export interface GitMerge extends GitMergeParameters {
}

/**
 * Status information about a requested merge operation.
 */
export interface GitMergeOperationStatusDetail {

    /**
     * Error message if the operation failed.
     */
    "failureMessage"?: string;

    /**
     * The commitId of the resultant merge commit.
     */
    "mergeCommitId"?: string;
}

/**
 * 
 */
export interface GitMergeOriginRef {
    "pullRequestId"?: number;
}

/**
 * Parameters required for performing git merge.
 */
export interface GitMergeParameters {

    /**
     * Comment or message of the commit.
     */
    "comment"?: string;

    /**
     * An enumeration of the parent commit IDs for the merge  commit.
     */
    "parents"?: Array<string>;
}

/**
 * Git object identifier and type information.
 */
export interface GitObject {

    /**
     * Object Id (Sha1Id).
     */
    "objectId"?: string;
}

/**
 * 
 */
export interface GitPathAction {
    "base64Content"?: string;
    "path"?: string;
    "rawTextContent"?: string;
    "targetPath"?: string;
}

/**
 * 
 */
export interface GitPathToItemsCollection {
    "items"?: { [key: string]: Array<GitItem>; };
}

/**
 * 
 */
export interface GitPolicyConfigurationResponse {

    /**
     * The HTTP client methods find the continuation token header in the response and populate this field.
     */
    "continuationToken"?: string;
    "policyConfigurations"?: Array<PolicyConfiguration>;
}

/**
 * Represents all the data associated with a pull request.
 */
export interface GitPullRequest {

    /**
     * Links to other related objects.
     */
    "links"?: ReferenceLinks;

    /**
     * A string which uniquely identifies this pull request. To generate an artifact ID for a pull request, use this template: ```vstfs:///Git/PullRequestId/{projectId}/{repositoryId}/{pullRequestId}```
     */
    "artifactId"?: string;

    /**
     * If set, auto-complete is enabled for this pull request and this is the identity that enabled it.
     */
    "autoCompleteSetBy"?: IdentityRef;

    /**
     * The user who closed the pull request.
     */
    "closedBy"?: IdentityRef;

    /**
     * The date when the pull request was closed (completed, abandoned, or merged externally).
     */
    "closedDate"?: Date;

    /**
     * The code review ID of the pull request. Used internally.
     */
    "codeReviewId"?: number;

    /**
     * The commits contained in the pull request.
     */
    "commits"?: Array<GitCommitRef>;

    /**
     * Options which affect how the pull request will be merged when it is completed.
     */
    "completionOptions"?: GitPullRequestCompletionOptions;

    /**
     * The most recent date at which the pull request entered the queue to be completed. Used internally.
     */
    "completionQueueTime"?: Date;

    /**
     * The identity of the user who created the pull request.
     */
    "createdBy"?: IdentityRef;

    /**
     * The date when the pull request was created.
     */
    "creationDate"?: Date;

    /**
     * The description of the pull request.
     */
    "description"?: string;

    /**
     * If this is a PR from a fork this will contain information about its source.
     */
    "forkSource"?: GitForkRef;

    /**
     * Draft / WIP pull request.
     */
    "isDraft"?: boolean;

    /**
     * The labels associated with the pull request.
     */
    "labels"?: Array<WebApiTagDefinition>;

    /**
     * The commit of the most recent pull request merge. If empty, the most recent merge is in progress or was unsuccessful.
     */
    "lastMergeCommit"?: GitCommitRef;

    /**
     * The commit at the head of the source branch at the time of the last pull request merge.
     */
    "lastMergeSourceCommit"?: GitCommitRef;

    /**
     * The commit at the head of the target branch at the time of the last pull request merge.
     */
    "lastMergeTargetCommit"?: GitCommitRef;

    /**
     * If set, pull request merge failed for this reason.
     */
    "mergeFailureMessage"?: string;

    /**
     * The ID of the job used to run the pull request merge. Used internally.
     */
    "mergeId"?: string;

    /**
     * Options used when the pull request merge runs. These are separate from completion options since completion happens only once and a new merge will run every time the source branch of the pull request changes.
     */
    "mergeOptions"?: GitPullRequestMergeOptions;

    /**
     * The ID of the pull request.
     */
    "pullRequestId"?: number;

    /**
     * Used internally.
     */
    "remoteUrl"?: string;

    /**
     * The repository containing the target branch of the pull request.
     */
    "repository"?: GitRepository;

    /**
     * A list of reviewers on the pull request along with the state of their votes.
     */
    "reviewers"?: Array<IdentityRefWithVote>;

    /**
     * The name of the source branch of the pull request.
     */
    "sourceRefName"?: string;

    /**
     * If true, this pull request supports multiple iterations. Iteration support means individual pushes to the source branch of the pull request can be reviewed and comments left in one iteration will be tracked across future iterations.
     */
    "supportsIterations"?: boolean;

    /**
     * The name of the target branch of the pull request.
     */
    "targetRefName"?: string;

    /**
     * The title of the pull request.
     */
    "title"?: string;

    /**
     * Used internally.
     */
    "url"?: string;

    /**
     * Any work item references associated with this pull request.
     */
    "workItemRefs"?: Array<ResourceRef>;
}

/**
 * Change made in a pull request.
 */
export interface GitPullRequestChange extends GitChange {
}

export namespace GitPullRequestChange {
}
/**
 * Represents a comment thread of a pull request. A thread contains meta data about the file it was left on (if any) along with one or more comments (an initial comment and the subsequent replies).
 */
export interface GitPullRequestCommentThread extends CommentThread {
}

/**
 * Comment thread context contains details about what diffs were being viewed at the time of thread creation and whether or not the thread has been tracked from that original diff.
 */
export interface GitPullRequestCommentThreadContext {

    /**
     * Used to track a comment across iterations. This value can be found by looking at the iteration's changes list. Must be set for pull requests with iteration support. Otherwise, it's not required for 'legacy' pull requests.
     */
    "changeTrackingId"?: number;

    /**
     * The iteration context being viewed when the thread was created.
     */
    "iterationContext"?: CommentIterationContext;

    /**
     * The criteria used to track this thread. If this property is filled out when the thread is returned, then the thread has been tracked from its original location using the given criteria.
     */
    "trackingCriteria"?: CommentTrackingCriteria;
}

/**
 * Preferences about how the pull request should be completed.
 */
export interface GitPullRequestCompletionOptions {

    /**
     * If true, policies will be explicitly bypassed while the pull request is completed.
     */
    "bypassPolicy"?: boolean;

    /**
     * If policies are bypassed, this reason is stored as to why bypass was used.
     */
    "bypassReason"?: string;

    /**
     * If true, the source branch of the pull request will be deleted after completion.
     */
    "deleteSourceBranch"?: boolean;

    /**
     * If set, this will be used as the commit message of the merge commit.
     */
    "mergeCommitMessage"?: string;

    /**
     * If true, the commits in the pull request will be squash-merged into the specified target branch on completion.
     */
    "squashMerge"?: boolean;

    /**
     * If true, we will attempt to transition any work items linked to the pull request into the next logical state (i.e. Active -> Resolved)
     */
    "transitionWorkItems"?: boolean;

    /**
     * If true, the current completion attempt was triggered via auto-complete. Used internally.
     */
    "triggeredByAutoComplete"?: boolean;
}

/**
 * Provides properties that describe a Git pull request iteration. Iterations are created as a result of creating and pushing updates to a pull request.
 */
export interface GitPullRequestIteration {

    /**
     * A collection of related REST reference links.
     */
    "links"?: ReferenceLinks;

    /**
     * Author of the pull request iteration.
     */
    "author"?: IdentityRef;

    /**
     * Changes included with the pull request iteration.
     */
    "changeList"?: Array<GitPullRequestChange>;

    /**
     * The commits included with the pull request iteration.
     */
    "commits"?: Array<GitCommitRef>;

    /**
     * The first common Git commit of the source and target refs.
     */
    "commonRefCommit"?: GitCommitRef;

    /**
     * The creation date of the pull request iteration.
     */
    "createdDate"?: Date;

    /**
     * Description of the pull request iteration.
     */
    "description"?: string;

    /**
     * Indicates if the Commits property contains a truncated list of commits in this pull request iteration.
     */
    "hasMoreCommits"?: boolean;

    /**
     * ID of the pull request iteration. Iterations are created as a result of creating and pushing updates to a pull request.
     */
    "id"?: number;

    /**
     * If the iteration reason is Retarget, this is the refName of the new target
     */
    "newTargetRefName"?: string;

    /**
     * If the iteration reason is Retarget, this is the original target refName
     */
    "oldTargetRefName"?: string;

    /**
     * The Git push information associated with this pull request iteration.
     */
    "push"?: GitPushRef;

    /**
     * The source Git commit of this iteration.
     */
    "sourceRefCommit"?: GitCommitRef;

    /**
     * The target Git commit of this iteration.
     */
    "targetRefCommit"?: GitCommitRef;

    /**
     * The updated date of the pull request iteration.
     */
    "updatedDate"?: Date;
}

/**
 * Collection of changes made in a pull request.
 */
export interface GitPullRequestIterationChanges {

    /**
     * Changes made in the iteration.
     */
    "changeEntries"?: Array<GitPullRequestChange>;

    /**
     * Value to specify as skip to get the next page of changes.  This will be zero if there are no more changes.
     */
    "nextSkip"?: number;

    /**
     * Value to specify as top to get the next page of changes.  This will be zero if there are no more changes.
     */
    "nextTop"?: number;
}

/**
 * The options which are used when a pull request merge is created.
 */
export interface GitPullRequestMergeOptions {
    "detectRenameFalsePositives"?: boolean;

    /**
     * If true, rename detection will not be performed during the merge.
     */
    "disableRenames"?: boolean;
}

/**
 * A set of pull request queries and their results.
 */
export interface GitPullRequestQuery {

    /**
     * The queries to perform.
     */
    "queries"?: Array<GitPullRequestQueryInput>;

    /**
     * The results of the queries. This matches the QueryInputs list so Results[n] are the results of QueryInputs[n]. Each entry in the list is a dictionary of commit->pull requests.
     */
    "results"?: Array<{ [key: string]: Array<GitPullRequest>; }>;
}

/**
 * Pull request query input parameters.
 */
export interface GitPullRequestQueryInput {

    /**
     * The list of commit IDs to search for.
     */
    "items"?: Array<string>;
}

/**
 * 
 */
export interface GitPullRequestReviewFileContentInfo {
    "links"?: ReferenceLinks;

    /**
     * The file change path.
     */
    "path"?: string;

    /**
     * Content hash of on-disk representation of file content. Its calculated by the client by using SHA1 hash function. Ensure that uploaded file has same encoding as in source control.
     */
    "shA1Hash"?: string;
}

/**
 * Pull requests can be searched for matching this criteria.
 */
export interface GitPullRequestSearchCriteria {

    /**
     * If set, search for pull requests that were created by this identity.
     */
    "creatorId"?: string;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;

    /**
     * If set, search for pull requests whose target branch is in this repository.
     */
    "repositoryId"?: string;

    /**
     * If set, search for pull requests that have this identity as a reviewer.
     */
    "reviewerId"?: string;

    /**
     * If set, search for pull requests from this branch.
     */
    "sourceRefName"?: string;

    /**
     * If set, search for pull requests whose source branch is in this repository.
     */
    "sourceRepositoryId"?: string;

    /**
     * If set, search for pull requests into this branch.
     */
    "targetRefName"?: string;
}

/**
 * This class contains the metadata of a service/extension posting pull request status. Status can be associated with a pull request or an iteration.
 */
export interface GitPullRequestStatus extends GitStatus {
}

/**
 * 
 */
export interface GitPush extends GitPushRef {
}

/**
 * 
 */
export interface GitPushEventData {
    "afterId"?: string;
    "beforeId"?: string;
    "branch"?: string;
    "commits"?: Array<GitCommit>;
    "repository"?: GitRepository;
}

/**
 * 
 */
export interface GitPushRef {
    "links"?: ReferenceLinks;
    "date"?: Date;
    "pushedBy"?: IdentityRef;
    "pushId"?: number;
    "url"?: string;
}

/**
 * 
 */
export interface GitPushSearchCriteria {
    "fromDate"?: Date;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;
    "includeRefUpdates"?: boolean;
    "pusherId"?: string;
    "refName"?: string;
    "toDate"?: Date;
}

/**
 * 
 */
export interface GitQueryBranchStatsCriteria {
    "baseCommit"?: GitVersionDescriptor;
    "targetCommits"?: Array<GitVersionDescriptor>;
}

/**
 * 
 */
export interface GitQueryCommitsCriteria {

    /**
     * Number of entries to skip
     */
    "$Skip"?: number;

    /**
     * Maximum number of entries to retrieve
     */
    "$Top"?: number;

    /**
     * Alias or display name of the author
     */
    "author"?: string;

    /**
     * Only applicable when ItemVersion specified. If provided, start walking history starting at this commit.
     */
    "compareVersion"?: GitVersionDescriptor;

    /**
     * Only applies when an itemPath is specified. This determines whether to exclude delete entries of the specified path.
     */
    "excludeDeletes"?: boolean;

    /**
     * If provided, a lower bound for filtering commits alphabetically
     */
    "fromCommitId"?: string;

    /**
     * If provided, only include history entries created after this date (string)
     */
    "fromDate"?: string;

    /**
     * If provided, specifies the exact commit ids of the commits to fetch. May not be combined with other parameters.
     */
    "ids"?: Array<string>;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;

    /**
     * Whether to include the push information
     */
    "includePushData"?: boolean;

    /**
     * Whether to include the image Url for committers and authors
     */
    "includeUserImageUrl"?: boolean;

    /**
     * Whether to include linked work items
     */
    "includeWorkItems"?: boolean;

    /**
     * Path of item to search under
     */
    "itemPath"?: string;

    /**
     * If provided, identifies the commit or branch to search
     */
    "itemVersion"?: GitVersionDescriptor;

    /**
     * If provided, an upper bound for filtering commits alphabetically
     */
    "toCommitId"?: string;

    /**
     * If provided, only include history entries created before this date (string)
     */
    "toDate"?: string;

    /**
     * Alias or display name of the committer
     */
    "user"?: string;
}

/**
 * 
 */
export interface GitQueryRefsCriteria {

    /**
     * List of commit Ids to be searched
     */
    "commitIds"?: Array<string>;

    /**
     * List of complete or partial names for refs to be searched
     */
    "refNames"?: Array<string>;
}

/**
 * 
 */
export interface GitRecycleBinRepositoryDetails {

    /**
     * Setting to false will undo earlier deletion and restore the repository.
     */
    "deleted"?: boolean;
}

/**
 * 
 */
export interface GitRef {
    "links"?: ReferenceLinks;
    "creator"?: IdentityRef;
    "isLocked"?: boolean;
    "isLockedBy"?: IdentityRef;
    "name"?: string;
    "objectId"?: string;
    "peeledObjectId"?: string;
    "statuses"?: Array<GitStatus>;
    "url"?: string;
}

/**
 * 
 */
export interface GitRefFavorite {
    "links"?: ReferenceLinks;
    "id"?: number;
    "identityId"?: string;
    "name"?: string;
    "repositoryId"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface GitRefUpdate {
    "isLocked"?: boolean;
    "name"?: string;
    "newObjectId"?: string;
    "oldObjectId"?: string;
    "repositoryId"?: string;
}

/**
 * 
 */
export interface GitRefUpdateResult {

    /**
     * Custom message for the result object For instance, Reason for failing.
     */
    "customMessage"?: string;

    /**
     * Whether the ref is locked or not
     */
    "isLocked"?: boolean;

    /**
     * Ref name
     */
    "name"?: string;

    /**
     * New object ID
     */
    "newObjectId"?: string;

    /**
     * Old object ID
     */
    "oldObjectId"?: string;

    /**
     * Name of the plugin that rejected the updated.
     */
    "rejectedBy"?: string;

    /**
     * Repository ID
     */
    "repositoryId"?: string;

    /**
     * True if the ref update succeeded, false otherwise
     */
    "success"?: boolean;
}

/**
 * 
 */
export interface GitRepository {
    "links"?: ReferenceLinks;
    "defaultBranch"?: string;
    "id"?: string;

    /**
     * True if the repository was created as a fork
     */
    "isFork"?: boolean;
    "name"?: string;
    "parentRepository"?: GitRepositoryRef;
    "project"?: TeamProjectReference;
    "remoteUrl"?: string;

    /**
     * Compressed size (bytes) of the repository.
     */
    "size"?: number;
    "sshUrl"?: string;
    "url"?: string;
    "validRemoteUrls"?: Array<string>;
}

/**
 * 
 */
export interface GitRepositoryCreateOptions {
    "name"?: string;
    "parentRepository"?: GitRepositoryRef;
    "project"?: TeamProjectReference;
}

/**
 * 
 */
export interface GitRepositoryRef {

    /**
     * Team Project Collection where this Fork resides
     */
    "collection"?: TeamProjectCollectionReference;
    "id"?: string;

    /**
     * True if the repository was created as a fork
     */
    "isFork"?: boolean;
    "name"?: string;
    "project"?: TeamProjectReference;
    "remoteUrl"?: string;
    "sshUrl"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface GitRepositoryStats {
    "activePullRequestsCount"?: number;
    "branchesCount"?: number;
    "commitsCount"?: number;
    "repositoryId"?: string;
}

/**
 * 
 */
export interface GitResolution {

    /**
     * User who created the resolution.
     */
    "author"?: IdentityRef;
}

/**
 * 
 */
export interface GitResolutionMergeContent extends GitResolution {
}

/**
 * 
 */
export interface GitResolutionPathConflict extends GitResolution {
}

/**
 * 
 */
export interface GitResolutionPickOneAction extends GitResolution {
}

/**
 * 
 */
export interface GitResolutionRename1to2 extends GitResolutionMergeContent {
}

/**
 * 
 */
export interface GitRevert extends GitAsyncRefOperation {
}

/**
 * This class contains the metadata of a service/extension posting a status.
 */
export interface GitStatus {

    /**
     * Reference links.
     */
    "links"?: ReferenceLinks;

    /**
     * Context of the status.
     */
    "context"?: GitStatusContext;

    /**
     * Identity that created the status.
     */
    "createdBy"?: IdentityRef;

    /**
     * Creation date and time of the status.
     */
    "creationDate"?: Date;

    /**
     * Status description. Typically describes current state of the status.
     */
    "description"?: string;

    /**
     * Status identifier.
     */
    "id"?: number;

    /**
     * URL with status details.
     */
    "targetUrl"?: string;

    /**
     * Last update date and time of the status.
     */
    "updatedDate"?: Date;
}

/**
 * Status context that uniquely identifies the status.
 */
export interface GitStatusContext {

    /**
     * Genre of the status. Typically name of the service/tool generating the status, can be empty.
     */
    "genre"?: string;

    /**
     * Name identifier of the status, cannot be null or empty.
     */
    "name"?: string;
}

/**
 * An object describing the git suggestion.  Git suggestions are currently limited to suggested pull requests.
 */
export interface GitSuggestion {

    /**
     * Specific properties describing the suggestion.
     */
    "properties"?: { [key: string]: any; };

    /**
     * The type of suggestion (e.g. pull request).
     */
    "type"?: string;
}

/**
 * 
 */
export interface GitTargetVersionDescriptor extends GitVersionDescriptor {
}

/**
 * 
 */
export interface GitTemplate {

    /**
     * Name of the Template
     */
    "name"?: string;

    /**
     * Type of the Template
     */
    "type"?: string;
}

/**
 * 
 */
export interface GitTreeDiff {

    /**
     * ObjectId of the base tree of this diff.
     */
    "baseTreeId"?: string;

    /**
     * List of tree entries that differ between the base and target tree.  Renames and object type changes are returned as a delete for the old object and add for the new object.  If a continuation token is returned in the response header, some tree entries are yet to be processed and may yeild more diff entries. If the continuation token is not returned all the diff entries have been included in this response.
     */
    "diffEntries"?: Array<GitTreeDiffEntry>;

    /**
     * ObjectId of the target tree of this diff.
     */
    "targetTreeId"?: string;

    /**
     * REST Url to this resource.
     */
    "url"?: string;
}

/**
 * 
 */
export interface GitTreeDiffEntry {

    /**
     * SHA1 hash of the object in the base tree, if it exists. Will be null in case of adds.
     */
    "baseObjectId"?: string;

    /**
     * Relative path in base and target trees.
     */
    "path"?: string;

    /**
     * SHA1 hash of the object in the target tree, if it exists. Will be null in case of deletes.
     */
    "targetObjectId"?: string;
}

/**
 * 
 */
export interface GitTreeDiffResponse {

    /**
     * The HTTP client methods find the continuation token header in the response and populate this field.
     */
    "continuationToken"?: Array<string>;
    "treeDiff"?: GitTreeDiff;
}

/**
 * 
 */
export interface GitTreeEntryRef {

    /**
     * Mode represented as octal string
     */
    "mode"?: string;

    /**
     * SHA1 hash of git object
     */
    "objectId"?: string;

    /**
     * Path relative to parent tree object
     */
    "relativePath"?: string;

    /**
     * Size of content
     */
    "size"?: number;

    /**
     * url to retrieve tree or blob
     */
    "url"?: string;
}

/**
 * 
 */
export interface GitTreeRef {
    "links"?: ReferenceLinks;

    /**
     * SHA1 hash of git object
     */
    "objectId"?: string;

    /**
     * Sum of sizes of all children
     */
    "size"?: number;

    /**
     * Blobs and trees under this tree
     */
    "treeEntries"?: Array<GitTreeEntryRef>;

    /**
     * Url to tree
     */
    "url"?: string;
}

/**
 * User info and date for Git operations.
 */
export interface GitUserDate {

    /**
     * Date of the Git operation.
     */
    "date"?: Date;

    /**
     * Email address of the user performing the Git operation.
     */
    "email"?: string;

    /**
     * Url for the user's avatar.
     */
    "imageUrl"?: string;

    /**
     * Name of the user performing the Git operation.
     */
    "name"?: string;
}

/**
 * 
 */
export interface GitVersionDescriptor {

    /**
     * Version string identifier (name of tag/branch, SHA1 of commit)
     */
    "version"?: string;
}

/**
 * Globally unique key for a repository.
 */
export interface GlobalGitRepositoryKey {

    /**
     * Team Project Collection ID of the collection for the repository.
     */
    "collectionId"?: string;

    /**
     * Team Project ID of the project for the repository.
     */
    "projectId"?: string;

    /**
     * ID of the repository.
     */
    "repositoryId"?: string;
}

/**
 * Permissions for feed service-wide operations such as the creation of new feeds.
 */
export interface GlobalPermission {

    /**
     * Identity of the user with the provided Role.
     */
    "identityDescriptor"?: IdentityDescriptor;
}

/**
 * 
 */
export interface GraphCachePolicies {

    /**
     * Size of the cache
     */
    "cacheSize"?: number;
}

/**
 * Subject descriptor of a Graph entity
 */
export interface GraphDescriptorResult {

    /**
     * This field contains zero or more interesting links about the graph descriptor. These links may be invoked to obtain additional relationships or more detailed information about this graph descriptor.
     */
    "links"?: ReferenceLinks;
    "value"?: string;
}

/**
 * Represents a set of data used to communicate with a federated provider on behalf of a particular user.
 */
export interface GraphFederatedProviderData {

    /**
     * The access token that can be used to communicated with the federated provider on behalf on the target identity, if we were able to successfully acquire one, otherwise <code>null</code>, if we were not.
     */
    "accessToken"?: string;

    /**
     * Whether or not the immediate provider (i.e. AAD) has indicated that we can call them to attempt to get an access token to communicate with the federated provider on behalf of the target identity.
     */
    "canQueryAccessToken"?: boolean;

    /**
     * The name of the federated provider, e.g. "github.com".
     */
    "providerName"?: string;

    /**
     * The descriptor of the graph subject to which this federated provider data corresponds.
     */
    "subjectDescriptor"?: string;

    /**
     * The version number of this federated provider data, which corresponds to when it was last updated. Can be used to prevent returning stale provider data from the cache when the caller is aware of a newer version, such as to prevent local cache poisoning from a remote cache or store. This is the app layer equivalent of the data layer sequence ID.
     */
    "version"?: number;
}

/**
 * 
 */
export interface GraphGlobalExtendedPropertyBatch {
    "propertyNameFilters"?: Array<string>;
    "subjectDescriptors"?: Array<string>;
}

/**
 * Graph group entity
 */
export interface GraphGroup extends GraphMember {
}

/**
 * Do not attempt to use this type to create a new group. This type does not contain sufficient fields to create a new group.
 */
export interface GraphGroupCreationContext {

    /**
     * Optional: If provided, we will use this identifier for the storage key of the created group
     */
    "storageKey"?: string;
}

/**
 * Use this type to create a new group using the mail address as a reference to an existing group from an external AD or AAD backed provider. This is the subset of GraphGroup fields required for creation of a group for the AAD and AD use case.
 */
export interface GraphGroupMailAddressCreationContext extends GraphGroupCreationContext {
}

/**
 * Use this type to create a new group using the OriginID as a reference to an existing group from an external AD or AAD backed provider. This is the subset of GraphGroup fields required for creation of a group for the AD and AAD use case.
 */
export interface GraphGroupOriginIdCreationContext extends GraphGroupCreationContext {
}

/**
 * Use this type to create a new Vsts group that is not backed by an external provider.
 */
export interface GraphGroupVstsCreationContext extends GraphGroupCreationContext {
}

/**
 * 
 */
export interface GraphMember extends GraphSubject {
}

/**
 * Relationship between a container and a member
 */
export interface GraphMembership {

    /**
     * This field contains zero or more interesting links about the graph membership. These links may be invoked to obtain additional relationships or more detailed information about this graph membership.
     */
    "links"?: ReferenceLinks;
    "containerDescriptor"?: string;
    "memberDescriptor"?: string;
}

/**
 * Status of a Graph membership (active/inactive)
 */
export interface GraphMembershipState {

    /**
     * This field contains zero or more interesting links about the graph membership state. These links may be invoked to obtain additional relationships or more detailed information about this graph membership state.
     */
    "links"?: ReferenceLinks;

    /**
     * When true, the membership is active
     */
    "active"?: boolean;
}

/**
 * 
 */
export interface GraphMembershipTraversal {

    /**
     * Reason why the subject could not be traversed completely
     */
    "incompletenessReason"?: string;

    /**
     * When true, the subject is traversed completely
     */
    "isComplete"?: boolean;

    /**
     * The traversed subject descriptor
     */
    "subjectDescriptor"?: string;

    /**
     * Subject descriptor ids of the traversed members
     */
    "traversedSubjectIds"?: Array<string>;

    /**
     * Subject descriptors of the traversed members
     */
    "traversedSubjects"?: Array<string>;
}

/**
 * Who is the provider for this user and what is the identifier and domain that is used to uniquely identify the user.
 */
export interface GraphProviderInfo {

    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    "descriptor"?: string;

    /**
     * This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AAD the tenantID of the directory.)
     */
    "domain"?: string;

    /**
     * The type of source provider for the origin identifier (ex: "aad", "msa")
     */
    "origin"?: string;

    /**
     * The unique identifier from the system of origin. (For MSA this is the PUID in hex notation, for AAD this is the object id.)
     */
    "originId"?: string;
}

/**
 * Container where a graph entity is defined (organization, project, team)
 */
export interface GraphScope extends GraphSubject {
}

/**
 * This type is the subset of fields that can be provided by the user to create a Vsts scope. Scope creation is currently limited to internal back-compat scenarios. End users that attempt to create a scope with this API will fail.
 */
export interface GraphScopeCreationContext {

    /**
     * Set this field to override the default description of this scope's admin group.
     */
    "adminGroupDescription"?: string;

    /**
     * All scopes have an Administrator Group that controls access to the contents of the scope. Set this field to use a non-default group name for that administrators group.
     */
    "adminGroupName"?: string;

    /**
     * Set this optional field if this scope is created on behalf of a user other than the user making the request. This should be the Id of the user that is not the requester.
     */
    "creatorId"?: string;

    /**
     * The scope must be provided with a unique name within the parent scope. This means the created scope can have a parent or child with the same name, but no siblings with the same name.
     */
    "name"?: string;

    /**
     * An optional ID that uniquely represents the scope within it's parent scope. If this parameter is not provided, Vsts will generate on automatically.
     */
    "storageKey"?: string;
}

/**
 * Storage key of a Graph entity
 */
export interface GraphStorageKeyResult {

    /**
     * This field contains zero or more interesting links about the graph storage key. These links may be invoked to obtain additional relationships or more detailed information about this graph storage key.
     */
    "links"?: ReferenceLinks;
    "value"?: string;
}

/**
 * Top-level graph entity
 */
export interface GraphSubject extends GraphSubjectBase {
}

/**
 * 
 */
export interface GraphSubjectBase {

    /**
     * This field contains zero or more interesting links about the graph subject. These links may be invoked to obtain additional relationships or more detailed information about this graph subject.
     */
    "links"?: ReferenceLinks;

    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    "descriptor"?: string;

    /**
     * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
     */
    "displayName"?: string;

    /**
     * This url is the full route to the source resource of this graph subject.
     */
    "url"?: string;
}

/**
 * Batching of subjects to lookup using the Graph API
 */
export interface GraphSubjectLookup {
    "lookupKeys"?: Array<GraphSubjectLookupKey>;
}

/**
 * 
 */
export interface GraphSubjectLookupKey {
    "descriptor"?: string;
}

/**
 * 
 */
export interface GraphSystemSubject extends GraphSubject {
}

/**
 * Graph user entity
 */
export interface GraphUser extends GraphMember {
}

/**
 * Do not attempt to use this type to create a new user. Use one of the subclasses instead. This type does not contain sufficient fields to create a new user.
 */
export interface GraphUserCreationContext {

    /**
     * Optional: If provided, we will use this identifier for the storage key of the created user
     */
    "storageKey"?: string;
}

/**
 * Use this type to create a new user using the mail address as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its mail address in the backing provider.
 */
export interface GraphUserMailAddressCreationContext extends GraphUserCreationContext {
}

/**
 * Use this type to create a new user using the OriginID as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its unique ID in the backing provider.
 */
export interface GraphUserOriginIdCreationContext extends GraphUserCreationContext {
}

/**
 * Use this type to create a new user using the principal name as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its principal name in the backing provider.
 */
export interface GraphUserPrincipalNameCreationContext extends GraphUserCreationContext {
}

/**
 * Represent a group in the form that holds controls in it.
 */
export interface Group {

    /**
     * Display Name of the Group
     */
    "displayName"?: string;

    /**
     * Contribution for the group.
     */
    "contribution"?: WitContribution;

    /**
     * Controls to be put in the group.
     */
    "controls"?: Array<Control>;

    /**
     * The height for the contribution.
     */
    "height"?: number;

    /**
     * The id for the layout node.
     */
    "id"?: string;

    /**
     * A value indicating whether this layout node has been inherited from a parent layout.  This is expected to only be only set by the combiner.
     */
    "inherited"?: boolean;

    /**
     * A value indicating if the layout node is contribution are not.
     */
    "isContribution"?: boolean;

    /**
     * Label for the group.
     */
    "label"?: string;

    /**
     * Order in which the group should appear in the section.
     */
    "order"?: number;

    /**
     * A value indicating whether this layout node has been overridden by a child layout.
     */
    "overridden"?: boolean;

    /**
     * A value indicating if the group should be hidden or not.
     */
    "visible"?: boolean;
}

/**
 * A group entity with additional properties including its license, extensions, and project membership
 */
export interface GroupEntitlement {

    /**
     * Extension Rules.
     */
    "extensionRules"?: Array<Extension>;

    /**
     * Member reference.
     */
    "group"?: GraphGroup;

    /**
     * The unique identifier which matches the Id of the GraphMember.
     */
    "id"?: string;

    /**
     * [Readonly] The last time the group licensing rule was executed (regardless of whether any changes were made).
     */
    "lastExecuted"?: Date;

    /**
     * License Rule.
     */
    "licenseRule"?: AccessLevel;

    /**
     * Group members. Only used when creating a new group.
     */
    "members"?: Array<UserEntitlement>;

    /**
     * Relation between a project and the member's effective permissions in that project.
     */
    "projectEntitlements"?: Array<ProjectEntitlement>;
}

/**
 * 
 */
export interface GroupEntitlementOperationReference extends OperationReference {
}

/**
 * 
 */
export interface GroupOperationResult extends BaseOperationResult {
}

/**
 * Group option to add a user to
 */
export interface GroupOption {

    /**
     * Access Level
     */
    "accessLevel"?: AccessLevel;

    /**
     * Group
     */
    "group"?: Group;
}

/**
 * 
 */
export interface GroupSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * 
 */
export interface HelpLink {
    "text"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface HideStateModel {
    "hidden"?: boolean;
}

/**
 * 
 */
export interface HistoryEntry {

    /**
     * The Change list (changeset/commit/shelveset) for this point in history
     */
    "changeList"?: ChangeList;

    /**
     * The path of the item at this point in history (only relevant for File history, not folders)
     */
    "serverItem"?: string;
}

/**
 * Describes the position of a piece of text in a document.
 */
export interface Hit {

    /**
     * Gets or sets the start character offset of a piece of text.
     */
    "charOffset"?: number;

    /**
     * Gets or sets the length of a piece of text.
     */
    "length"?: number;
}

/**
 * 
 */
export interface HttpPostedTcmAttachment {
    "attachmentContent"?: string;
    "contentLength"?: number;
    "contentType"?: string;
    "fileName"?: string;
}

/**
 * Abstraction interface for the diagnostic log.  Primarily for deserialization.
 */
export interface INotificationDiagnosticLog {
    "activityId"?: string;
    "description"?: string;
    "endTime"?: Date;
    "id"?: string;
    "logType"?: string;
    "messages"?: Array<NotificationDiagnosticLogMessage>;
    "properties"?: { [key: string]: string; };
    "source"?: string;
    "startTime"?: Date;
}

/**
 * 
 */
export interface ISubscriptionChannel {
    "type"?: string;
}

/**
 * 
 */
export interface ISubscriptionFilter {
    "eventType"?: string;
    "type"?: string;
}

/**
 * 
 */
export interface IdentityData {
    "identityIds"?: Array<string>;
}

/**
 * An Identity descriptor is a wrapper for the identity type (Windows SID, Passport) along with a unique identifier such as the SID or PUID.
 */
export interface IdentityDescriptor {

    /**
     * The unique identifier for this identity, not exceeding 256 chars, which will be persisted.
     */
    "identifier"?: string;

    /**
     * Type of descriptor (for example, Windows, Passport, etc.).
     */
    "identityType"?: string;
}

/**
 * 
 */
export interface IdentityRef extends GraphSubjectBase {
}

/**
 * Identity information including a vote on a pull request.
 */
export interface IdentityRefWithVote extends IdentityRef {
}

/**
 * Describes a reference to an identity.
 */
export interface IdentityReference extends IdentityRef {
}

/**
 * 
 */
export interface IgnoredGate {

    /**
     * Gets the date on which gate is last ignored.
     */
    "lastModifiedOn"?: Date;

    /**
     * Name of gate ignored.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ImportRepositoryValidation {
    "gitSource"?: GitImportGitSource;
    "password"?: string;
    "tfvcSource"?: GitImportTfvcSource;
    "username"?: string;
}

/**
 * 
 */
export interface IncludedGitCommit {
    "commitId"?: string;
    "commitTime"?: Date;
    "parentCommitIds"?: Array<string>;
    "repositoryId"?: string;
}

/**
 * Data representation of an information node associated with a build
 */
export interface InformationNode {

    /**
     * Fields of the information node
     */
    "fields"?: { [key: string]: string; };

    /**
     * Process or person that last modified this node
     */
    "lastModifiedBy"?: string;

    /**
     * Date this node was last modified
     */
    "lastModifiedDate"?: Date;

    /**
     * Node Id of this information node
     */
    "nodeId"?: number;

    /**
     * Id of parent node (xml tree)
     */
    "parentId"?: number;

    /**
     * The type of the information node
     */
    "type"?: string;
}

/**
 * 
 */
export interface InputBindingContext {

    /**
     * Value of the input
     */
    "value"?: string;
}

/**
 * Describes an input for subscriptions.
 */
export interface InputDescriptor {

    /**
     * The ids of all inputs that the value of this input is dependent on.
     */
    "dependencyInputIds"?: Array<string>;

    /**
     * Description of what this input is used for
     */
    "description"?: string;

    /**
     * The group localized name to which this input belongs and can be shown as a header for the container that will include all the inputs in the group.
     */
    "groupName"?: string;

    /**
     * If true, the value information for this input is dynamic and should be fetched when the value of dependency inputs change.
     */
    "hasDynamicValueInformation"?: boolean;

    /**
     * Identifier for the subscription input
     */
    "id"?: string;

    /**
     * Gets whether this input is confidential, such as for a password or application key
     */
    "isConfidential"?: boolean;

    /**
     * Localized name which can be shown as a label for the subscription input
     */
    "name"?: string;

    /**
     * Custom properties for the input which can be used by the service provider
     */
    "properties"?: { [key: string]: any; };

    /**
     * Underlying data type for the input value. When this value is specified, InputMode, Validation and Values are optional.
     */
    "type"?: string;

    /**
     * Gets whether this input is included in the default generated action description.
     */
    "useInDefaultDescription"?: boolean;

    /**
     * Information to use to validate this input's value
     */
    "validation"?: InputValidation;

    /**
     * A hint for input value. It can be used in the UI as the input placeholder.
     */
    "valueHint"?: string;

    /**
     * Information about possible values for this input
     */
    "values"?: InputValues;
}

/**
 * Defines a filter for subscription inputs. The filter matches a set of inputs if any (one or more) of the groups evaluates to true.
 */
export interface InputFilter {

    /**
     * Groups of input filter expressions. This filter matches a set of inputs if any (one or more) of the groups evaluates to true.
     */
    "conditions"?: Array<InputFilterCondition>;
}

/**
 * An expression which can be applied to filter a list of subscription inputs
 */
export interface InputFilterCondition {

    /**
     * Whether or not to do a case sensitive match
     */
    "caseSensitive"?: boolean;

    /**
     * The Id of the input to filter on
     */
    "inputId"?: string;

    /**
     * The "expected" input value to compare with the actual input value
     */
    "inputValue"?: string;
}

/**
 * Describes what values are valid for a subscription input
 */
export interface InputValidation {
    "isRequired"?: boolean;
    "maxLength"?: number;
    "maxValue"?: string;
    "minLength"?: number;
    "minValue"?: string;
    "pattern"?: string;
    "patternMismatchErrorMessage"?: string;
}

/**
 * 
 */
export interface InputValidationItem extends ValidationItem {
}

/**
 * 
 */
export interface InputValidationRequest {
    "inputs"?: { [key: string]: ValidationItem; };
}

/**
 * Information about a single value for an input
 */
export interface InputValue {

    /**
     * Any other data about this input
     */
    "data"?: { [key: string]: any; };

    /**
     * The text to show for the display of this value
     */
    "displayValue"?: string;

    /**
     * The value to store for this input
     */
    "value"?: string;
}

/**
 * Information about the possible/allowed values for a given subscription input
 */
export interface InputValues {

    /**
     * The default value to use for this input
     */
    "defaultValue"?: string;

    /**
     * Errors encountered while computing dynamic values.
     */
    "error"?: InputValuesError;

    /**
     * The id of the input
     */
    "inputId"?: string;

    /**
     * Should this input be disabled
     */
    "isDisabled"?: boolean;

    /**
     * Should the value be restricted to one of the values in the PossibleValues (True) or are the values in PossibleValues just a suggestion (False)
     */
    "isLimitedToPossibleValues"?: boolean;

    /**
     * Should this input be made read-only
     */
    "isReadOnly"?: boolean;

    /**
     * Possible values that this input can take
     */
    "possibleValues"?: Array<InputValue>;
}

/**
 * Error information related to a subscription input value.
 */
export interface InputValuesError {

    /**
     * The error message.
     */
    "message"?: string;
}

/**
 * 
 */
export interface InputValuesQuery {
    "currentValues"?: { [key: string]: string; };

    /**
     * The input values to return on input, and the result from the consumer on output.
     */
    "inputValues"?: Array<InputValues>;

    /**
     * Subscription containing information about the publisher/consumer and the current input values
     */
    "resource"?: any;
}

/**
 * 
 */
export interface InstallationTarget {
    "target"?: string;
    "targetVersion"?: string;
}

/**
 * Represents a VSTS extension along with its installation state
 */
export interface InstalledExtension extends ExtensionManifest {
}

/**
 * 
 */
export interface InstalledExtensionQuery {
    "assetTypes"?: Array<string>;
    "monikers"?: Array<ExtensionIdentifier>;
}

/**
 * The state of an installed extension
 */
export interface InstalledExtensionState {

    /**
     * List of installation issues
     */
    "installationIssues"?: Array<InstalledExtensionStateIssue>;

    /**
     * The time at which this installation was last updated
     */
    "lastUpdated"?: Date;
}

/**
 * Represents an installation issue
 */
export interface InstalledExtensionStateIssue {

    /**
     * The error message
     */
    "message"?: string;

    /**
     * Source of the installation issue, for example  "Demands"
     */
    "source"?: string;
}

/**
 * Real time event (SignalR) for IsDraft update on a pull request
 */
export interface IsDraftUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface Issue {

    /**
     * The category.
     */
    "category"?: string;

    /**
     * Issue data.
     */
    "data"?: { [key: string]: string; };

    /**
     * Issue message.
     */
    "message"?: string;

    /**
     * Issue type, for example error, warning or info.
     */
    "issueType"?: string;
}

/**
 * 
 */
export interface ItemContent {
    "content"?: string;
}

/**
 * Optional details to include when returning an item model
 */
export interface ItemDetailsOptions {

    /**
     * If true, include metadata about the file type
     */
    "includeContentMetadata"?: boolean;
}

/**
 * 
 */
export interface ItemModel {
    "links"?: ReferenceLinks;
    "content"?: string;
    "contentMetadata"?: FileContentMetadata;
    "isFolder"?: boolean;
    "isSymLink"?: boolean;
    "path"?: string;
    "url"?: string;
}

/**
 * Represents work items in an iteration backlog
 */
export interface IterationWorkItems extends TeamSettingsDataContractBase {
}

/**
 * Represents a JSON object.
 */
export interface JObject {
    "item"?: JToken;

    /**
     * Gets the node type for this JToken.
     */
    "type"?: string;
}

/**
 * Represents an abstract JSON token.
 */
export interface JToken {

    /**
     * Get the first child token of this token.
     */
    "first"?: JToken;

    /**
     * Gets a value indicating whether this token has child tokens.
     */
    "hasValues"?: boolean;
    "item"?: JToken;

    /**
     * Get the last child token of this token.
     */
    "last"?: JToken;

    /**
     * Gets the next sibling token of this node.
     */
    "next"?: JToken;

    /**
     * Gets or sets the parent.
     */
    "parent"?: string;

    /**
     * Gets the path of the JSON token.
     */
    "path"?: string;

    /**
     * Gets the previous sibling token of this node.
     */
    "previous"?: JToken;

    /**
     * Gets the root JToken of this JToken.
     */
    "root"?: JToken;

    /**
     * Gets the node type for this JToken.
     */
    "type"?: string;
}

/**
 * 
 */
export interface JenkinsArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * 
 */
export interface JobAssignedEvent extends JobEvent {
}

/**
 * 
 */
export interface JobCancelMessage {
    "jobId"?: string;
    "timeout"?: string;
}

/**
 * 
 */
export interface JobCompletedEvent extends JobEvent {
}

/**
 * Represents the context of variables and vectors for a job request.
 */
export interface JobEnvironment {
    "endpoints"?: Array<ServiceEndpoint>;
    "mask"?: Array<MaskHint>;
    "options"?: { [key: string]: JobOption; };
    "secureFiles"?: Array<SecureFile>;

    /**
     * Gets or sets the endpoint used for communicating back to the calling service.
     */
    "systemConnection"?: ServiceEndpoint;
    "variables"?: { [key: string]: string; };
}

/**
 * 
 */
export interface JobEvent {
    "jobId"?: string;
    "name"?: string;
}

/**
 * 
 */
export interface JobEventConfig {
    "timeout"?: string;
}

/**
 * 
 */
export interface JobEventsConfig extends EventsConfig {
}

/**
 * Represents an option that may affect the way an agent runs the job.
 */
export interface JobOption {
    "data"?: { [key: string]: string; };

    /**
     * Gets the id of the option.
     */
    "id"?: string;
}

/**
 * 
 */
export interface JobRequestMessage {
    "environment"?: JobEnvironment;
    "jobId"?: string;
    "jobName"?: string;
    "jobRefName"?: string;
    "messageType"?: string;
    "plan"?: TaskOrchestrationPlanReference;
    "timeline"?: TimelineReference;
}

/**
 * 
 */
export interface JobStartedEvent extends JobEvent {
}

/**
 * BlobBlock hash formatted to be deserialized for symbol service.
 */
export interface JsonBlobBlockHash {

    /**
     * Array of hash bytes.
     */
    "hashBytes"?: Array<string>;
}

/**
 * 
 */
export interface JsonBlobIdentifier {
    "identifierValue"?: Array<string>;
}

/**
 * BlobIdentifier with block hashes formatted to be deserialzied for symbol service.
 */
export interface JsonBlobIdentifierWithBlocks {

    /**
     * List of blob block hashes.
     */
    "blockHashes"?: Array<JsonBlobBlockHash>;

    /**
     * Array of blobId bytes.
     */
    "identifierValue"?: Array<string>;
}

/**
 * The JSON model for JSON Patch Operations
 */
export interface JsonPatchDocument extends Array<JsonPatchOperation> {
}

/**
 * The JSON model for a JSON Patch operation
 */
export interface JsonPatchOperation {

    /**
     * The path to copy from for the Move/Copy operation.
     */
    "from"?: string;

    /**
     * The path for the operation
     */
    "path"?: string;

    /**
     * The value for the operation. This is either a primitive or a JToken.
     */
    "value"?: any;
}

/**
 * 
 */
export interface KubernetesServiceGroup extends ServiceGroup {
}

/**
 * 
 */
export interface KubernetesServiceGroupCreateParameters {
    "name"?: string;
    "namespace"?: string;
    "serviceEndpointId"?: string;
}

/**
 * Real time event (SignalR) for updated labels on a pull request
 */
export interface LabelsUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface LastResultDetails {
    "dateCompleted"?: Date;
    "duration"?: number;
    "runBy"?: IdentityRef;
}

/**
 * 
 */
export interface LegacyBuildConfiguration {
    "branchName"?: string;
    "buildConfigurationId"?: number;
    "buildDefinitionId"?: number;
    "buildDefinitionName"?: string;
    "buildFlavor"?: string;
    "buildId"?: number;
    "buildNumber"?: string;
    "buildPlatform"?: string;
    "buildQuality"?: string;
    "buildSystem"?: string;
    "buildUri"?: string;
    "completedDate"?: Date;
    "createdDate"?: Date;
    "oldBuildConfigurationId"?: number;
    "repositoryId"?: string;
    "repositoryType"?: string;
    "sourceVersion"?: string;
    "teamProjectName"?: string;
}

/**
 * 
 */
export interface LegacyReleaseReference {
    "attempt"?: number;
    "environmentCreationDate"?: Date;
    "primaryArtifactBuildId"?: number;
    "primaryArtifactProjectId"?: string;
    "primaryArtifactType"?: string;
    "releaseCreationDate"?: Date;
    "releaseDefId"?: number;
    "releaseEnvDefId"?: number;
    "releaseEnvId"?: number;
    "releaseEnvName"?: string;
    "releaseEnvUri"?: string;
    "releaseId"?: number;
    "releaseName"?: string;
    "releaseRefId"?: number;
    "releaseUri"?: string;
}

/**
 * 
 */
export interface LegacyTestCaseResult {
    "afnStripId"?: number;
    "areaId"?: number;
    "areaUri"?: string;
    "automatedTestId"?: string;
    "automatedTestName"?: string;
    "automatedTestStorage"?: string;
    "automatedTestType"?: string;
    "automatedTestTypeId"?: string;
    "buildNumber"?: string;
    "buildReference"?: LegacyBuildConfiguration;
    "comment"?: string;
    "computerName"?: string;
    "configurationId"?: number;
    "configurationName"?: string;
    "creationDate"?: Date;
    "customFields"?: Array<TestExtensionField>;
    "dateCompleted"?: Date;
    "dateStarted"?: Date;
    "duration"?: number;
    "errorMessage"?: string;
    "failingSince"?: FailingSince;
    "failureType"?: string;
    "id"?: LegacyTestCaseResultIdentifier;
    "isRerun"?: boolean;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "lastUpdatedByName"?: string;
    "outcome"?: string;
    "owner"?: string;
    "ownerName"?: string;
    "priority"?: string;
    "releaseReference"?: LegacyReleaseReference;
    "resetCount"?: number;
    "resolutionStateId"?: number;
    "revision"?: number;
    "runBy"?: string;
    "runByName"?: string;
    "sequenceId"?: number;
    "stackTrace"?: TestExtensionField;
    "state"?: string;
    "subResultCount"?: number;
    "suiteName"?: string;
    "testCaseArea"?: string;
    "testCaseAreaUri"?: string;
    "testCaseId"?: number;
    "testCaseReferenceId"?: number;
    "testCaseRevision"?: number;
    "testCaseTitle"?: string;
    "testPlanId"?: number;
    "testPointId"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
    "testRunTitle"?: string;
    "testSuiteId"?: number;
}

/**
 * 
 */
export interface LegacyTestCaseResultIdentifier {
    "areaUri"?: string;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface LegacyTestRun {
    "bugsCount"?: number;
    "buildConfigurationId"?: number;
    "buildFlavor"?: string;
    "buildNumber"?: string;
    "buildPlatform"?: string;
    "buildReference"?: LegacyBuildConfiguration;
    "buildUri"?: string;
    "comment"?: string;
    "completeDate"?: Date;
    "configurationIds"?: Array<number>;
    "controller"?: string;
    "creationDate"?: Date;
    "csmContent"?: string;
    "csmParameters"?: string;
    "customFields"?: Array<TestExtensionField>;
    "dropLocation"?: string;
    "dtlAutEnvironment"?: ShallowReference;
    "dtlTestEnvironment"?: ShallowReference;
    "dueDate"?: Date;
    "errorMessage"?: string;
    "filter"?: RunFilter;
    "incompleteTests"?: number;
    "isAutomated"?: boolean;
    "isBvt"?: boolean;
    "iteration"?: string;
    "iterationId"?: number;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "lastUpdatedByName"?: string;
    "legacySharePath"?: string;
    "notApplicableTests"?: number;
    "owner"?: string;
    "ownerName"?: string;
    "passedTests"?: number;
    "postProcessState"?: string;
    "publicTestSettingsId"?: number;
    "releaseEnvironmentUri"?: string;
    "releaseReference"?: LegacyReleaseReference;
    "releaseUri"?: string;
    "revision"?: number;
    "rowVersion"?: Array<string>;
    "runHasDtlEnvironment"?: boolean;
    "runTimeout"?: string;
    "serviceVersion"?: string;
    "sourceWorkflow"?: string;
    "startDate"?: Date;
    "state"?: string;
    "subscriptionName"?: string;
    "substate"?: string;
    "teamProject"?: string;
    "teamProjectUri"?: string;
    "testConfigurationsMapping"?: string;
    "testEnvironmentId"?: string;
    "testMessageLogEntries"?: Array<TestMessageLogDetails>;
    "testMessageLogId"?: number;
    "testPlanId"?: number;
    "testRunId"?: number;
    "testRunStatistics"?: Array<LegacyTestRunStatistic>;
    "testSettingsId"?: number;
    "title"?: string;
    "totalTests"?: number;
    "type"?: string;
    "unanalyzedTests"?: number;
    "version"?: number;
}

/**
 * 
 */
export interface LegacyTestRunStatistic {
    "count"?: number;
    "outcome"?: string;
    "resolutionState"?: TestResolutionState;
    "state"?: string;
    "testRunId"?: number;
}

/**
 * 
 */
export interface LegacyTestSettings {
    "areaId"?: number;
    "areaPath"?: string;
    "createdBy"?: string;
    "createdByName"?: string;
    "createdDate"?: Date;
    "description"?: string;
    "id"?: number;
    "isAutomated"?: boolean;
    "isPublic"?: boolean;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "lastUpdatedByName"?: string;
    "machineRoles"?: Array<TestSettingsMachineRole>;
    "name"?: string;
    "revision"?: number;
    "settings"?: string;
    "teamProjectUri"?: string;
}

/**
 * Summary of Licenses in the organization.
 */
export interface LicenseSummaryData extends SummaryData {
}

/**
 * Maps a contribution to a licensing behavior
 */
export interface LicensingOverride {

    /**
     * Fully qualified contribution id which we want to define licensing behavior for
     */
    "id"?: string;
}

/**
 * Lightbox configuration
 */
export interface LightboxOptions {

    /**
     * Height of desired lightbox, in pixels
     */
    "height"?: number;

    /**
     * True to allow lightbox resizing, false to disallow lightbox resizing, defaults to false.
     */
    "resizable"?: boolean;

    /**
     * Width of desired lightbox, in pixels
     */
    "width"?: number;
}

/**
 * 
 */
export interface LineBlockCoverage {

    /**
     * End of line block
     */
    "end"?: number;

    /**
     * Start of line block
     */
    "start"?: number;

    /**
     * Coverage status
     */
    "status"?: number;
}

/**
 * The class to represent the line diff block
 */
export interface LineDiffBlock {

    /**
     * Line number where this block starts in modified file.
     */
    "modifiedLineNumberStart"?: number;

    /**
     * Count of lines in this block in modified file.
     */
    "modifiedLinesCount"?: number;

    /**
     * Line number where this block starts in original file.
     */
    "originalLineNumberStart"?: number;

    /**
     * Count of lines in this block in original file.
     */
    "originalLinesCount"?: number;
}

/**
 * Link description.
 */
export interface Link {

    /**
     * Collection of link attributes.
     */
    "attributes"?: { [key: string]: any; };

    /**
     * Relation type.
     */
    "rel"?: string;

    /**
     * Link url.
     */
    "url"?: string;
}

/**
 * 
 */
export interface LinkedWorkItemsQuery {
    "automatedTestNames"?: Array<string>;
    "planId"?: number;
    "pointIds"?: Array<number>;
    "suiteIds"?: Array<number>;
    "testCaseIds"?: Array<number>;
    "workItemCategory"?: string;
}

/**
 * 
 */
export interface LinkedWorkItemsQueryResult {
    "automatedTestName"?: string;
    "planId"?: number;
    "pointId"?: number;
    "suiteId"?: number;
    "testCaseId"?: number;
    "workItems"?: Array<WorkItemReference>;
}

/**
 * 
 */
export interface LoadGenerationGeoLocation {
    "location"?: string;
    "percentage"?: number;
}

/**
 * 
 */
export interface LoadTest {
}

/**
 * 
 */
export interface LoadTestDefinition {
    "agentCount"?: number;
    "browserMixs"?: Array<BrowserMix>;
    "coreCount"?: number;
    "coresPerAgent"?: number;
    "loadGenerationGeoLocations"?: Array<LoadGenerationGeoLocation>;
    "loadPatternName"?: string;
    "loadTestName"?: string;
    "maxVusers"?: number;
    "runDuration"?: number;
    "samplingRate"?: number;
    "thinkTime"?: number;
    "urls"?: Array<string>;
}

/**
 * 
 */
export interface LoadTestErrors {
    "count"?: number;
    "occurrences"?: number;
    "types"?: Array<Type>;
    "url"?: string;
}

/**
 * 
 */
export interface LoadTestRunDetails extends LoadTestRunSettings {
}

/**
 * 
 */
export interface LoadTestRunSettings {
    "agentCount"?: number;
    "coreCount"?: number;
    "coresPerAgent"?: number;
    "duration"?: number;
    "samplingInterval"?: number;
    "warmUpDuration"?: number;
}

/**
 * 
 */
export interface MachineGroupBasedDeployPhase extends DeployPhase {
}

/**
 * 
 */
export interface MachineGroupDeploymentInput extends DeploymentInput {
}

/**
 * 
 */
export interface MailMessage {

    /**
     * Body of mail.
     */
    "body"?: string;

    /**
     * Mail CC recipients.
     */
    "cc"?: EmailRecipients;

    /**
     * Reply to.
     */
    "inReplyTo"?: string;

    /**
     * Message ID of the mail.
     */
    "messageId"?: string;

    /**
     * Data when should be replied to mail.
     */
    "replyBy"?: Date;

    /**
     * Reply to Email recipients.
     */
    "replyTo"?: EmailRecipients;

    /**
     * List of mail section types.
     */
    "sections"?: Array<ERRORUNKNOWN>;

    /**
     * Subject of the mail.
     */
    "subject"?: string;

    /**
     * Mail To recipients.
     */
    "to"?: EmailRecipients;
}

/**
 * 
 */
export interface ManualIntervention {

    /**
     * Gets or sets the identity who should approve.
     */
    "approver"?: IdentityRef;

    /**
     * Gets or sets comments for approval.
     */
    "comments"?: string;

    /**
     * Gets date on which it got created.
     */
    "createdOn"?: Date;

    /**
     * Gets the unique identifier for manual intervention.
     */
    "id"?: number;

    /**
     * Gets or sets instructions for approval.
     */
    "instructions"?: string;

    /**
     * Gets date on which it got modified.
     */
    "modifiedOn"?: Date;

    /**
     * Gets or sets the name.
     */
    "name"?: string;

    /**
     * Gets releaseReference for manual intervention.
     */
    "release"?: ReleaseShallowReference;

    /**
     * Gets releaseDefinitionReference for manual intervention.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * Gets releaseEnvironmentReference for manual intervention.
     */
    "releaseEnvironment"?: ReleaseEnvironmentShallowReference;

    /**
     * Get task instance identifier.
     */
    "taskInstanceId"?: string;

    /**
     * Gets url to access the manual intervention.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ManualInterventionUpdateMetadata {

    /**
     * Sets the comment for manual intervention update.
     */
    "comment"?: string;
}

/**
 * 
 */
export interface MappingDetails {

    /**
     * The local path.
     */
    "localPath"?: string;

    /**
     * The mapping type.
     */
    "mappingType"?: string;

    /**
     * The server path.
     */
    "serverPath"?: string;
    "mappings"?: { [key: string]: InputValue; };
}

/**
 * Client serialization contract for Delivery Timeline Markers.
 */
export interface Marker {

    /**
     * Color associated with the marker.
     */
    "color"?: string;

    /**
     * Where the marker should be displayed on the timeline.
     */
    "date"?: Date;

    /**
     * Label/title for the marker.
     */
    "label"?: string;
}

/**
 * Represents a purchase of resource units in a secondary marketplace.
 */
export interface MarketplacePurchasedLicense {

    /**
     * The Marketplace display name.
     */
    "marketplaceName"?: string;

    /**
     * The name of the identity making the purchase as seen by the marketplace
     */
    "purchaserName"?: string;

    /**
     * The quantity purchased.
     */
    "purchaseUnitCount"?: number;
}

/**
 * 
 */
export interface MaskHint {
    "value"?: string;
}

/**
 * 
 */
export interface MatcherResult {
    "matcher"?: string;
    "stats"?: { [key: string]: any; };
}

/**
 * 
 */
export interface MavenDistributionManagement {
    "repository"?: MavenRepository;
    "snapshotRepository"?: MavenSnapshotRepository;
}

/**
 * Identifies a particular Maven package version
 */
export interface MavenMinimalPackageDetails {

    /**
     * Package artifact ID
     */
    "artifact"?: string;

    /**
     * Package group ID
     */
    "group"?: string;

    /**
     * Package version
     */
    "version"?: string;
}

/**
 * 
 */
export interface MavenPackage {
    "artifactId"?: string;
    "artifactIndex"?: ReferenceLink;
    "artifactMetadata"?: ReferenceLink;
    "deletedDate"?: Date;
    "files"?: ReferenceLinks;
    "groupId"?: string;
    "pom"?: MavenPomMetadata;
    "requestedFile"?: ReferenceLink;
    "snapshotMetadata"?: ReferenceLink;
    "version"?: string;
    "versions"?: ReferenceLinks;
    "versionsIndex"?: ReferenceLink;
}

/**
 * Deletion state of a maven package.
 */
export interface MavenPackageVersionDeletionState {

    /**
     * Artifact Id of the package.
     */
    "artifactId"?: string;

    /**
     * UTC date the package was deleted.
     */
    "deletedDate"?: Date;

    /**
     * Group Id of the package.
     */
    "groupId"?: string;

    /**
     * Version of the package.
     */
    "version"?: string;
}

/**
 * A batch of operations to apply to package versions.
 */
export interface MavenPackagesBatchRequest {

    /**
     * Data required to perform the operation. This is optional based on type of operation. Use BatchPromoteData if performing a promote operation.
     */
    "data"?: BatchOperationData;

    /**
     * The packages onto which the operation will be performed.
     */
    "packages"?: Array<MavenMinimalPackageDetails>;
}

/**
 * 
 */
export interface MavenPomBuild {
    "plugins"?: Array<Plugin>;
}

/**
 * 
 */
export interface MavenPomCi {
    "notifiers"?: Array<MavenPomCiNotifier>;
    "system"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface MavenPomCiNotifier {
    "configuration"?: Array<string>;
    "sendOnError"?: string;
    "sendOnFailure"?: string;
    "sendOnSuccess"?: string;
    "sendOnWarning"?: string;
    "type"?: string;
}

/**
 * 
 */
export interface MavenPomDependency extends MavenPomGav {
}

/**
 * 
 */
export interface MavenPomDependencyManagement {
    "dependencies"?: Array<MavenPomDependency>;
}

/**
 * 
 */
export interface MavenPomGav {
    "artifactId"?: string;
    "groupId"?: string;
    "version"?: string;
}

/**
 * 
 */
export interface MavenPomIssueManagement {
    "system"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface MavenPomLicense extends MavenPomOrganization {
}

/**
 * 
 */
export interface MavenPomMailingList {
    "archive"?: string;
    "name"?: string;
    "otherArchives"?: Array<string>;
    "post"?: string;
    "subscribe"?: string;
    "unsubscribe"?: string;
}

/**
 * 
 */
export interface MavenPomMetadata extends MavenPomGav {
}

/**
 * 
 */
export interface MavenPomOrganization {
    "name"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface MavenPomParent extends MavenPomGav {
}

/**
 * 
 */
export interface MavenPomPerson {
    "email"?: string;
    "id"?: string;
    "name"?: string;
    "organization"?: string;
    "organizationUrl"?: string;
    "roles"?: Array<string>;
    "timezone"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface MavenPomScm {
    "connection"?: string;
    "developerConnection"?: string;
    "tag"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface MavenRecycleBinPackageVersionDetails {

    /**
     * Setting to false will undo earlier deletion and restore the package to feed.
     */
    "deleted"?: boolean;
}

/**
 * 
 */
export interface MavenRepository {
    "uniqueVersion"?: boolean;
}

/**
 * 
 */
export interface MavenSnapshotRepository extends MavenRepository {
}

/**
 * 
 */
export interface Member {
    "displayName"?: string;
    "id"?: string;
    "imageUrl"?: string;
    "uniqueName"?: string;
    "url"?: string;
}

/**
 * Deprecated: Use UserEntitlement instead
 */
export interface MemberEntitlement extends UserEntitlement {
}

/**
 * 
 */
export interface MemberEntitlementOperationReference extends OperationReference {
}

/**
 * 
 */
export interface MemberEntitlementsPatchResponse extends MemberEntitlementsResponseBase {
}

/**
 * 
 */
export interface MemberEntitlementsPostResponse extends MemberEntitlementsResponseBase {
}

/**
 * 
 */
export interface MemberEntitlementsResponseBase {

    /**
     * True if all operations were successful.
     */
    "isSuccess"?: boolean;

    /**
     * Result of the member entitlement after the operations. have been applied
     */
    "memberEntitlement"?: MemberEntitlement;
}

/**
 * Real time event (SignalR) for a merge completed on a pull request
 */
export interface MergeCompletedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface MessageQueueSubscriptionChannel {
    "type"?: string;
}

/**
 * 
 */
export interface Metric {

    /**
     * Name of the Metric.
     */
    "name"?: string;

    /**
     * Value of the Metric.
     */
    "value"?: number;
}

/**
 * Meta data for a metrics column.
 */
export interface MetricsColumnMetaData {

    /**
     * Name.
     */
    "columnName"?: string;

    /**
     * Data type.
     */
    "columnValueType"?: string;
}

/**
 * Metrics columns header
 */
export interface MetricsColumnsHeader {

    /**
     * Properties of deployment group for which metrics are provided. E.g. 1: LastJobStatus E.g. 2: TargetState
     */
    "dimensions"?: Array<MetricsColumnMetaData>;

    /**
     * The types of metrics. E.g. 1: total count of deployment targets. E.g. 2: Average time of deployment to the deployment targets.
     */
    "metrics"?: Array<MetricsColumnMetaData>;
}

/**
 * Metrics row.
 */
export interface MetricsRow {

    /**
     * The values of the properties mentioned as 'Dimensions' in column header. E.g. 1: For a property 'LastJobStatus' - metrics will be provided for 'passed', 'failed', etc. E.g. 2: For a property 'TargetState' - metrics will be provided for 'online', 'offline' targets.
     */
    "dimensions"?: Array<string>;

    /**
     * Metrics in serialized format. Should be deserialized based on the data type provided in header.
     */
    "metrics"?: Array<string>;
}

/**
 * Minimal package details required to identify a package within a protocol.
 */
export interface MinimalPackageDetails {

    /**
     * Package name.
     */
    "id"?: string;

    /**
     * Package version.
     */
    "version"?: string;
}

/**
 * Core data about any package, including its id and version information and basic state.
 */
export interface MinimalPackageVersion {

    /**
     * Upstream source this package was ingested from.
     */
    "directUpstreamSourceId"?: string;

    /**
     * Id for the package.
     */
    "id"?: string;

    /**
     * [Obsolete] Used for legacy scenarios and may be removed in future versions.
     */
    "isCachedVersion"?: boolean;

    /**
     * True if this package has been deleted.
     */
    "isDeleted"?: boolean;

    /**
     * True if this is the latest version of the package by package type sort order.
     */
    "isLatest"?: boolean;

    /**
     * (NuGet Only) True if this package is listed.
     */
    "isListed"?: boolean;

    /**
     * Normalized version using normalization rules specific to a package type.
     */
    "normalizedVersion"?: string;

    /**
     * Package description.
     */
    "packageDescription"?: string;

    /**
     * UTC Date the package was published to the service.
     */
    "publishDate"?: Date;

    /**
     * Internal storage id.
     */
    "storageId"?: string;

    /**
     * Display version.
     */
    "version"?: string;

    /**
     * List of views containing this package version.
     */
    "views"?: Array<FeedView>;
}

/**
 * Package version metadata for a Universal package
 */
export interface ModelPackage {

    /**
     * Related REST links.
     */
    "links"?: ReferenceLinks;

    /**
     * Package Id.
     */
    "id"?: string;

    /**
     * Used for legacy scenarios and may be removed in future versions.
     */
    "isCached"?: boolean;

    /**
     * The display name of the package.
     */
    "name"?: string;

    /**
     * The normalized name representing the identity of this package within its package type.
     */
    "normalizedName"?: string;

    /**
     * Type of the package.
     */
    "protocolType"?: string;

    /**
     * [Obsolete] - this field is unused and will be removed in a future release.
     */
    "starCount"?: number;

    /**
     * Url for this package.
     */
    "url"?: string;

    /**
     * All versions for this package within its feed.
     */
    "versions"?: Array<MinimalPackageVersion>;

    /**
     * If and when the package was deleted.
     */
    "deletedDate"?: Date;

    /**
     * If and when the package was permanently deleted.
     */
    "permanentlyDeletedDate"?: Date;

    /**
     * The version of the package.
     */
    "version"?: string;

    /**
     * Deprecated message, if any, for the package.
     */
    "deprecateMessage"?: string;

    /**
     * The history of upstream sources for this package. The first source in the list is the immediate source from which this package was saved.
     */
    "sourceChain"?: Array<UpstreamSourceInfo>;

    /**
     * If and when the package was deleted.
     */
    "unpublishedDate"?: Date;
}

/**
 * 
 */
export interface ModuleCoverage {
    "blockCount"?: number;
    "blockData"?: Array<string>;

    /**
     * Code Coverage File Url
     */
    "fileUrl"?: string;
    "functions"?: Array<FunctionCoverage>;
    "name"?: string;
    "signature"?: string;
    "signatureAge"?: number;
    "statistics"?: CoverageStatistics;
}

/**
 * 
 */
export interface ModuleCoverage2 {
    "blockCount"?: number;
    "blockData"?: Array<string>;
    "blockDataLength"?: number;
    "blocksCovered"?: number;
    "blocksNotCovered"?: number;
    "coverageFileUrl"?: string;
    "coverageId"?: number;
    "linesCovered"?: number;
    "linesNotCovered"?: number;
    "linesPartiallyCovered"?: number;
    "moduleId"?: number;
    "name"?: string;
    "signature"?: string;
    "signatureAge"?: number;
}

/**
 * 
 */
export interface MultiConfigInput extends ParallelExecutionInputBase {
}

/**
 * 
 */
export interface MultiMachineInput extends ParallelExecutionInputBase {
}

/**
 * Represents options for running a phase against multiple agents.
 */
export interface MultipleAgentExecutionOptions extends AgentTargetExecutionOptions {
}

/**
 * Name value pair
 */
export interface NameValuePair {

    /**
     * Name
     */
    "name"?: string;

    /**
     * Value
     */
    "value"?: string;
}

/**
 * Defines the data contract of the result of processing an event for a subscription.
 */
export interface Notification {

    /**
     * Gets or sets date and time that this result was created.
     */
    "createdDate"?: Date;

    /**
     * Details about this notification (if available)
     */
    "details"?: NotificationDetails;

    /**
     * The event id associated with this notification
     */
    "eventId"?: string;

    /**
     * The notification id
     */
    "id"?: number;

    /**
     * Gets or sets date and time that this result was last modified.
     */
    "modifiedDate"?: Date;

    /**
     * The subscriber Id  associated with this notification. This is the last identity who touched in the subscription. In case of test notifications it can be the tester if the subscription is not created yet.
     */
    "subscriberId"?: string;

    /**
     * The subscription id associated with this notification
     */
    "subscriptionId"?: string;
}

/**
 * 
 */
export interface NotificationAdminSettings {
}

/**
 * 
 */
export interface NotificationAdminSettingsUpdateParameters {
}

/**
 * 
 */
export interface NotificationBacklogStatus {
    "captureTime"?: Date;
    "channel"?: string;
    "jobId"?: string;
    "lastJobBatchStartTime"?: Date;
    "lastJobProcessedTime"?: Date;
    "lastNotificationBatchStartTime"?: Date;
    "lastNotificationProcessedTime"?: Date;
    "oldestPendingNotificationTime"?: Date;
    "publisher"?: string;

    /**
     * Null status is unprocessed
     */
    "status"?: string;
    "unprocessedNotifications"?: number;
}

/**
 * 
 */
export interface NotificationBatch {
    "endTime"?: string;
    "notificationCount"?: number;
    "notificationIds"?: string;
    "problematicNotifications"?: Array<DiagnosticNotification>;
    "startTime"?: string;
}

/**
 * 
 */
export interface NotificationDeliveryLog extends NotificationJobDiagnosticLog {
}

/**
 * Defines the data contract of notification details.
 */
export interface NotificationDetails {

    /**
     * Gets or sets the time that this notification was completed (response received from the consumer)
     */
    "completedDate"?: Date;

    /**
     * Gets or sets this notification detail's consumer action identifier.
     */
    "consumerActionId"?: string;

    /**
     * Gets or sets this notification detail's consumer identifier.
     */
    "consumerId"?: string;

    /**
     * Gets or sets this notification detail's consumer inputs.
     */
    "consumerInputs"?: { [key: string]: string; };

    /**
     * Gets or sets the time that this notification was dequeued for processing
     */
    "dequeuedDate"?: Date;

    /**
     * Gets or sets this notification detail's error detail.
     */
    "errorDetail"?: string;

    /**
     * Gets or sets this notification detail's error message.
     */
    "errorMessage"?: string;

    /**
     * Gets or sets this notification detail's event content.
     */
    "event"?: Event;

    /**
     * Gets or sets this notification detail's event type.
     */
    "eventType"?: string;

    /**
     * Gets or sets the time that this notification was finished processing (just before the request is sent to the consumer)
     */
    "processedDate"?: Date;

    /**
     * Gets or sets this notification detail's publisher identifier.
     */
    "publisherId"?: string;

    /**
     * Gets or sets this notification detail's publisher inputs.
     */
    "publisherInputs"?: { [key: string]: string; };

    /**
     * Gets or sets the time that this notification was queued (created)
     */
    "queuedDate"?: Date;

    /**
     * Gets or sets this notification detail's request.
     */
    "request"?: string;

    /**
     * Number of requests attempted to be sent to the consumer
     */
    "requestAttempts"?: number;

    /**
     * Duration of the request to the consumer in seconds
     */
    "requestDuration"?: number;

    /**
     * Gets or sets this notification detail's reponse.
     */
    "response"?: string;
}

/**
 * Abstract base class for all of the diagnostic logs.
 */
export interface NotificationDiagnosticLog {

    /**
     * Identifier used for correlating to other diagnostics that may have been recorded elsewhere.
     */
    "activityId"?: string;
    "description"?: string;
    "endTime"?: Date;
    "errors"?: number;

    /**
     * Unique instance identifier.
     */
    "id"?: string;
    "logType"?: string;
    "messages"?: Array<NotificationDiagnosticLogMessage>;
    "properties"?: { [key: string]: string; };

    /**
     * This identifier depends on the logType.  For notification jobs, this will be the job Id. For subscription tracing, this will be a special root Guid with the subscription Id encoded.
     */
    "source"?: string;
    "startTime"?: Date;
    "warnings"?: number;
}

/**
 * 
 */
export interface NotificationDiagnosticLogMessage {

    /**
     * Corresponds to .Net TraceLevel enumeration
     */
    "level"?: number;
    "message"?: string;
    "time"?: string;
}

/**
 * 
 */
export interface NotificationEventBacklogStatus {
    "eventBacklogStatus"?: Array<EventBacklogStatus>;
    "notificationBacklogStatus"?: Array<NotificationBacklogStatus>;
}

/**
 * Encapsulates the properties of a filterable field. A filterable field is a field in an event that can used to filter notifications for a certain event type.
 */
export interface NotificationEventField {

    /**
     * Gets or sets the type of this field.
     */
    "fieldType"?: NotificationEventFieldType;

    /**
     * Gets or sets the unique identifier of this field.
     */
    "id"?: string;

    /**
     * Gets or sets the name of this field.
     */
    "name"?: string;

    /**
     * Gets or sets the path to the field in the event object. This path can be either Json Path or XPath, depending on if the event will be serialized into Json or XML
     */
    "path"?: string;

    /**
     * Gets or sets the scopes that this field supports. If not specified then the event type scopes apply.
     */
    "supportedScopes"?: Array<string>;
}

/**
 * Encapsulates the properties of a field type. It includes a unique id for the operator and a localized string for display name
 */
export interface NotificationEventFieldOperator {

    /**
     * Gets or sets the display name of an operator
     */
    "displayName"?: string;

    /**
     * Gets or sets the id of an operator
     */
    "id"?: string;
}

/**
 * Encapsulates the properties of a field type. It describes the data type of a field, the operators it support and how to populate it in the UI
 */
export interface NotificationEventFieldType {

    /**
     * Gets or sets the unique identifier of this field type.
     */
    "id"?: string;
    "operatorConstraints"?: Array<OperatorConstraint>;

    /**
     * Gets or sets the list of operators that this type supports.
     */
    "operators"?: Array<NotificationEventFieldOperator>;

    /**
     * Gets or sets the value definition of this field like the getValuesMethod and template to display in the UI
     */
    "value"?: ValueDefinition;
}

/**
 * Encapsulates the properties of a notification event publisher.
 */
export interface NotificationEventPublisher {
    "id"?: string;
    "subscriptionManagementInfo"?: SubscriptionManagement;
    "url"?: string;
}

/**
 * Encapsulates the properties of an event role.  An event Role is used for role based subscription for example for a buildCompletedEvent, one role is request by field
 */
export interface NotificationEventRole {

    /**
     * Gets or sets an Id for that role, this id is used by the event.
     */
    "id"?: string;

    /**
     * Gets or sets the Name for that role, this name is used for UI display.
     */
    "name"?: string;

    /**
     * Gets or sets whether this role can be a group or just an individual user
     */
    "supportsGroups"?: boolean;
}

/**
 * Encapsulates the properties of an event type. It defines the fields, that can be used for filtering, for that event type.
 */
export interface NotificationEventType {
    "category"?: NotificationEventTypeCategory;

    /**
     * Gets or sets the color representing this event type. Example: rgb(128,245,211) or #fafafa
     */
    "color"?: string;
    "customSubscriptionsAllowed"?: boolean;
    "eventPublisher"?: NotificationEventPublisher;
    "fields"?: { [key: string]: NotificationEventField; };
    "hasInitiator"?: boolean;

    /**
     * Gets or sets the icon representing this event type. Can be a URL or a CSS class. Example: css://some-css-class
     */
    "icon"?: string;

    /**
     * Gets or sets the unique identifier of this event definition.
     */
    "id"?: string;

    /**
     * Gets or sets the name of this event definition.
     */
    "name"?: string;
    "roles"?: Array<NotificationEventRole>;

    /**
     * Gets or sets the scopes that this event type supports
     */
    "supportedScopes"?: Array<string>;

    /**
     * Gets or sets the rest end point to get this event type details (fields, fields types)
     */
    "url"?: string;
}

/**
 * Encapsulates the properties of a category. A category will be used by the UI to group event types
 */
export interface NotificationEventTypeCategory {

    /**
     * Gets or sets the unique identifier of this category.
     */
    "id"?: string;

    /**
     * Gets or sets the friendly name of this category.
     */
    "name"?: string;
}

/**
 * 
 */
export interface NotificationJobDiagnosticLog extends NotificationDiagnosticLog {
}

/**
 * 
 */
export interface NotificationQueryCondition {
    "eventInitiator"?: string;
    "eventType"?: string;
    "subscriber"?: string;
    "subscriptionId"?: string;
}

/**
 * 
 */
export interface NotificationReason {
    "targetIdentities"?: Array<IdentityRef>;
}

/**
 * Summary of a particular result and count.
 */
export interface NotificationResultsSummaryDetail {

    /**
     * Count of notification sent out with a matching result.
     */
    "notificationCount"?: number;
}

/**
 * 
 */
export interface NotificationStatistic {
    "date"?: Date;
    "hitCount"?: number;
    "path"?: string;
    "user"?: IdentityRef;
}

/**
 * 
 */
export interface NotificationStatisticsQuery {
    "conditions"?: Array<NotificationStatisticsQueryConditions>;
}

/**
 * 
 */
export interface NotificationStatisticsQueryConditions {
    "endDate"?: Date;
    "hitCountMinimum"?: number;
    "path"?: string;
    "startDate"?: Date;
    "user"?: IdentityRef;
}

/**
 * A subscriber is a user or group that has the potential to receive notifications.
 */
export interface NotificationSubscriber {

    /**
     * Identifier of the subscriber.
     */
    "id"?: string;

    /**
     * Preferred email address of the subscriber. A null or empty value indicates no preferred email address has been set.
     */
    "preferredEmailAddress"?: string;
}

/**
 * Updates to a subscriber. Typically used to change (or set) a preferred email address or default delivery preference.
 */
export interface NotificationSubscriberUpdateParameters {

    /**
     * New preferred email address for the subscriber. Specify an empty string to clear the current address.
     */
    "preferredEmailAddress"?: string;
}

/**
 * A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events.
 */
export interface NotificationSubscription {

    /**
     * Links to related resources, APIs, and views for the subscription.
     */
    "links"?: ReferenceLinks;

    /**
     * Admin-managed settings for the subscription. Only applies when the subscriber is a group.
     */
    "adminSettings"?: SubscriptionAdminSettings;

    /**
     * Channel for delivering notifications triggered by the subscription.
     */
    "channel"?: ISubscriptionChannel;

    /**
     * Description of the subscription. Typically describes filter criteria which helps identity the subscription.
     */
    "description"?: string;

    /**
     * Diagnostics for this subscription.
     */
    "diagnostics"?: SubscriptionDiagnostics;

    /**
     * Any extra properties like detailed description for different contexts, user/group contexts
     */
    "extendedProperties"?: { [key: string]: string; };

    /**
     * Matching criteria for the subscription. ExpressionFilter
     */
    "filter"?: ISubscriptionFilter;

    /**
     * Subscription identifier.
     */
    "id"?: string;

    /**
     * User that last modified (or created) the subscription.
     */
    "lastModifiedBy"?: IdentityRef;

    /**
     * Date when the subscription was last modified. If the subscription has not been updated since it was created, this value will indicate when the subscription was created.
     */
    "modifiedDate"?: Date;

    /**
     * The container in which events must be published from in order to be matched by the subscription. If empty, the scope is the current host (typically an account or project collection). For example, a subscription scoped to project A will not produce notifications for events published from project B.
     */
    "scope"?: SubscriptionScope;

    /**
     * Message that provides more details about the status of the subscription.
     */
    "statusMessage"?: string;

    /**
     * User or group that will receive notifications for events matching the subscription's filter criteria.
     */
    "subscriber"?: IdentityRef;

    /**
     * REST API URL of the subscriotion.
     */
    "url"?: string;

    /**
     * User-managed settings for the subscription. Only applies when the subscriber is a group. Typically used to indicate whether the calling user is opted in or out of a group subscription.
     */
    "userSettings"?: SubscriptionUserSettings;
}

/**
 * Parameters for creating a new subscription. A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events.
 */
export interface NotificationSubscriptionCreateParameters {

    /**
     * Channel for delivering notifications triggered by the new subscription.
     */
    "channel"?: ISubscriptionChannel;

    /**
     * Brief description for the new subscription. Typically describes filter criteria which helps identity the subscription.
     */
    "description"?: string;

    /**
     * Matching criteria for the new subscription. ExpressionFilter
     */
    "filter"?: ISubscriptionFilter;

    /**
     * The container in which events must be published from in order to be matched by the new subscription. If not specified, defaults to the current host (typically an account or project collection). For example, a subscription scoped to project A will not produce notifications for events published from project B.
     */
    "scope"?: SubscriptionScope;

    /**
     * User or group that will receive notifications for events matching the subscription's filter criteria. If not specified, defaults to the calling user.
     */
    "subscriber"?: IdentityRef;
}

/**
 * 
 */
export interface NotificationSubscriptionTemplate {
    "description"?: string;
    "filter"?: ISubscriptionFilter;
    "id"?: string;
    "notificationEventInformation"?: NotificationEventType;
}

/**
 * Parameters for updating an existing subscription. A subscription defines criteria for matching events and how the subscription's subscriber should be notified about those events. Note: only the fields to be updated should be set.
 */
export interface NotificationSubscriptionUpdateParameters {

    /**
     * Admin-managed settings for the subscription. Only applies to subscriptions where the subscriber is a group.
     */
    "adminSettings"?: SubscriptionAdminSettings;

    /**
     * Channel for delivering notifications triggered by the subscription.
     */
    "channel"?: ISubscriptionChannel;

    /**
     * Updated description for the subscription. Typically describes filter criteria which helps identity the subscription.
     */
    "description"?: string;

    /**
     * Matching criteria for the subscription. ExpressionFilter
     */
    "filter"?: ISubscriptionFilter;

    /**
     * The container in which events must be published from in order to be matched by the new subscription. If not specified, defaults to the current host (typically the current account or project collection). For example, a subscription scoped to project A will not produce notifications for events published from project B.
     */
    "scope"?: SubscriptionScope;

    /**
     * Optional message that provides more details about the updated status.
     */
    "statusMessage"?: string;

    /**
     * User-managed settings for the subscription. Only applies to subscriptions where the subscriber is a group. Typically used to opt-in or opt-out a user from a group subscription.
     */
    "userSettings"?: SubscriptionUserSettings;
}

/**
 * Summary of the notifications for a subscription.
 */
export interface NotificationSummary {

    /**
     * The notification results for this particular subscription.
     */
    "results"?: Array<NotificationResultsSummaryDetail>;

    /**
     * The subscription id associated with this notification
     */
    "subscriptionId"?: string;
}

/**
 * Encapsulates notifications result properties. It defines the number of notifications and the recipients of notifications.
 */
export interface NotificationsEvaluationResult {

    /**
     * Count of generated notifications
     */
    "count"?: number;
}

/**
 * Defines a query for service hook notifications.
 */
export interface NotificationsQuery {

    /**
     * The subscriptions associated with the notifications returned from the query
     */
    "associatedSubscriptions"?: Array<Subscription>;

    /**
     * If true, we will return all notification history for the query provided; otherwise, the summary is returned.
     */
    "includeDetails"?: boolean;

    /**
     * Optional maximum date at which the notification was created
     */
    "maxCreatedDate"?: Date;

    /**
     * Optional maximum number of overall results to include
     */
    "maxResults"?: number;

    /**
     * Optional maximum number of results for each subscription. Only takes effect when a list of subscription ids is supplied in the query.
     */
    "maxResultsPerSubscription"?: number;

    /**
     * Optional minimum date at which the notification was created
     */
    "minCreatedDate"?: Date;

    /**
     * Optional publisher id to restrict the results to
     */
    "publisherId"?: string;

    /**
     * Results from the query
     */
    "results"?: Array<Notification>;

    /**
     * Optional list of subscription ids to restrict the results to
     */
    "subscriptionIds"?: Array<string>;

    /**
     * Summary of notifications - the count of each result type (success, fail, ..).
     */
    "summary"?: Array<NotificationSummary>;
}

/**
 * Deletion state of an npm package.
 */
export interface NpmPackageVersionDeletionState {

    /**
     * Name of the package.
     */
    "name"?: string;

    /**
     * UTC date the package was unpublished.
     */
    "unpublishedDate"?: Date;

    /**
     * Version of the package.
     */
    "version"?: string;
}

/**
 * A batch of operations to apply to package versions.
 */
export interface NpmPackagesBatchRequest {

    /**
     * Data required to perform the operation. This is optional based on type of operation. Use BatchPromoteData if performing a promote operation.
     */
    "data"?: BatchOperationData;

    /**
     * The packages onto which the operation will be performed.
     */
    "packages"?: Array<MinimalPackageDetails>;
}

/**
 * 
 */
export interface NpmRecycleBinPackageVersionDetails {

    /**
     * Setting to false will undo earlier deletion and restore the package to feed.
     */
    "deleted"?: boolean;
}

/**
 * Deletion state of a NuGet package.
 */
export interface NuGetPackageVersionDeletionState {

    /**
     * Utc date the package was deleted.
     */
    "deletedDate"?: Date;

    /**
     * Name of the package.
     */
    "name"?: string;

    /**
     * Version of the package.
     */
    "version"?: string;
}

/**
 * A batch of operations to apply to package versions.
 */
export interface NuGetPackagesBatchRequest {

    /**
     * Data required to perform the operation. This is optional based on the type of the operation. Use BatchPromoteData if performing a promote operation.
     */
    "data"?: BatchOperationData;

    /**
     * The packages onto which the operation will be performed.
     */
    "packages"?: Array<MinimalPackageDetails>;
}

/**
 * 
 */
export interface NuGetRecycleBinPackageVersionDetails {

    /**
     * Setting to false will undo earlier deletion and restore the package to feed.
     */
    "deleted"?: boolean;
}

/**
 * 
 */
export interface OAuthConfiguration {

    /**
     * Gets or sets the ClientId
     */
    "clientId"?: string;

    /**
     * Gets or sets the ClientSecret
     */
    "clientSecret"?: string;

    /**
     * Gets or sets the identity who created the config.
     */
    "createdBy"?: IdentityRef;

    /**
     * Gets or sets the time when config was created.
     */
    "createdOn"?: Date;

    /**
     * Gets or sets the type of the endpoint.
     */
    "endpointType"?: string;

    /**
     * Gets or sets the unique identifier of this field
     */
    "id"?: string;

    /**
     * Gets or sets the identity who modified the config.
     */
    "modifiedBy"?: IdentityRef;

    /**
     * Gets or sets the time when variable group was modified
     */
    "modifiedOn"?: Date;

    /**
     * Gets or sets the name
     */
    "name"?: string;

    /**
     * Gets or sets the Url
     */
    "url"?: string;
}

/**
 * 
 */
export interface OAuthConfigurationParams {

    /**
     * Gets or sets the ClientId
     */
    "clientId"?: string;

    /**
     * Gets or sets the ClientSecret
     */
    "clientSecret"?: string;

    /**
     * Gets or sets the type of the endpoint.
     */
    "endpointType"?: string;

    /**
     * Gets or sets the name
     */
    "name"?: string;

    /**
     * Gets or sets the Url
     */
    "url"?: string;
}

/**
 * 
 */
export interface OAuthEndpointStatus {
    "state"?: string;
    "statusMessage"?: string;
}

/**
 * Contains information about the progress or result of an async operation.
 */
export interface Operation extends OperationReference {
}

/**
 * Reference for an async operation.
 */
export interface OperationReference {

    /**
     * Unique identifier for the operation.
     */
    "id"?: string;

    /**
     * Unique identifier for the plugin.
     */
    "pluginId"?: string;

    /**
     * URL to get the full operation object.
     */
    "url"?: string;
}

/**
 * 
 */
export interface OperationResult {

    /**
     * List of error codes paired with their corresponding error messages.
     */
    "errors"?: Array<{ [key: string]: string; }>;

    /**
     * Success status of the operation.
     */
    "isSuccess"?: boolean;

    /**
     * Identifier of the Member being acted upon.
     */
    "memberId"?: string;

    /**
     * Result of the MemberEntitlement after the operation.
     */
    "result"?: MemberEntitlement;
}

/**
 * 
 */
export interface OperationResultReference {

    /**
     * URL to the operation result.
     */
    "resultUrl"?: string;
}

/**
 * Encapsulates the properties of an operator constraint. An operator constraint defines if some operator is available only for specific scope like a project scope.
 */
export interface OperatorConstraint {
    "operator"?: string;

    /**
     * Gets or sets the list of scopes that this type supports.
     */
    "supportedScopes"?: Array<string>;
}

/**
 * 
 */
export interface OverridableRunSettings {
    "staticAgentRunSettings"?: StaticAgentRunSetting;
}

/**
 * A single change to a feed's packages.
 */
export interface PackageChange {

    /**
     * Package that was changed.
     */
    "package"?: ModelPackage;

    /**
     * Change that was performed on a package version.
     */
    "packageVersionChange"?: PackageVersionChange;
}

/**
 * A set of change operations to a feed's packages.
 */
export interface PackageChangesResponse {

    /**
     * Related REST links.
     */
    "links"?: ReferenceLinks;

    /**
     * Number of changes in this batch.
     */
    "count"?: number;

    /**
     * Token that should be used in future calls for this feed to retrieve new changes.
     */
    "nextPackageContinuationToken"?: number;

    /**
     * List of changes.
     */
    "packageChanges"?: Array<PackageChange>;
}

/**
 * A dependency on another package version.
 */
export interface PackageDependency {

    /**
     * Dependency package group (an optional classification within some package types).
     */
    "group"?: string;

    /**
     * Dependency package name.
     */
    "packageName"?: string;

    /**
     * Dependency package version range.
     */
    "versionRange"?: string;
}

/**
 * A package file for a specific package version, only relevant to package types that contain multiple files per version.
 */
export interface PackageFile {

    /**
     * Hierarchical representation of files.
     */
    "children"?: Array<PackageFile>;

    /**
     * File name.
     */
    "name"?: string;

    /**
     * Extended data unique to a specific package type.
     */
    "protocolMetadata"?: ProtocolMetadata;
}

/**
 * Represents a downloadable package.
 */
export interface PackageMetadata {

    /**
     * The date the package was created
     */
    "createdOn"?: Date;

    /**
     * A direct link to download the package.
     */
    "downloadUrl"?: string;

    /**
     * The UI uses this to display instructions, i.e. "unzip MyAgent.zip"
     */
    "filename"?: string;

    /**
     * MD5 hash as a base64 string
     */
    "hashValue"?: string;

    /**
     * A link to documentation
     */
    "infoUrl"?: string;

    /**
     * The platform (win7, linux, etc.)
     */
    "platform"?: string;

    /**
     * The type of package (e.g. "agent")
     */
    "type"?: string;

    /**
     * The package version.
     */
    "version"?: PackageVersion;
}

/**
 * All metrics for a certain package id
 */
export interface PackageMetrics {

    /**
     * Total count of downloads per package id.
     */
    "downloadCount"?: number;

    /**
     * Number of downloads per unique user per package id.
     */
    "downloadUniqueUsers"?: number;

    /**
     * UTC date and time when package was last downloaded.
     */
    "lastDownloaded"?: Date;

    /**
     * Package id.
     */
    "packageId"?: string;
}

/**
 * Query to get package metrics
 */
export interface PackageMetricsQuery {

    /**
     * List of package ids
     */
    "packageIds"?: Array<string>;
}

/**
 * 
 */
export interface PackageTrigger extends ReleaseTriggerBase {
}

/**
 * 
 */
export interface PackageVersion extends MinimalPackageVersion {
}

/**
 * A change to a single package version.
 */
export interface PackageVersionChange {

    /**
     * Token marker for this change, allowing the caller to send this value back to the service and receive changes beyond this one.
     */
    "continuationToken"?: number;

    /**
     * Package version that was changed.
     */
    "packageVersion"?: PackageVersion;
}

/**
 * 
 */
export interface PackageVersionDetails {

    /**
     * Indicates the deprecate message of a package version
     */
    "deprecateMessage"?: string;

    /**
     * The view to which the package version will be added
     */
    "views"?: JsonPatchOperation;

    /**
     * Indicates the listing state of a package
     */
    "listed"?: boolean;
}

/**
 * All metrics for a certain package version id
 */
export interface PackageVersionMetrics {

    /**
     * Total count of downloads per package version id.
     */
    "downloadCount"?: number;

    /**
     * Number of downloads per unique user per package version id.
     */
    "downloadUniqueUsers"?: number;

    /**
     * UTC date and time when package version was last downloaded.
     */
    "lastDownloaded"?: Date;

    /**
     * Package id.
     */
    "packageId"?: string;

    /**
     * Package version id.
     */
    "packageVersionId"?: string;
}

/**
 * Query to get package version metrics
 */
export interface PackageVersionMetricsQuery {

    /**
     * List of package version ids
     */
    "packageVersionIds"?: Array<string>;
}

/**
 * Provenance for a published package version
 */
export interface PackageVersionProvenance {

    /**
     * Name or Id of the feed.
     */
    "feedId"?: string;

    /**
     * Id of the package (GUID Id, not name).
     */
    "packageId"?: string;

    /**
     * Id of the package version (GUID Id, not name).
     */
    "packageVersionId"?: string;

    /**
     * Provenance information for this package version.
     */
    "provenance"?: Provenance;
}

/**
 * 
 */
export interface Page {

    /**
     * Contribution for the page.
     */
    "contribution"?: WitContribution;

    /**
     * The id for the layout node.
     */
    "id"?: string;

    /**
     * A value indicating whether this layout node has been inherited from a parent layout.  This is expected to only be only set by the combiner.
     */
    "inherited"?: boolean;

    /**
     * A value indicating if the layout node is contribution are not.
     */
    "isContribution"?: boolean;

    /**
     * The label for the page.
     */
    "label"?: string;

    /**
     * A value indicating whether any user operations are permitted on this page and the contents of this page
     */
    "locked"?: boolean;

    /**
     * Order in which the page should appear in the layout.
     */
    "order"?: number;

    /**
     * A value indicating whether this layout node has been overridden by a child layout.
     */
    "overridden"?: boolean;

    /**
     * The sections of the page.
     */
    "sections"?: Array<Section>;

    /**
     * A value indicating if the page should be hidden or not.
     */
    "visible"?: boolean;
}

/**
 * 
 */
export interface PageSummary {
    "averagePageTime"?: number;
    "pageUrl"?: string;
    "percentagePagesMeetingGoal"?: number;
    "percentileData"?: Array<SummaryPercentileData>;
    "scenarioName"?: string;
    "testName"?: string;
    "totalPages"?: number;
}

/**
 * 
 */
export interface PagedGraphGroups {

    /**
     * This will be non-null if there is another page of data. There will never be more than one continuation token returned by a request.
     */
    "continuationToken"?: Array<string>;

    /**
     * The enumerable list of groups found within a page.
     */
    "graphGroups"?: Array<GraphGroup>;
}

/**
 * A page of users
 */
export interface PagedGraphMemberList extends PagedList {
}

/**
 * 
 */
export interface PagedGraphUsers {

    /**
     * This will be non-null if there is another page of data. There will never be more than one continuation token returned by a request.
     */
    "continuationToken"?: Array<string>;

    /**
     * The enumerable set of users found within a page.
     */
    "graphUsers"?: Array<GraphUser>;
}

/**
 * 
 */
export interface PagedList {
    "continuationToken"?: string;
    "items"?: Array<string>;
    "totalCount"?: number;
}

/**
 * 
 */
export interface ParallelExecutionInputBase extends ExecutionInput {
}

/**
 * 
 */
export interface ParentChildWIMap {
    "childWorkItemIds"?: Array<number>;
    "id"?: number;
    "title"?: string;
}

/**
 * Represents an evaluated permission.
 */
export interface PermissionEvaluation {

    /**
     * Permission bit for this evaluated permission.
     */
    "permissions"?: number;

    /**
     * Security namespace identifier for this evaluated permission.
     */
    "securityNamespaceId"?: string;

    /**
     * Security namespace-specific token for this evaluated permission.
     */
    "token"?: string;

    /**
     * Permission evaluation value.
     */
    "value"?: boolean;
}

/**
 * Represents a set of evaluated permissions.
 */
export interface PermissionEvaluationBatch {

    /**
     * True if members of the Administrators group should always pass the security check.
     */
    "alwaysAllowAdministrators"?: boolean;

    /**
     * Array of permission evaluations to evaluate.
     */
    "evaluations"?: Array<PermissionEvaluation>;
}

/**
 * Represents a phase of a build definition.
 */
export interface Phase {

    /**
     * The condition that must be true for this phase to execute.
     */
    "condition"?: string;
    "dependencies"?: Array<Dependency>;

    /**
     * The cancellation timeout, in minutes, for builds queued against this definition.
     */
    "jobCancelTimeoutInMinutes"?: number;

    /**
     * The job execution timeout, in minutes, for builds queued against this definition.
     */
    "jobTimeoutInMinutes"?: number;

    /**
     * The name of the phase.
     */
    "name"?: string;

    /**
     * The unique ref name of the phase.
     */
    "refName"?: string;
    "steps"?: Array<BuildDefinitionStep>;

    /**
     * The target (agent, server, etc.) for this phase.
     */
    "target"?: PhaseTarget;
    "variables"?: { [key: string]: BuildDefinitionVariable; };
}

/**
 * Represents the target of a phase.
 */
export interface PhaseTarget {

    /**
     * The type of the target.
     */
    "type"?: number;
}

/**
 * Picklist.
 */
export interface PickList extends PickListMetadata {
}

/**
 * 
 */
export interface PickListItemModel {
    "id"?: string;
    "value"?: string;
}

/**
 * Metadata for picklist.
 */
export interface PickListMetadata {

    /**
     * ID of the picklist
     */
    "id"?: string;

    /**
     * Indicates whether items outside of suggested list are allowed
     */
    "isSuggested"?: boolean;

    /**
     * Name of the picklist
     */
    "name"?: string;

    /**
     * DataType of picklist
     */
    "type"?: string;

    /**
     * Url of the picklist
     */
    "url"?: string;
}

/**
 * 
 */
export interface PickListMetadataModel {

    /**
     * ID of the picklist
     */
    "id"?: string;

    /**
     * Is input values by user only limited to suggested values
     */
    "isSuggested"?: boolean;

    /**
     * Name of the picklist
     */
    "name"?: string;

    /**
     * Type of picklist
     */
    "type"?: string;

    /**
     * Url of the picklist
     */
    "url"?: string;
}

/**
 * 
 */
export interface PickListModel extends PickListMetadataModel {
}

/**
 * 
 */
export interface PipelineProcess {
}

/**
 * Data contract for the plan definition
 */
export interface Plan {

    /**
     * Identity that created this plan. Defaults to null for records before upgrading to ScaledAgileViewComponent4.
     */
    "createdByIdentity"?: IdentityRef;

    /**
     * Date when the plan was created
     */
    "createdDate"?: Date;

    /**
     * Description of the plan
     */
    "description"?: string;

    /**
     * Id of the plan
     */
    "id"?: string;

    /**
     * Identity that last modified this plan. Defaults to null for records before upgrading to ScaledAgileViewComponent4.
     */
    "modifiedByIdentity"?: IdentityRef;

    /**
     * Date when the plan was last modified. Default to CreatedDate when the plan is first created.
     */
    "modifiedDate"?: Date;

    /**
     * Name of the plan
     */
    "name"?: string;

    /**
     * The PlanPropertyCollection instance associated with the plan. These are dependent on the type of the plan. For example, DeliveryTimelineView, it would be of type DeliveryViewPropertyCollection.
     */
    "properties"?: any;

    /**
     * Revision of the plan. Used to safeguard users from overwriting each other's changes.
     */
    "revision"?: number;

    /**
     * The resource url to locate the plan via rest api
     */
    "url"?: string;
}

/**
 * 
 */
export interface PlanEnvironment {
    "mask"?: Array<MaskHint>;
    "options"?: { [key: string]: JobOption; };
    "variables"?: { [key: string]: string; };
}

/**
 * Metadata about a plan definition that is stored in favorites service
 */
export interface PlanMetadata {

    /**
     * Identity of the creator of the plan
     */
    "createdByIdentity"?: IdentityRef;

    /**
     * Description of plan
     */
    "description"?: string;

    /**
     * Last modified date of the plan
     */
    "modifiedDate"?: Date;
}

/**
 * A model class used for creating and updating test plans.
 */
export interface PlanUpdateModel {

    /**
     * Area path to which the test plan belongs. This should be set to area path of the team that works on this test plan.
     */
    "area"?: ShallowReference;

    /**
     * Build ID of the build whose quality is tested by the tests in this test plan. For automated testing, this build ID is used to find the test binaries that contain automated test methods.
     */
    "build"?: ShallowReference;

    /**
     * The Build Definition that generates a build associated with this test plan.
     */
    "buildDefinition"?: ShallowReference;

    /**
     * IDs of configurations to be applied when new test suites and test cases are added to the test plan.
     */
    "configurationIds"?: Array<number>;

    /**
     * Description of the test plan.
     */
    "description"?: string;

    /**
     * End date for the test plan.
     */
    "endDate"?: string;

    /**
     * Iteration path assigned to the test plan. This indicates when the target iteration by which the testing in this plan is supposed to be complete and the product is ready to be released.
     */
    "iteration"?: string;

    /**
     * Name of the test plan.
     */
    "name"?: string;

    /**
     * Owner of the test plan.
     */
    "owner"?: IdentityRef;

    /**
     * Release Environment to be used to deploy the build and run automated tests from this test plan.
     */
    "releaseEnvironmentDefinition"?: ReleaseEnvironmentDefinitionReference;

    /**
     * Start date for the test plan.
     */
    "startDate"?: string;

    /**
     * State of the test plan.
     */
    "state"?: string;

    /**
     * Test Outcome settings
     */
    "testOutcomeSettings"?: TestOutcomeSettings;
}

/**
 * Base class for plan view data contracts. Anything common goes here.
 */
export interface PlanViewData {
    "id"?: string;
    "revision"?: number;
}

/**
 * 
 */
export interface Plugin extends MavenPomGav {
}

/**
 * 
 */
export interface PluginConfiguration {
    "goalPrefix"?: string;
}

/**
 * Assignments for the Test Point
 */
export interface PointAssignment extends Configuration {
}

/**
 * 
 */
export interface PointLastResult {
    "lastUpdatedDate"?: Date;
    "pointId"?: number;
}

/**
 * Model to update test point.
 */
export interface PointUpdateModel {

    /**
     * Outcome to update.
     */
    "outcome"?: string;

    /**
     * Reset test point to active.
     */
    "resetToActive"?: boolean;

    /**
     * Tester to update. Type IdentityRef.
     */
    "tester"?: IdentityRef;
}

/**
 * Test point workitem property.
 */
export interface PointWorkItemProperty {

    /**
     * key value pair of test point work item property.
     */
    "workItem"?: { [key: string]: any; };
}

/**
 * Filter class for test point.
 */
export interface PointsFilter {

    /**
     * List of Configurations for filtering.
     */
    "configurationNames"?: Array<string>;

    /**
     * List of test case id for filtering.
     */
    "testcaseIds"?: Array<number>;

    /**
     * List of tester for filtering.
     */
    "testers"?: Array<IdentityRef>;
}

/**
 * 
 */
export interface PointsResults2 {
    "changeNumber"?: number;
    "lastFailureType"?: string;
    "lastResolutionStateId"?: number;
    "lastResultOutcome"?: string;
    "lastResultState"?: string;
    "lastTestResultId"?: number;
    "lastTestRunId"?: number;
    "lastUpdated"?: Date;
    "planId"?: number;
    "pointId"?: number;
}

/**
 * The full policy configuration with settings.
 */
export interface PolicyConfiguration extends VersionedPolicyConfigurationRef {
}

/**
 * Policy configuration reference.
 */
export interface PolicyConfigurationRef {

    /**
     * The policy configuration ID.
     */
    "id"?: number;

    /**
     * The policy configuration type.
     */
    "type"?: PolicyTypeRef;

    /**
     * The URL where the policy configuration can be retrieved.
     */
    "url"?: string;
}

/**
 * This record encapsulates the current state of a policy as it applies to one specific pull request. Each pull request has a unique PolicyEvaluationRecord for each pull request which the policy applies to.
 */
export interface PolicyEvaluationRecord {

    /**
     * Links to other related objects
     */
    "links"?: ReferenceLinks;

    /**
     * A string which uniquely identifies the target of a policy evaluation.
     */
    "artifactId"?: string;

    /**
     * Time when this policy finished evaluating on this pull request.
     */
    "completedDate"?: Date;

    /**
     * Contains all configuration data for the policy which is being evaluated.
     */
    "configuration"?: PolicyConfiguration;

    /**
     * Internal context data of this policy evaluation.
     */
    "context"?: JObject;

    /**
     * Guid which uniquely identifies this evaluation record (one policy running on one pull request).
     */
    "evaluationId"?: string;

    /**
     * Time when this policy was first evaluated on this pull request.
     */
    "startedDate"?: Date;
}

/**
 * Real time event (SignalR) for a policy evaluation update on a pull request
 */
export interface PolicyEvaluationUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * User-friendly policy type with description (used for querying policy types).
 */
export interface PolicyType extends PolicyTypeRef {
}

/**
 * Policy type reference.
 */
export interface PolicyTypeRef {

    /**
     * Display name of the policy type.
     */
    "displayName"?: string;

    /**
     * The policy type ID.
     */
    "id"?: string;

    /**
     * The URL where the policy type can be retrieved.
     */
    "url"?: string;
}

/**
 * Represents a single pre-defined query.
 */
export interface PredefinedQuery {

    /**
     * Whether or not the query returned the complete set of data or if the data was truncated.
     */
    "hasMore"?: boolean;

    /**
     * Id of the query
     */
    "id"?: string;

    /**
     * Localized name of the query
     */
    "name"?: string;

    /**
     * The results of the query.  This will be a set of WorkItem objects with only the 'id' set.  The client is responsible for paging in the data as needed.
     */
    "results"?: Array<WorkItem>;

    /**
     * REST API Url to use to retrieve results for this query
     */
    "url"?: string;

    /**
     * Url to use to display a page in the browser with the results of this query
     */
    "webUrl"?: string;
}

/**
 * 
 */
export interface Process extends ProcessReference {
}

/**
 * Process Behavior Model.
 */
export interface ProcessBehavior {

    /**
     * Color.
     */
    "color"?: string;

    /**
     * . Description
     */
    "description"?: string;

    /**
     * Process Behavior Fields.
     */
    "fields"?: Array<ProcessBehaviorField>;

    /**
     * Parent behavior reference.
     */
    "inherits"?: ProcessBehaviorReference;

    /**
     * Behavior Name.
     */
    "name"?: string;

    /**
     * Rank of the behavior
     */
    "rank"?: number;

    /**
     * Behavior Id
     */
    "referenceName"?: string;

    /**
     * Url of the behavior.
     */
    "url"?: string;
}

/**
 * Process Behavior Create Payload.
 */
export interface ProcessBehaviorCreateRequest {

    /**
     * Color.
     */
    "color"?: string;

    /**
     * Parent behavior id.
     */
    "inherits"?: string;

    /**
     * Name of the behavior.
     */
    "name"?: string;

    /**
     * ReferenceName is optional, if not specified will be auto-generated.
     */
    "referenceName"?: string;
}

/**
 * Process Behavior Field.
 */
export interface ProcessBehaviorField {

    /**
     * Name of the field.
     */
    "name"?: string;

    /**
     * Reference name of the field.
     */
    "referenceName"?: string;

    /**
     * Url to field.
     */
    "url"?: string;
}

/**
 * Process behavior Reference.
 */
export interface ProcessBehaviorReference {

    /**
     * Id of a Behavior.
     */
    "behaviorRefName"?: string;

    /**
     * Url to behavior.
     */
    "url"?: string;
}

/**
 * Process Behavior Replace Payload.
 */
export interface ProcessBehaviorUpdateRequest {

    /**
     * Color.
     */
    "color"?: string;

    /**
     * Behavior Name.
     */
    "name"?: string;
}

/**
 * Process Configurations for the project
 */
export interface ProcessConfiguration {

    /**
     * Details about bug work items
     */
    "bugWorkItems"?: CategoryConfiguration;

    /**
     * Details about portfolio backlogs
     */
    "portfolioBacklogs"?: Array<CategoryConfiguration>;

    /**
     * Details of requirement backlog
     */
    "requirementBacklog"?: CategoryConfiguration;

    /**
     * Details of task backlog
     */
    "taskBacklog"?: CategoryConfiguration;

    /**
     * Type fields for the process configuration
     */
    "typeFields"?: { [key: string]: WorkItemFieldReference; };
    "url"?: string;
}

/**
 * Describes the result of a Process Import request.
 */
export interface ProcessImportResult {

    /**
     * Help URL.
     */
    "helpUrl"?: string;

    /**
     * ID of the import operation.
     */
    "id"?: string;

    /**
     * Whether this imported process is new.
     */
    "isNew"?: boolean;

    /**
     * The promote job identifier.
     */
    "promoteJobId"?: string;

    /**
     * The list of validation results.
     */
    "validationResults"?: Array<ValidationIssue>;
}

/**
 * Process.
 */
export interface ProcessInfo {

    /**
     * Description of the process.
     */
    "description"?: string;

    /**
     * Is the process default.
     */
    "isDefault"?: boolean;

    /**
     * Is the process enabled.
     */
    "isEnabled"?: boolean;

    /**
     * Name of the process.
     */
    "name"?: string;

    /**
     * ID of the parent process.
     */
    "parentProcessTypeId"?: string;

    /**
     * Projects in this process to which the user is subscribed to.
     */
    "projects"?: Array<ProjectReference>;

    /**
     * Reference name of the process.
     */
    "referenceName"?: string;

    /**
     * The ID of the process.
     */
    "typeId"?: string;
}

/**
 * 
 */
export interface ProcessModel {

    /**
     * Description of the process
     */
    "description"?: string;

    /**
     * Name of the process
     */
    "name"?: string;

    /**
     * Projects in this process
     */
    "projects"?: Array<ProjectReference>;

    /**
     * Properties of the process
     */
    "properties"?: ProcessProperties;

    /**
     * Reference name of the process
     */
    "referenceName"?: string;

    /**
     * The ID of the process
     */
    "typeId"?: string;
}

/**
 * 
 */
export interface ProcessParameters {
    "dataSourceBindings"?: Array<DataSourceBindingBase>;
    "inputs"?: Array<TaskInputDefinitionBase>;
    "sourceDefinitions"?: Array<TaskSourceDefinitionBase>;
}

/**
 * Describes result of process operation promote.
 */
export interface ProcessPromoteStatus {

    /**
     * Number of projects for which promote is complete.
     */
    "complete"?: number;

    /**
     * ID of the promote operation.
     */
    "id"?: string;

    /**
     * The error message assoicated with the promote operation. The string will be empty if there are no errors.
     */
    "message"?: string;

    /**
     * Number of projects for which promote is pending.
     */
    "pending"?: number;

    /**
     * The remaining retries.
     */
    "remainingRetries"?: number;

    /**
     * True if promote finished all the projects successfully. False if still inprogress or any project promote failed.
     */
    "successful"?: boolean;
}

/**
 * Properties of the process.
 */
export interface ProcessProperties {

    /**
     * Is the process default process.
     */
    "isDefault"?: boolean;

    /**
     * Is the process enabled.
     */
    "isEnabled"?: boolean;

    /**
     * ID of the parent process.
     */
    "parentProcessTypeId"?: string;

    /**
     * Version of the process.
     */
    "version"?: string;
}

/**
 * 
 */
export interface ProcessReference {
    "name"?: string;
    "url"?: string;
}

/**
 * Process Rule Response.
 */
export interface ProcessRule extends CreateProcessRuleRequest {
}

/**
 * Class that describes a work item type object
 */
export interface ProcessWorkItemType {
    "behaviors"?: Array<WorkItemTypeBehavior>;

    /**
     * Color hexadecimal code to represent the work item type
     */
    "color"?: string;

    /**
     * Description of the work item type
     */
    "description"?: string;

    /**
     * Icon to represent the work item typ
     */
    "icon"?: string;

    /**
     * Reference name of the parent work item type
     */
    "inherits"?: string;

    /**
     * Indicates if a work item type is disabled
     */
    "isDisabled"?: boolean;
    "layout"?: FormLayout;

    /**
     * Name of the work item type
     */
    "name"?: string;

    /**
     * Reference name of work item type
     */
    "referenceName"?: string;
    "states"?: Array<WorkItemStateResultModel>;

    /**
     * Url of the work item type
     */
    "url"?: string;
}

/**
 * Class that describes a field in a work item type and its properties.
 */
export interface ProcessWorkItemTypeField {

    /**
     * Allow setting field value to a group identity. Only applies to identity fields.
     */
    "allowGroups"?: boolean;

    /**
     * The default value of the field.
     */
    "defaultValue"?: any;

    /**
     * Description of the field.
     */
    "description"?: string;

    /**
     * Name of the field.
     */
    "name"?: string;

    /**
     * If true the field cannot be edited.
     */
    "readOnly"?: boolean;

    /**
     * Reference name of the field.
     */
    "referenceName"?: string;

    /**
     * If true the field cannot be empty.
     */
    "required"?: boolean;

    /**
     * Resource URL of the field.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ProcessedEvent {

    /**
     * All of the users that were associtated with this event and their role.
     */
    "actors"?: Array<EventActor>;
    "allowedChannels"?: string;
    "artifactUri"?: string;
    "deliveryIdentities"?: ProcessingIdentities;

    /**
     * Evaluations for each user
     */
    "evaluations"?: { [key: string]: SubscriptionEvaluation; };
    "eventId"?: number;

    /**
     * Which members were excluded from evaluation (only applies to ActorMatcher subscriptions)
     */
    "exclusions"?: Array<EventActor>;

    /**
     * Which members were included for evaluation (only applies to ActorMatcher subscriptions)
     */
    "inclusions"?: Array<EventActor>;
    "notifications"?: Array<GeneratedNotification>;
}

/**
 * 
 */
export interface ProcessingDiagnosticIdentity extends DiagnosticIdentity {
}

/**
 * 
 */
export interface ProcessingIdentities {
    "excludedIdentities"?: { [key: string]: ProcessingDiagnosticIdentity; };
    "includedIdentities"?: { [key: string]: ProcessingDiagnosticIdentity; };
    "messages"?: Array<NotificationDiagnosticLogMessage>;
    "missingIdentities"?: Array<string>;
    "properties"?: { [key: string]: string; };
}

/**
 * A user profile.
 */
export interface Profile {

    /**
     * The attributes of this profile.
     */
    "applicationContainer"?: AttributesContainer;

    /**
     * The core attributes of this profile.
     */
    "coreAttributes"?: { [key: string]: CoreProfileAttribute; };

    /**
     * The maximum revision number of any attribute.
     */
    "coreRevision"?: number;

    /**
     * The unique identifier of the profile.
     */
    "id"?: string;

    /**
     * The maximum revision number of any attribute.
     */
    "revision"?: number;

    /**
     * The time at which this profile was last changed.
     */
    "timeStamp"?: Date;
}

/**
 * A named object associated with a profile.
 */
export interface ProfileAttribute extends ProfileAttributeBase {
}

/**
 * 
 */
export interface ProfileAttributeBase {

    /**
     * The descriptor of the attribute.
     */
    "descriptor"?: AttributeDescriptor;

    /**
     * The revision number of the attribute.
     */
    "revision"?: number;

    /**
     * The time the attribute was last changed.
     */
    "timeStamp"?: Date;

    /**
     * The value of the attribute.
     */
    "value"?: string;
}

/**
 * Country/region information
 */
export interface ProfileRegion {

    /**
     * The two-letter code defined in ISO 3166 for the country/region.
     */
    "code"?: string;

    /**
     * Localized country/region name
     */
    "name"?: string;
}

/**
 * Container of country/region information
 */
export interface ProfileRegions {

    /**
     * List of country/region code with contact consent requirement type of notice
     */
    "noticeContactConsentRequirementRegions"?: Array<string>;

    /**
     * List of country/region code with contact consent requirement type of opt-out
     */
    "optOutContactConsentRequirementRegions"?: Array<string>;

    /**
     * List of country/regions
     */
    "regions"?: Array<ProfileRegion>;
}

/**
 * Defines the details of the project.
 */
export interface Project {

    /**
     * Id of the project.
     */
    "id"?: string;

    /**
     * Name of the project.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ProjectAvatar {

    /**
     * The avatar image represented as a byte array
     */
    "image"?: Array<string>;
}

/**
 * Relation between a project and the user's effective permissions in that project.
 */
export interface ProjectEntitlement {

    /**
     * Project Group (e.g. Contributor, Reader etc.)
     */
    "group"?: Group;

    /**
     * Project Ref
     */
    "projectRef"?: ProjectRef;

    /**
     * Team Ref.
     */
    "teamRefs"?: Array<TeamRef>;
}

/**
 * Contains information describing a project.
 */
export interface ProjectInfo {

    /**
     * The abbreviated name of the project.
     */
    "abbreviation"?: string;

    /**
     * The description of the project.
     */
    "description"?: string;

    /**
     * The id of the project.
     */
    "id"?: string;

    /**
     * The time that this project was last updated.
     */
    "lastUpdateTime"?: Date;

    /**
     * The name of the project.
     */
    "name"?: string;

    /**
     * A set of name-value pairs storing additional property data related to the project.
     */
    "properties"?: Array<ProjectProperty>;

    /**
     * The current revision of the project.
     */
    "revision"?: number;

    /**
     * A Uri that can be used to refer to this project.
     */
    "uri"?: string;

    /**
     * The version number of the project.
     */
    "version"?: number;
}

/**
 * 
 */
export interface ProjectMessage {
    "project"?: ProjectInfo;
    "shouldInvalidateSystemStore"?: boolean;
}

/**
 * A named value associated with a project.
 */
export interface ProjectProperty {

    /**
     * The name of the property.
     */
    "name"?: string;

    /**
     * The value of the property.
     */
    "value"?: any;
}

/**
 * A reference to a project
 */
export interface ProjectRef {

    /**
     * Project ID.
     */
    "id"?: string;

    /**
     * Project Name.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ProjectReference {

    /**
     * The ID of the project
     */
    "id"?: string;

    /**
     * Name of the project
     */
    "name"?: string;

    /**
     * Visibility of the project.
     */
    "visibility"?: string;

    /**
     * Description of the project
     */
    "description"?: string;

    /**
     * Url of the project
     */
    "url"?: string;
}

/**
 * Project work item type state colors
 */
export interface ProjectWorkItemStateColors {

    /**
     * Project name
     */
    "projectName"?: string;

    /**
     * State colors for all work item type in a project
     */
    "workItemTypeStateColors"?: Array<WorkItemTypeStateColors>;
}

/**
 * The class represents a property bag as a collection of key-value pairs. Values of all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted. Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are retuned as a String. Byte[] expected as base64 encoded string.
 */
export interface PropertiesCollection {

    /**
     * The count of properties in the collection.
     */
    "count"?: number;
    "item"?: any;

    /**
     * The set of keys in the collection.
     */
    "keys"?: Array<string>;

    /**
     * The set of values in the collection.
     */
    "values"?: Array<string>;
}

/**
 * 
 */
export interface PropertyBag {

    /**
     * Generic store for test session data
     */
    "bag"?: { [key: string]: string; };
}

/**
 * 
 */
export interface PropertySelector {

    /**
     * List of properties.
     */
    "properties"?: Array<string>;
}

/**
 * Extended metadata for a specific package type.
 */
export interface ProtocolMetadata {

    /**
     * Extended metadata for a specific package type, formatted to the associated schema version definition.
     */
    "data"?: any;

    /**
     * Schema version.
     */
    "schemaVersion"?: number;
}

/**
 * Data about the origin of a published package
 */
export interface Provenance {

    /**
     * Other provenance data.
     */
    "data"?: { [key: string]: string; };

    /**
     * Type of provenance source, for example "InternalBuild", "InternalRelease"
     */
    "provenanceSource"?: string;

    /**
     * Identity of user that published the package
     */
    "publisherUserIdentity"?: string;

    /**
     * HTTP User-Agent used when pushing the package.
     */
    "userAgent"?: string;
}

/**
 * Result of an update work item type XML update operation.
 */
export interface ProvisioningResult {

    /**
     * Details about of the provisioning import events.
     */
    "provisioningImportEvents"?: Array<string>;
}

/**
 * 
 */
export interface Proxy {
    "authorization"?: ProxyAuthorization;

    /**
     * This is a description string
     */
    "description"?: string;

    /**
     * The friendly name of the server
     */
    "friendlyName"?: string;
    "globalDefault"?: boolean;

    /**
     * This is a string representation of the site that the proxy server is located in (e.g. "NA-WA-RED")
     */
    "site"?: string;
    "siteDefault"?: boolean;

    /**
     * The URL of the proxy server
     */
    "url"?: string;
}

/**
 * 
 */
export interface ProxyAuthorization {

    /**
     * Gets or sets the endpoint used to obtain access tokens from the configured token service.
     */
    "authorizationUrl"?: string;

    /**
     * Gets or sets the client identifier for this proxy.
     */
    "clientId"?: string;

    /**
     * Gets or sets the user identity to authorize for on-prem.
     */
    "identity"?: IdentityDescriptor;

    /**
     * Gets or sets the public key used to verify the identity of this proxy. Only specify on hosted.
     */
    "publicKey"?: PublicKey;
}

/**
 * Represents the public key portion of an RSA asymmetric key.
 */
export interface PublicKey {

    /**
     * Gets or sets the exponent for the public key.
     */
    "exponent"?: Array<string>;

    /**
     * Gets or sets the modulus for the public key.
     */
    "modulus"?: Array<string>;
}

/**
 * 
 */
export interface PublishTaskGroupMetadata {
    "comment"?: string;
    "parentDefinitionRevision"?: number;
    "preview"?: boolean;
    "taskGroupId"?: string;
    "taskGroupRevision"?: number;
}

/**
 * 
 */
export interface PublishedExtension {
    "categories"?: Array<string>;
    "displayName"?: string;
    "extensionId"?: string;
    "extensionName"?: string;
    "installationTargets"?: Array<InstallationTarget>;
    "lastUpdated"?: Date;
    "longDescription"?: string;

    /**
     * Date on which the extension was first uploaded.
     */
    "publishedDate"?: Date;
    "publisher"?: PublisherFacts;

    /**
     * Date on which the extension first went public.
     */
    "releaseDate"?: Date;
    "sharedWith"?: Array<ExtensionShare>;
    "shortDescription"?: string;
    "statistics"?: Array<ExtensionStatistic>;
    "tags"?: Array<string>;
    "versions"?: Array<ExtensionVersion>;
}

/**
 * Defines the data contract of an event publisher.
 */
export interface Publisher {

    /**
     * Reference Links
     */
    "links"?: ReferenceLinks;

    /**
     * Gets this publisher's localized description.
     */
    "description"?: string;

    /**
     * Gets this publisher's identifier.
     */
    "id"?: string;

    /**
     * Publisher-specific inputs
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets this publisher's localized name.
     */
    "name"?: string;

    /**
     * The service instance type of the first party publisher.
     */
    "serviceInstanceType"?: string;

    /**
     * Gets this publisher's supported event types.
     */
    "supportedEvents"?: Array<EventTypeDescriptor>;

    /**
     * The url for this resource
     */
    "url"?: string;
}

/**
 * Wrapper around an event which is being published
 */
export interface PublisherEvent {

    /**
     * Add key/value pairs which will be stored with a published notification in the SH service DB.  This key/value pairs are for diagnostic purposes only and will have not effect on the delivery of a notificaton.
     */
    "diagnostics"?: { [key: string]: string; };

    /**
     * The event being published
     */
    "event"?: Event;

    /**
     * Gets or sets flag for filtered events
     */
    "isFilteredEvent"?: boolean;

    /**
     * Additional data that needs to be sent as part of notification to complement the Resource data in the Event
     */
    "notificationData"?: { [key: string]: string; };

    /**
     * Gets or sets the array of older supported resource versions.
     */
    "otherResourceVersions"?: Array<VersionedResource>;

    /**
     * Optional publisher-input filters which restricts the set of subscriptions which are triggered by the event
     */
    "publisherInputFilters"?: Array<InputFilter>;

    /**
     * Gets or sets matchd hooks subscription which caused this event.
     */
    "subscription"?: Subscription;
}

/**
 * High-level information about the publisher, like id's and names
 */
export interface PublisherFacts {
    "displayName"?: string;
    "publisherId"?: string;
    "publisherName"?: string;
}

/**
 * Defines a query for service hook publishers.
 */
export interface PublishersQuery {

    /**
     * Optional list of publisher ids to restrict the results to
     */
    "publisherIds"?: Array<string>;

    /**
     * Filter for publisher inputs
     */
    "publisherInputs"?: { [key: string]: string; };

    /**
     * Results from the query
     */
    "results"?: Array<Publisher>;
}

/**
 * Represents a pull request object.  These are retrieved from Source Providers.
 */
export interface PullRequest {

    /**
     * The links to other objects related to this object.
     */
    "links"?: ReferenceLinks;

    /**
     * Author of the pull request.
     */
    "author"?: IdentityRef;

    /**
     * Current state of the pull request, e.g. open, merged, closed, conflicts, etc.
     */
    "currentState"?: string;

    /**
     * Description for the pull request.
     */
    "description"?: string;

    /**
     * Unique identifier for the pull request
     */
    "id"?: string;

    /**
     * The name of the provider this pull request is associated with.
     */
    "providerName"?: string;

    /**
     * Source branch ref of this pull request
     */
    "sourceBranchRef"?: string;

    /**
     * Owner of the source repository of this pull request
     */
    "sourceRepositoryOwner"?: string;

    /**
     * Target branch ref of this pull request
     */
    "targetBranchRef"?: string;

    /**
     * Owner of the target repository of this pull request
     */
    "targetRepositoryOwner"?: string;

    /**
     * Title of the pull request.
     */
    "title"?: string;
}

/**
 * 
 */
export interface PullRequestConfiguration {

    /**
     * Code repository reference.
     */
    "codeRepositoryReference"?: CodeRepositoryReference;

    /**
     * In case of Source based artifacts, Code reference will be present in Artifact details.
     */
    "useArtifactReference"?: boolean;
}

/**
 * Real time event (SignalR) for pull request creation
 */
export interface PullRequestCreatedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface PullRequestFilter {

    /**
     * List of tags.
     */
    "tags"?: Array<string>;

    /**
     * Target branch of pull request.
     */
    "targetBranch"?: string;
}

/**
 * Initial config contract sent to extensions creating tabs on the pull request page
 */
export interface PullRequestTabExtensionConfig {
    "pullRequestId"?: number;
    "repositoryId"?: string;
}

/**
 * 
 */
export interface PullRequestTrigger extends ReleaseTriggerBase {
}

/**
 * Deletion state of a Python package.
 */
export interface PyPiPackageVersionDeletionState {

    /**
     * UTC date the package was deleted.
     */
    "deletedDate"?: Date;

    /**
     * Name of the package.
     */
    "name"?: string;

    /**
     * Version of the package.
     */
    "version"?: string;
}

/**
 * A batch of operations to apply to package versions.
 */
export interface PyPiPackagesBatchRequest {

    /**
     * Data required to perform the operation. This is optional based on the type of the operation. Use BatchPromoteData if performing a promote operation.
     */
    "data"?: BatchOperationData;

    /**
     * The packages onto which the operation will be performed.
     */
    "packages"?: Array<MinimalPackageDetails>;
}

/**
 * 
 */
export interface PyPiRecycleBinPackageVersionDetails {

    /**
     * Setting to false will undo earlier deletion and restore the package to feed.
     */
    "deleted"?: boolean;
}

/**
 * Describes a request to get a list of queries
 */
export interface QueryBatchGetRequest {

    /**
     * The requested query ids
     */
    "ids"?: Array<string>;
}

/**
 * 
 */
export interface QueryByPointRequest {
    "projectName"?: string;
    "testPlanId"?: number;
    "testPointId"?: number;
}

/**
 * 
 */
export interface QueryByRunRequest {
    "includeActionResults"?: boolean;
    "outcome"?: string;
    "owner"?: string;
    "pageSize"?: number;
    "projectName"?: string;
    "state"?: string;
    "testRunId"?: number;
}

/**
 * Represents an item in the work item query hierarchy. This can be either a query or a folder.
 */
export interface QueryHierarchyItem extends WorkItemTrackingResource {
}

/**
 * 
 */
export interface QueryHierarchyItemsResult {

    /**
     * The count of items.
     */
    "count"?: number;

    /**
     * Indicates if the max return limit was hit but there are still more items
     */
    "hasMore"?: boolean;

    /**
     * The list of items
     */
    "value"?: Array<QueryHierarchyItem>;
}

/**
 * 
 */
export interface QueryModel {
    "query"?: string;
}

/**
 * 
 */
export interface QueryTestActionResultRequest {
    "identifier"?: LegacyTestCaseResultIdentifier;
    "projectName"?: string;
}

/**
 * 
 */
export interface QueryTestActionResultResponse {
    "testActionResults"?: Array<TestActionResult>;
    "testAttachments"?: Array<TestResultAttachment>;
    "testResultParameters"?: Array<TestResultParameter>;
}

/**
 * 
 */
export interface QueryTestMessageLogEntryRequest {
    "projectName"?: string;
    "testMessageLogId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface QueryTestRunStatsRequest {
    "teamProjectName"?: string;
    "testRunId"?: number;
}

/**
 * 
 */
export interface QueryTestRuns2Request {
    "includeStatistics"?: boolean;
    "query"?: ResultsStoreQuery;
}

/**
 * 
 */
export interface QueryTestRunsRequest {
    "buildUri"?: string;
    "owner"?: string;
    "planId"?: number;
    "skip"?: number;
    "teamProjectName"?: string;
    "testRunId"?: number;
    "top"?: number;
}

/**
 * 
 */
export interface QueuedReleaseData {

    /**
     * Project ID of the release.
     */
    "projectId"?: string;

    /**
     * Release queue position.
     */
    "queuePosition"?: number;

    /**
     * Queued release ID.
     */
    "releaseId"?: number;
}

/**
 * Base contract for a real time pull request event (SignalR)
 */
export interface RealTimePullRequestEvent {

    /**
     * The id of this event. Can be used to track send/receive state between client and server.
     */
    "eventId"?: string;

    /**
     * The id of the pull request this event was generated for.
     */
    "pullRequestId"?: number;
}

/**
 * 
 */
export interface RealtimeBuildEvent {
    "buildId"?: number;
}

/**
 * 
 */
export interface RealtimeReleaseDefinitionEvent {
    "definitionId"?: number;
    "projectId"?: string;
}

/**
 * 
 */
export interface RealtimeReleaseEvent {
    "environmentId"?: number;
    "projectId"?: string;
    "releaseId"?: number;
}

/**
 * A single package version within the recycle bin.
 */
export interface RecycleBinPackageVersion extends PackageVersion {
}

/**
 * The class to represent a REST reference link.  RFC: http://tools.ietf.org/html/draft-kelly-json-hal-06  The RFC is not fully implemented, additional properties are allowed on the reference link but as of yet we don't have a need for them.
 */
export interface ReferenceLink {
    "href"?: string;
}

/**
 * The class to represent a collection of REST reference links.
 */
export interface ReferenceLinks {

    /**
     * The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
     */
    "links"?: { [key: string]: any; };
}

/**
 * 
 */
export interface Release {

    /**
     * Gets links to access the release.
     */
    "links"?: ReferenceLinks;

    /**
     * Gets or sets the list of artifacts.
     */
    "artifacts"?: Array<Artifact>;

    /**
     * Gets or sets comment.
     */
    "comment"?: string;

    /**
     * Gets or sets the identity who created.
     */
    "createdBy"?: IdentityRef;

    /**
     * Gets date on which it got created.
     */
    "createdOn"?: Date;

    /**
     * Gets revision number of definition snapshot.
     */
    "definitionSnapshotRevision"?: number;

    /**
     * Gets or sets description of release.
     */
    "description"?: string;

    /**
     * Gets list of environments.
     */
    "environments"?: Array<ReleaseEnvironment>;

    /**
     * Gets the unique identifier of this field.
     */
    "id"?: number;

    /**
     * Whether to exclude the release from retention policies.
     */
    "keepForever"?: boolean;

    /**
     * Gets logs container url.
     */
    "logsContainerUrl"?: string;

    /**
     * Gets or sets the identity who modified.
     */
    "modifiedBy"?: IdentityRef;

    /**
     * Gets date on which it got modified.
     */
    "modifiedOn"?: Date;

    /**
     * Gets name.
     */
    "name"?: string;

    /**
     * Gets pool name.
     */
    "poolName"?: string;

    /**
     * Gets or sets project reference.
     */
    "projectReference"?: ProjectReference;
    "properties"?: PropertiesCollection;

    /**
     * Gets releaseDefinitionReference which specifies the reference of the release definition to which this release is associated.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * Gets or sets the release definition revision.
     */
    "releaseDefinitionRevision"?: number;

    /**
     * Gets release name format.
     */
    "releaseNameFormat"?: string;

    /**
     * Gets or sets list of tags.
     */
    "tags"?: Array<string>;
    "triggeringArtifactAlias"?: string;

    /**
     * Gets the list of variable groups.
     */
    "variableGroups"?: Array<VariableGroup>;

    /**
     * Gets or sets the dictionary of variables.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseAbandonedEvent {
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * 
 */
export interface ReleaseApproval {

    /**
     * Gets the identity who approved.
     */
    "approvedBy"?: IdentityRef;

    /**
     * Gets or sets the identity who should approve.
     */
    "approver"?: IdentityRef;

    /**
     * Gets or sets attempt which specifies as which deployment attempt it belongs.
     */
    "attempt"?: number;

    /**
     * Gets or sets comments for approval.
     */
    "comments"?: string;

    /**
     * Gets date on which it got created.
     */
    "createdOn"?: Date;

    /**
     * Gets history which specifies all approvals associated with this approval.
     */
    "history"?: Array<ReleaseApprovalHistory>;

    /**
     * Gets the unique identifier of this field.
     */
    "id"?: number;

    /**
     * Gets or sets as approval is automated or not.
     */
    "isAutomated"?: boolean;

    /**
     * Gets date on which it got modified.
     */
    "modifiedOn"?: Date;

    /**
     * Gets or sets rank which specifies the order of the approval. e.g. Same rank denotes parallel approval.
     */
    "rank"?: number;

    /**
     * Gets releaseReference which specifies the reference of the release to which this approval is associated.
     */
    "release"?: ReleaseShallowReference;

    /**
     * Gets releaseDefinitionReference which specifies the reference of the release definition to which this approval is associated.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * Gets releaseEnvironmentReference which specifies the reference of the release environment to which this approval is associated.
     */
    "releaseEnvironment"?: ReleaseEnvironmentShallowReference;

    /**
     * Gets the revision number.
     */
    "revision"?: number;

    /**
     * Gets url to access the approval.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ReleaseApprovalHistory {

    /**
     * Identity of the approver.
     */
    "approver"?: IdentityRef;

    /**
     * Identity of the object who changed approval.
     */
    "changedBy"?: IdentityRef;

    /**
     * Approval histroy comments.
     */
    "comments"?: string;

    /**
     * Time when this approval created.
     */
    "createdOn"?: Date;

    /**
     * Time when this approval modified.
     */
    "modifiedOn"?: Date;

    /**
     * Approval histroy revision.
     */
    "revision"?: number;
}

/**
 * 
 */
export interface ReleaseApprovalPendingEvent {
    "approval"?: ReleaseApproval;
    "approvalOptions"?: ApprovalOptions;
    "completedApprovals"?: Array<ReleaseApproval>;
    "definitionName"?: string;
    "deployment"?: Deployment;
    "environmentId"?: number;
    "environmentName"?: string;
    "environments"?: Array<ReleaseEnvironment>;
    "isMultipleRankApproval"?: boolean;
    "pendingApprovals"?: Array<ReleaseApproval>;
    "releaseCreator"?: string;
    "releaseName"?: string;
    "title"?: string;
    "webAccessUri"?: string;
}

/**
 * 
 */
export interface ReleaseArtifact {

    /**
     * Gets or sets the artifact provider of ReleaseArtifact.
     */
    "artifactProvider"?: ArtifactProvider;

    /**
     * Gets or sets the artifact type of ReleaseArtifact.
     */
    "artifactType"?: string;

    /**
     * Gets or sets the definition json of ReleaseArtifact.
     */
    "definitionData"?: string;

    /**
     * Gets or sets the definition id of ReleaseArtifact.
     */
    "definitionId"?: number;

    /**
     * Gets or sets the description of ReleaseArtifact.
     */
    "description"?: string;

    /**
     * Gets or sets the id of ReleaseArtifact.
     */
    "id"?: number;

    /**
     * Gets or sets the name of ReleaseArtifact.
     */
    "name"?: string;

    /**
     * Gets or sets the release id.
     */
    "releaseId"?: number;
}

/**
 * 
 */
export interface ReleaseCondition extends Condition {
}

/**
 * 
 */
export interface ReleaseCreatedEvent {
    "project"?: ProjectReference;
    "release"?: Release;
}

/**
 * 
 */
export interface ReleaseDefinition extends ReleaseDefinitionShallowReference {
}

/**
 * 
 */
export interface ReleaseDefinitionApprovalStep extends ReleaseDefinitionEnvironmentStep {
}

/**
 * 
 */
export interface ReleaseDefinitionApprovals {

    /**
     * Gets or sets the approval options.
     */
    "approvalOptions"?: ApprovalOptions;

    /**
     * Gets or sets the approvals.
     */
    "approvals"?: Array<ReleaseDefinitionApprovalStep>;
}

/**
 * 
 */
export interface ReleaseDefinitionDeployStep extends ReleaseDefinitionEnvironmentStep {
}

/**
 * 
 */
export interface ReleaseDefinitionEnvironment {

    /**
     * Gets or sets the BadgeUrl. BadgeUrl will be used when Badge will be enabled in Release Definition Environment.
     */
    "badgeUrl"?: string;

    /**
     * Gets or sets the environment conditions.
     */
    "conditions"?: Array<Condition>;

    /**
     * Gets or sets the current release reference.
     */
    "currentRelease"?: ReleaseShallowReference;

    /**
     * Gets or sets the demands.
     */
    "demands"?: Array<Demand>;

    /**
     * Gets or sets the deploy phases of environment.
     */
    "deployPhases"?: Array<DeployPhase>;

    /**
     * Gets or sets the deploystep.
     */
    "deployStep"?: ReleaseDefinitionDeployStep;

    /**
     * Gets or sets the environment options.
     */
    "environmentOptions"?: EnvironmentOptions;

    /**
     * Gets or sets the triggers on environment.
     */
    "environmentTriggers"?: Array<EnvironmentTrigger>;

    /**
     * Gets or sets the environment execution policy.
     */
    "executionPolicy"?: EnvironmentExecutionPolicy;

    /**
     * Gets and sets the ID of the ReleaseDefinitionEnvironment.
     */
    "id"?: number;

    /**
     * Gets and sets the name of the ReleaseDefinitionEnvironment.
     */
    "name"?: string;

    /**
     * Gets and sets the Owner of the ReleaseDefinitionEnvironment.
     */
    "owner"?: IdentityRef;

    /**
     * Gets or sets the post deployment approvals.
     */
    "postDeployApprovals"?: ReleaseDefinitionApprovals;

    /**
     * Gets or sets the post deployment gates.
     */
    "postDeploymentGates"?: ReleaseDefinitionGatesStep;

    /**
     * Gets or sets the pre deployment approvals.
     */
    "preDeployApprovals"?: ReleaseDefinitionApprovals;

    /**
     * Gets or sets the pre deployment gates.
     */
    "preDeploymentGates"?: ReleaseDefinitionGatesStep;

    /**
     * Gets or sets the environment process parameters.
     */
    "processParameters"?: ProcessParameters;

    /**
     * Gets or sets the properties on environment.
     */
    "properties"?: PropertiesCollection;

    /**
     * Gets or sets the queue ID.
     */
    "queueId"?: number;

    /**
     * Gets and sets the rank of the ReleaseDefinitionEnvironment.
     */
    "rank"?: number;

    /**
     * Gets or sets the environment retention policy.
     */
    "retentionPolicy"?: EnvironmentRetentionPolicy;

    /**
     * Gets or sets the schedules
     */
    "schedules"?: Array<ReleaseSchedule>;

    /**
     * Gets or sets the variable groups.
     */
    "variableGroups"?: Array<number>;

    /**
     * Gets and sets the variables.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseDefinitionEnvironmentStep {

    /**
     * ID of the approval or deploy step.
     */
    "id"?: number;
}

/**
 * 
 */
export interface ReleaseDefinitionEnvironmentSummary {

    /**
     * ID of ReleaseDefinition environment summary.
     */
    "id"?: number;

    /**
     * List of release shallow reference deployed using this ReleaseDefinition.
     */
    "lastReleases"?: Array<ReleaseShallowReference>;

    /**
     * Name of ReleaseDefinition environment summary.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ReleaseDefinitionEnvironmentTemplate {

    /**
     * Indicates whether template can be deleted or not.
     */
    "canDelete"?: boolean;

    /**
     * Category of the ReleaseDefinition environment template.
     */
    "category"?: string;

    /**
     * Description of the ReleaseDefinition environment template.
     */
    "description"?: string;

    /**
     * ReleaseDefinition environment data which used to create this template.
     */
    "environment"?: ReleaseDefinitionEnvironment;

    /**
     * ID of the task which used to display icon used for this template.
     */
    "iconTaskId"?: string;

    /**
     * Icon uri of the template.
     */
    "iconUri"?: string;

    /**
     * ID of the ReleaseDefinition environment template.
     */
    "id"?: string;

    /**
     * Indicates whether template deleted or not.
     */
    "isDeleted"?: boolean;

    /**
     * Name of the ReleaseDefinition environment template.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ReleaseDefinitionGate {

    /**
     * Gets or sets the gates workflow.
     */
    "tasks"?: Array<WorkflowTask>;
}

/**
 * 
 */
export interface ReleaseDefinitionGatesOptions {

    /**
     * Gets or sets as the gates enabled or not.
     */
    "isEnabled"?: boolean;

    /**
     * Gets or sets the minimum duration for steady results after a successful gates evaluation.
     */
    "minimumSuccessDuration"?: number;

    /**
     * Gets or sets the time between re-evaluation of gates.
     */
    "samplingInterval"?: number;

    /**
     * Gets or sets the delay before evaluation.
     */
    "stabilizationTime"?: number;

    /**
     * Gets or sets the timeout after which gates fail.
     */
    "timeout"?: number;
}

/**
 * 
 */
export interface ReleaseDefinitionGatesStep {

    /**
     * Gets or sets the gates.
     */
    "gates"?: Array<ReleaseDefinitionGate>;

    /**
     * Gets or sets the gate options.
     */
    "gatesOptions"?: ReleaseDefinitionGatesOptions;

    /**
     * ID of the ReleaseDefinitionGateStep.
     */
    "id"?: number;
}

/**
 * 
 */
export interface ReleaseDefinitionRevision {

    /**
     * Gets api-version for revision object.
     */
    "apiVersion"?: string;

    /**
     * Gets the identity who did change.
     */
    "changedBy"?: IdentityRef;

    /**
     * Gets date on which ReleaseDefinition changed.
     */
    "changedDate"?: Date;

    /**
     * Gets comments for revision.
     */
    "comment"?: string;

    /**
     * Get id of the definition.
     */
    "definitionId"?: number;

    /**
     * Gets definition URL.
     */
    "definitionUrl"?: string;

    /**
     * Get revision number of the definition.
     */
    "revision"?: number;
}

/**
 * 
 */
export interface ReleaseDefinitionShallowReference {

    /**
     * Gets the links to related resources, APIs, and views for the release definition.
     */
    "links"?: ReferenceLinks;

    /**
     * Gets the unique identifier of release definition.
     */
    "id"?: number;

    /**
     * Gets or sets the name of the release definition.
     */
    "name"?: string;

    /**
     * Gets or sets the path of the release definition.
     */
    "path"?: string;

    /**
     * Gets or sets project reference.
     */
    "projectReference"?: ProjectReference;

    /**
     * Gets the REST API url to access the release definition.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ReleaseDefinitionSummary {

    /**
     * List of Release Definition environment summary.
     */
    "environments"?: Array<ReleaseDefinitionEnvironmentSummary>;

    /**
     * Release Definition reference.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * List of releases deployed using this Release Defintion.
     */
    "releases"?: Array<Release>;
}

/**
 * 
 */
export interface ReleaseDefinitionUndeleteParameter {

    /**
     * Gets or sets comment.
     */
    "comment"?: string;
}

/**
 * 
 */
export interface ReleaseDeployPhase {

    /**
     * Deployment jobs of the phase.
     */
    "deploymentJobs"?: Array<DeploymentJob>;

    /**
     * Phase execution error logs.
     */
    "errorLog"?: string;

    /**
     * List of manual intervention tasks execution information in phase.
     */
    "manualInterventions"?: Array<ManualIntervention>;

    /**
     * Name of the phase.
     */
    "name"?: string;

    /**
     * ID of the phase.
     */
    "phaseId"?: string;

    /**
     * Rank of the phase.
     */
    "rank"?: number;

    /**
     * Run Plan ID of the phase.
     */
    "runPlanId"?: string;

    /**
     * Phase start time.
     */
    "startedOn"?: Date;
}

/**
 * 
 */
export interface ReleaseEnvironment {

    /**
     * Gets list of conditions.
     */
    "conditions"?: Array<ReleaseCondition>;

    /**
     * Gets date on which it got created.
     */
    "createdOn"?: Date;

    /**
     * Gets definition environment id.
     */
    "definitionEnvironmentId"?: number;

    /**
     * Gets list of deploy phases snapshot.
     */
    "deployPhasesSnapshot"?: Array<DeployPhase>;

    /**
     * Gets deploy steps.
     */
    "deploySteps"?: Array<DeploymentAttempt>;

    /**
     * Gets environment options.
     */
    "environmentOptions"?: EnvironmentOptions;

    /**
     * Gets the unique identifier of this field.
     */
    "id"?: number;

    /**
     * Gets date on which it got modified.
     */
    "modifiedOn"?: Date;

    /**
     * Gets name.
     */
    "name"?: string;

    /**
     * Gets next scheduled UTC time.
     */
    "nextScheduledUtcTime"?: Date;

    /**
     * Gets the identity who is owner for release environment.
     */
    "owner"?: IdentityRef;

    /**
     * Gets list of post deploy approvals snapshot.
     */
    "postApprovalsSnapshot"?: ReleaseDefinitionApprovals;

    /**
     * Gets list of post deploy approvals.
     */
    "postDeployApprovals"?: Array<ReleaseApproval>;

    /**
     * Post deployment gates snapshot data.
     */
    "postDeploymentGatesSnapshot"?: ReleaseDefinitionGatesStep;

    /**
     * Gets list of pre deploy approvals snapshot.
     */
    "preApprovalsSnapshot"?: ReleaseDefinitionApprovals;

    /**
     * Gets list of pre deploy approvals.
     */
    "preDeployApprovals"?: Array<ReleaseApproval>;

    /**
     * Pre deployment gates snapshot data.
     */
    "preDeploymentGatesSnapshot"?: ReleaseDefinitionGatesStep;

    /**
     * Gets process parameters.
     */
    "processParameters"?: ProcessParameters;

    /**
     * Gets rank.
     */
    "rank"?: number;

    /**
     * Gets release reference which specifies the reference of the release to which this release environment is associated.
     */
    "release"?: ReleaseShallowReference;

    /**
     * Gets the identity who created release.
     */
    "releaseCreatedBy"?: IdentityRef;

    /**
     * Gets releaseDefinitionReference which specifies the reference of the release definition to which this release environment is associated.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;

    /**
     * Gets release id.
     */
    "releaseId"?: number;

    /**
     * Gets schedule deployment time of release environment.
     */
    "scheduledDeploymentTime"?: Date;

    /**
     * Gets list of schedules.
     */
    "schedules"?: Array<ReleaseSchedule>;

    /**
     * Gets time to deploy.
     */
    "timeToDeploy"?: number;

    /**
     * Gets trigger reason.
     */
    "triggerReason"?: string;

    /**
     * Gets the list of variable groups.
     */
    "variableGroups"?: Array<VariableGroup>;

    /**
     * Gets the dictionary of variables.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseEnvironmentCompletedEvent {
    "createdByName"?: string;
    "definitionId"?: number;
    "definitionName"?: string;
    "environment"?: ReleaseEnvironment;
    "environmentId"?: number;
    "projectName"?: string;
    "releaseCreatedBy"?: IdentityRef;
    "releaseLogsUri"?: string;
    "releaseName"?: string;
    "status"?: string;
    "title"?: string;
    "webAccessUri"?: string;
}

/**
 * Reference to release environment resource.
 */
export interface ReleaseEnvironmentDefinitionReference {

    /**
     * ID of the release definition that contains the release environment definition.
     */
    "definitionId"?: number;

    /**
     * ID of the release environment definition.
     */
    "environmentDefinitionId"?: number;
}

/**
 * 
 */
export interface ReleaseEnvironmentShallowReference {

    /**
     * Gets the links to related resources, APIs, and views for the release environment.
     */
    "links"?: ReferenceLinks;

    /**
     * Gets the unique identifier of release environment.
     */
    "id"?: number;

    /**
     * Gets or sets the name of the release environment.
     */
    "name"?: string;

    /**
     * Gets the REST API url to access the release environment.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ReleaseEnvironmentStatusUpdatedEvent extends RealtimeReleaseDefinitionEvent {
}

/**
 * 
 */
export interface ReleaseEnvironmentUpdateMetadata {

    /**
     * Gets or sets comment.
     */
    "comment"?: string;

    /**
     * Gets or sets scheduled deployment time.
     */
    "scheduledDeploymentTime"?: Date;

    /**
     * Sets list of environment variables to be overridden at deployment time.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseGates {

    /**
     * Contains the gates job details of each evaluation.
     */
    "deploymentJobs"?: Array<DeploymentJob>;

    /**
     * ID of release gates.
     */
    "id"?: number;

    /**
     * List of ignored gates.
     */
    "ignoredGates"?: Array<IgnoredGate>;

    /**
     * Gates last modified time.
     */
    "lastModifiedOn"?: Date;

    /**
     * Run plan ID of the gates.
     */
    "runPlanId"?: string;

    /**
     * Gates stabilization completed date and time.
     */
    "stabilizationCompletedOn"?: Date;

    /**
     * Gates evaluation started time.
     */
    "startedOn"?: Date;

    /**
     * Date and time at which all gates executed successfully.
     */
    "succeedingSince"?: Date;
}

/**
 * 
 */
export interface ReleaseGatesPhase extends ReleaseDeployPhase {
}

/**
 * 
 */
export interface ReleaseManagementInputValue {

    /**
     * The text to show for the display of this value.
     */
    "displayValue"?: string;

    /**
     * The value to store for this input.
     */
    "value"?: string;
}

/**
 * 
 */
export interface ReleaseNotCreatedEvent {
    "definitionReference"?: ReleaseDefinitionShallowReference;
    "message"?: string;
    "requestedBy"?: IdentityRef;
}

/**
 * Reference to a release.
 */
export interface ReleaseReference {
    "attempt"?: number;
    "creationDate"?: Date;

    /**
     * Release definition ID.
     */
    "definitionId"?: number;
    "environmentCreationDate"?: Date;

    /**
     * Release environment definition ID.
     */
    "environmentDefinitionId"?: number;

    /**
     * Release environment definition name.
     */
    "environmentDefinitionName"?: string;

    /**
     * Release environment ID.
     */
    "environmentId"?: number;

    /**
     * Release environment name.
     */
    "environmentName"?: string;

    /**
     * Release ID.
     */
    "id"?: number;

    /**
     * Release name.
     */
    "name"?: string;

    /**
     * Gets links to access the release.
     */
    "links"?: ReferenceLinks;

    /**
     * Gets list of artifacts.
     */
    "artifacts"?: Array<Artifact>;

    /**
     * Gets the identity who created release.
     */
    "createdBy"?: IdentityRef;

    /**
     * Gets date on when this release created.
     */
    "createdOn"?: Date;

    /**
     * Gets description.
     */
    "description"?: string;

    /**
     * Gets the identity who modified release.
     */
    "modifiedBy"?: IdentityRef;

    /**
     * Gets release definition shallow reference.
     */
    "releaseDefinition"?: ReleaseDefinitionShallowReference;
}

/**
 * 
 */
export interface ReleaseReference2 {
    "attempt"?: number;
    "environmentCreationDate"?: Date;
    "projectId"?: string;
    "releaseCreationDate"?: Date;
    "releaseDefId"?: number;
    "releaseEnvDefId"?: number;
    "releaseEnvId"?: number;
    "releaseEnvName"?: string;
    "releaseEnvUri"?: string;
    "releaseId"?: number;
    "releaseName"?: string;
    "releaseRefId"?: number;
    "releaseUri"?: string;
}

/**
 * 
 */
export interface ReleaseRevision {

    /**
     * Gets or sets the identity who changed.
     */
    "changedBy"?: IdentityRef;

    /**
     * Change date of the revision.
     */
    "changedDate"?: Date;

    /**
     * Change details of the revision.
     */
    "changeDetails"?: string;

    /**
     * Change details of the revision. Typically ChangeDetails values are Add and Update.
     */
    "changeType"?: string;

    /**
     * Comment of the revision.
     */
    "comment"?: string;

    /**
     * Release ID of which this revision belongs.
     */
    "definitionSnapshotRevision"?: number;

    /**
     * Gets or sets the release ID of which this revision belongs.
     */
    "releaseId"?: number;
}

/**
 * 
 */
export interface ReleaseSchedule {

    /**
     * Team Foundation Job Definition Job Id.
     */
    "jobId"?: string;

    /**
     * Flag to determine if this schedule should only release if the associated artifact has been changed or release definition changed.
     */
    "scheduleOnlyWithChanges"?: boolean;

    /**
     * Local time zone hour to start.
     */
    "startHours"?: number;

    /**
     * Local time zone minute to start.
     */
    "startMinutes"?: number;

    /**
     * Time zone Id of release schedule, such as 'UTC'.
     */
    "timeZoneId"?: string;
}

/**
 * 
 */
export interface ReleaseSettings {

    /**
     * Release retention settings.
     */
    "retentionSettings"?: RetentionSettings;
}

/**
 * 
 */
export interface ReleaseShallowReference {

    /**
     * Gets the links to related resources, APIs, and views for the release.
     */
    "links"?: ReferenceLinks;

    /**
     * Gets the unique identifier of release.
     */
    "id"?: number;

    /**
     * Gets or sets the name of the release.
     */
    "name"?: string;

    /**
     * Gets the REST API url to access the release.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ReleaseStartEnvironmentMetadata {

    /**
     * Sets release definition environment id.
     */
    "definitionEnvironmentId"?: number;

    /**
     * Sets list of environments variables to be overridden at deployment time.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseStartMetadata {

    /**
     * Sets list of artifact to create a release.
     */
    "artifacts"?: Array<ArtifactMetadata>;

    /**
     * Sets definition Id to create a release.
     */
    "definitionId"?: number;

    /**
     * Sets description to create a release.
     */
    "description"?: string;

    /**
     * Sets list of environments meta data.
     */
    "environmentsMetadata"?: Array<ReleaseStartEnvironmentMetadata>;

    /**
     * Sets 'true' to create release in draft mode, 'false' otherwise.
     */
    "isDraft"?: boolean;

    /**
     * Sets list of environments to manual as condition.
     */
    "manualEnvironments"?: Array<string>;
    "properties"?: PropertiesCollection;

    /**
     * Sets list of release variables to be overridden at deployment time.
     */
    "variables"?: { [key: string]: ConfigurationVariableValue; };
}

/**
 * 
 */
export interface ReleaseTask {

    /**
     * Agent name on which task executed.
     */
    "agentName"?: string;

    /**
     * Finish time of the release task.
     */
    "finishTime"?: Date;

    /**
     * ID of the release task.
     */
    "id"?: number;

    /**
     * List of issues occurred while execution of task.
     */
    "issues"?: Array<Issue>;

    /**
     * Number of lines log release task has.
     */
    "lineCount"?: number;

    /**
     * Log URL of the task.
     */
    "logUrl"?: string;

    /**
     * Name of the task.
     */
    "name"?: string;

    /**
     * Task execution complete precent.
     */
    "percentComplete"?: number;

    /**
     * Rank of the release task.
     */
    "rank"?: number;

    /**
     * Result code of the task.
     */
    "resultCode"?: string;

    /**
     * ID of the release task.
     */
    "startTime"?: Date;

    /**
     * Workflow task reference.
     */
    "task"?: WorkflowTaskReference;

    /**
     * Timeline record ID of the release task.
     */
    "timelineRecordId"?: string;
}

/**
 * 
 */
export interface ReleaseTaskAttachment {

    /**
     * Reference links of task.
     */
    "links"?: ReferenceLinks;

    /**
     * Data and time when it created.
     */
    "createdOn"?: Date;

    /**
     * Identity who modified.
     */
    "modifiedBy"?: IdentityRef;

    /**
     * Data and time when modified.
     */
    "modifiedOn"?: Date;

    /**
     * Name of the task attachment.
     */
    "name"?: string;

    /**
     * Record ID of the task.
     */
    "recordId"?: string;

    /**
     * Timeline ID of the task.
     */
    "timelineId"?: string;

    /**
     * Type of task attachment.
     */
    "type"?: string;
}

/**
 * 
 */
export interface ReleaseTaskLogUpdatedEvent extends RealtimeReleaseEvent {
}

/**
 * 
 */
export interface ReleaseTasksUpdatedEvent extends RealtimeReleaseEvent {
}

/**
 * 
 */
export interface ReleaseTriggerBase {
}

/**
 * 
 */
export interface ReleaseUpdateMetadata {

    /**
     * Sets comment for release.
     */
    "comment"?: string;

    /**
     * Set 'true' to exclude the release from retention policies.
     */
    "keepForever"?: boolean;

    /**
     * Sets list of manual environments.
     */
    "manualEnvironments"?: Array<string>;

    /**
     * Sets name of the release.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ReleaseUpdatedEvent extends RealtimeReleaseEvent {
}

/**
 * 
 */
export interface ReleaseWorkItemRef {

    /**
     * Gets or sets the ID.
     */
    "id"?: string;

    /**
     * Gets or sets the state.
     */
    "state"?: string;

    /**
     * Gets or sets the title.
     */
    "title"?: string;

    /**
     * Gets or sets the type.
     */
    "type"?: string;

    /**
     * Gets or sets the workitem url.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ReportingWorkItemLinksBatch extends StreamedBatch {
}

/**
 * 
 */
export interface ReportingWorkItemRevisionsBatch extends StreamedBatch {
}

/**
 * 
 */
export interface ReportingWorkItemRevisionsFilter {

    /**
     * A list of fields to return in work item revisions. Omit this parameter to get all reportable fields.
     */
    "fields"?: Array<string>;

    /**
     * Include deleted work item in the result.
     */
    "includeDeleted"?: boolean;

    /**
     * Return an identity reference instead of a string value for identity fields.
     */
    "includeIdentityRef"?: boolean;

    /**
     * Include only the latest version of a work item, skipping over all previous revisions of the work item.
     */
    "includeLatestOnly"?: boolean;

    /**
     * Include tag reference instead of string value for System.Tags field
     */
    "includeTagRef"?: boolean;

    /**
     * A list of types to filter the results to specific work item types. Omit this parameter to get work item revisions of all work item types.
     */
    "types"?: Array<string>;
}

/**
 * Defines the details of the repository.
 */
export interface Repository {

    /**
     * Id of the repository.
     */
    "id"?: string;

    /**
     * Name of the repository.
     */
    "name"?: string;
}

/**
 * Represents a repository's webhook returned from a source provider.
 */
export interface RepositoryWebhook {

    /**
     * The friendly name of the repository.
     */
    "name"?: string;
    "types"?: Array<ERRORUNKNOWN>;

    /**
     * The URL of the repository.
     */
    "url"?: string;
}

/**
 * Symbol request.
 */
export interface Request extends ResourceBase {
}

/**
 * 
 */
export interface RequestSummary {
    "averageResponseTime"?: number;
    "failedRequests"?: number;
    "passedRequests"?: number;
    "percentileData"?: Array<SummaryPercentileData>;
    "requestsPerSec"?: number;
    "requestUrl"?: string;
    "scenarioName"?: string;
    "testName"?: string;
    "totalRequests"?: number;
}

/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface RequestedExtension {

    /**
     * The unique name of the extension
     */
    "extensionName"?: string;

    /**
     * A list of each request for the extension
     */
    "extensionRequests"?: Array<ExtensionRequest>;

    /**
     * DisplayName of the publisher that owns the extension being published.
     */
    "publisherDisplayName"?: string;

    /**
     * Represents the Publisher of the requested extension
     */
    "publisherName"?: string;

    /**
     * The total number of requests for an extension
     */
    "requestCount"?: number;
}

/**
 * 
 */
export interface RequirementsToTestsMapping2 {
    "createdBy"?: string;
    "creationDate"?: Date;
    "deletedBy"?: string;
    "deletionDate"?: Date;
    "isMigratedToWIT"?: boolean;
    "projectId"?: string;
    "testMetadataId"?: number;
    "workItemId"?: number;
}

/**
 * 
 */
export interface ResetTestResultsRequest {
    "ids"?: Array<LegacyTestCaseResultIdentifier>;
    "projectName"?: string;
}

/**
 * Entry for a specific data provider's resulting data
 */
export interface ResolvedDataProvider {

    /**
     * The total time the data provider took to resolve its data (in milliseconds)
     */
    "duration"?: string;
    "error"?: string;
    "id"?: string;
}

/**
 * 
 */
export interface ResourceBase {

    /**
     * The ID of user who created this item. Optional.
     */
    "createdBy"?: string;

    /**
     * The date time when this item is created. Optional.
     */
    "createdDate"?: Date;

    /**
     * An identifier for this item. Optional.
     */
    "id"?: string;

    /**
     * An opaque ETag used to synchronize with the version stored at server end. Optional.
     */
    "storageETag"?: string;

    /**
     * A URI which can be used to retrieve this item in its raw format. Optional. Note this is distinguished from other URIs that are present in a derived resource.
     */
    "url"?: string;
}

/**
 * The base class for all resource containers, i.e. Account, Collection, Project
 */
export interface ResourceContainer {

    /**
     * Gets or sets the container's base URL, i.e. the URL of the host (collection, application, or deploument) containing the container resource.
     */
    "baseUrl"?: string;

    /**
     * Gets or sets the container's specific Id.
     */
    "id"?: string;

    /**
     * Gets or sets the container's name.
     */
    "name"?: string;

    /**
     * Gets or sets the container's REST API URL.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ResourceFilterOptions {
    "identities"?: Array<IdentityRef>;
    "resourceTypes"?: Array<string>;
}

/**
 * 
 */
export interface ResourceFilters {
    "createdBy"?: Array<string>;
    "resourceType"?: Array<string>;
    "searchText"?: string;
}

/**
 * Resources include Service Connections, Variable Groups and Secure Files.
 */
export interface ResourceItem {

    /**
     * Gets or sets the identity who created the resource.
     */
    "createdBy"?: IdentityRef;

    /**
     * Gets or sets description of the resource.
     */
    "description"?: string;

    /**
     * Gets or sets icon url of the resource.
     */
    "iconUrl"?: string;

    /**
     * Gets or sets Id of the resource.
     */
    "id"?: string;

    /**
     * Indicates whether resource is shared with other projects or not.
     */
    "isShared"?: boolean;

    /**
     * Gets or sets name of the resource.
     */
    "name"?: string;

    /**
     * Gets or sets internal properties of the resource.
     */
    "properties"?: { [key: string]: string; };

    /**
     * Gets or sets resource type.
     */
    "resourceType"?: string;
}

/**
 * 
 */
export interface ResourceLimit {
    "failedToReachAllProviders"?: boolean;
    "hostId"?: string;
    "isHosted"?: boolean;
    "isPremium"?: boolean;
    "parallelismTag"?: string;
    "resourceLimitsData"?: { [key: string]: string; };
    "totalCount"?: number;
    "totalMinutes"?: number;
}

/**
 * 
 */
export interface ResourceRef {
    "id"?: string;
    "url"?: string;
}

/**
 * Represents a reference to a resource.
 */
export interface ResourceReference {

    /**
     * An alias to be used when referencing the resource.
     */
    "alias"?: string;
}

/**
 * 
 */
export interface ResourceUsage {
    "resourceLimit"?: ResourceLimit;
    "runningRequests"?: Array<TaskAgentJobRequest>;
    "usedCount"?: number;
    "usedMinutes"?: number;
}

/**
 * 
 */
export interface ResourcesHubData {
    "continuationToken"?: string;
    "resourceFilterOptions"?: ResourceFilterOptions;
    "resourceFilters"?: ResourceFilters;
    "resourceItems"?: Array<ResourceItem>;
}

/**
 * 
 */
export interface Response {
    "error"?: string;
    "id"?: string;
    "url"?: string;
}

/**
 * Test result retention settings
 */
export interface ResultRetentionSettings {

    /**
     * Automated test result retention duration in days
     */
    "automatedResultsRetentionDuration"?: number;

    /**
     * Last Updated by identity
     */
    "lastUpdatedBy"?: IdentityRef;

    /**
     * Last updated date
     */
    "lastUpdatedDate"?: Date;

    /**
     * Manual test result retention duration in days
     */
    "manualResultsRetentionDuration"?: number;
}

/**
 * 
 */
export interface ResultTransformationDetails {

    /**
     * Gets or sets the template for callback parameters
     */
    "callbackContextTemplate"?: string;

    /**
     * Gets or sets the template to decide whether to callback or not
     */
    "callbackRequiredTemplate"?: string;

    /**
     * Gets or sets the template for result transformation.
     */
    "resultTemplate"?: string;
}

/**
 * 
 */
export interface ResultUpdateRequest {
    "actionResultDeletes"?: Array<TestActionResult>;
    "actionResults"?: Array<TestActionResult>;
    "attachmentDeletes"?: Array<TestResultAttachmentIdentity>;
    "attachments"?: Array<TestResultAttachment>;
    "parameterDeletes"?: Array<TestResultParameter>;
    "parameters"?: Array<TestResultParameter>;
    "testCaseResult"?: LegacyTestCaseResult;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface ResultUpdateRequestModel {
    "actionResultDeletes"?: Array<TestActionResultModel>;
    "actionResults"?: Array<TestActionResultModel>;
    "parameterDeletes"?: Array<TestResultParameterModel>;
    "parameters"?: Array<TestResultParameterModel>;
    "testCaseResult"?: TestCaseResultUpdateModel;
}

/**
 * 
 */
export interface ResultUpdateResponse {
    "attachmentIds"?: Array<number>;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "lastUpdatedByName"?: string;
    "maxReservedSubResultId"?: number;
    "revision"?: number;
    "testResultId"?: number;
}

/**
 * 
 */
export interface ResultUpdateResponseModel {
    "revision"?: number;
}

/**
 * Results class for Test Point
 */
export interface Results {
}

/**
 * 
 */
export interface ResultsByQueryRequest {
    "pageSize"?: number;
    "query"?: ResultsStoreQuery;
}

/**
 * 
 */
export interface ResultsByQueryResponse {
    "excessIds"?: Array<LegacyTestCaseResultIdentifier>;
    "testResults"?: Array<LegacyTestCaseResult>;
}

/**
 * 
 */
export interface ResultsFilter {
    "automatedTestName"?: string;
    "branch"?: string;
    "groupBy"?: string;
    "maxCompleteDate"?: Date;
    "resultsCount"?: number;
    "testCaseId"?: number;
    "testCaseReferenceIds"?: Array<number>;
    "testPlanId"?: number;
    "testPointIds"?: Array<number>;
    "testResultsContext"?: TestResultsContext;
    "trendDays"?: number;
}

/**
 * 
 */
export interface ResultsStoreQuery {
    "dayPrecision"?: boolean;
    "queryText"?: string;
    "teamProjectName"?: string;
    "timeZone"?: string;
}

/**
 * Real time event (SignalR) for when the target branch of a pull request is changed
 */
export interface RetargetEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface RetentionPolicy {
    "artifacts"?: Array<string>;
    "artifactTypesToDelete"?: Array<string>;
    "branches"?: Array<string>;

    /**
     * Indicates the number of days to keep deployment.
     */
    "daysToKeep"?: number;

    /**
     * Indicates whether the build record itself should be deleted.
     */
    "deleteBuildRecord"?: boolean;

    /**
     * Indicates whether to delete test results associated with the build.
     */
    "deleteTestResults"?: boolean;

    /**
     * The minimum number of builds to keep.
     */
    "minimumToKeep"?: number;
}

/**
 * 
 */
export interface RetentionSettings {

    /**
     * Number of days to keep deleted releases.
     */
    "daysToKeepDeletedReleases"?: number;

    /**
     * Specifies the default environment retention policy.
     */
    "defaultEnvironmentRetentionPolicy"?: EnvironmentRetentionPolicy;

    /**
     * Specifies the maximum environment retention policy.
     */
    "maximumEnvironmentRetentionPolicy"?: EnvironmentRetentionPolicy;
}

/**
 * Real time event (SignalR) for a reviewer vote update on a pull request
 */
export interface ReviewerVoteUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * Real time event (SignalR) for an update to reviewers on a pull request
 */
export interface ReviewersUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * Real time event (SignalR) for reviewer votes being reset on a pull request
 */
export interface ReviewersVotesResetEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface RoleBasedFilter extends ExpressionFilter {
}

/**
 * 
 */
export interface Rule {
    "clauses"?: Array<FilterClause>;
    "filter"?: string;
    "isEnabled"?: string;
    "name"?: string;
    "settings"?: Attribute;
}

/**
 * 
 */
export interface RuleAction {

    /**
     * Field on which the action should be taken.
     */
    "targetField"?: string;

    /**
     * Value to apply on target field, once the action is taken.
     */
    "value"?: string;
}

/**
 * 
 */
export interface RuleActionModel {
    "actionType"?: string;
    "targetField"?: string;
    "value"?: string;
}

/**
 * Defines a condition on a field when the rule should be triggered.
 */
export interface RuleCondition {

    /**
     * Field that defines condition.
     */
    "field"?: string;

    /**
     * Value of field to define the condition for rule.
     */
    "value"?: string;
}

/**
 * 
 */
export interface RuleConditionModel {
    "conditionType"?: string;
    "field"?: string;
    "value"?: string;
}

/**
 * Test run create details.
 */
export interface RunCreateModel {

    /**
     * true if test run is automated, false otherwise. By default it will be false.
     */
    "automated"?: boolean;

    /**
     * An abstracted reference to the build that it belongs.
     */
    "build"?: ShallowReference;

    /**
     * Drop location of the build used for test run.
     */
    "buildDropLocation"?: string;

    /**
     * Flavor of the build used for test run. (E.g: Release, Debug)
     */
    "buildFlavor"?: string;

    /**
     * Platform of the build used for test run. (E.g.: x86, amd64)
     */
    "buildPlatform"?: string;
    "buildReference"?: BuildConfiguration;

    /**
     * Comments entered by those analyzing the run.
     */
    "comment"?: string;

    /**
     * Completed date time of the run.
     */
    "completeDate"?: string;

    /**
     * IDs of the test configurations associated with the run.
     */
    "configurationIds"?: Array<number>;

    /**
     * Name of the test controller used for automated run.
     */
    "controller"?: string;
    "customTestFields"?: Array<CustomTestField>;

    /**
     * An abstracted reference to DtlAutEnvironment.
     */
    "dtlAutEnvironment"?: ShallowReference;

    /**
     * An abstracted reference to DtlTestEnvironment.
     */
    "dtlTestEnvironment"?: ShallowReference;

    /**
     * Due date and time for test run.
     */
    "dueDate"?: string;
    "environmentDetails"?: DtlEnvironmentDetails;

    /**
     * Error message associated with the run.
     */
    "errorMessage"?: string;
    "filter"?: RunFilter;

    /**
     * The iteration in which to create the run. Root iteration of the team project will be default
     */
    "iteration"?: string;

    /**
     * Name of the test run.
     */
    "name"?: string;

    /**
     * Display name of the owner of the run.
     */
    "owner"?: IdentityRef;

    /**
     * An abstracted reference to the plan that it belongs.
     */
    "plan"?: ShallowReference;

    /**
     * IDs of the test points to use in the run.
     */
    "pointIds"?: Array<number>;

    /**
     * URI of release environment associated with the run.
     */
    "releaseEnvironmentUri"?: string;
    "releaseReference"?: ReleaseReference;

    /**
     * URI of release associated with the run.
     */
    "releaseUri"?: string;

    /**
     * Run summary for run Type = NoConfigRun.
     */
    "runSummary"?: Array<RunSummaryModel>;
    "runTimeout"?: string;
    "sourceWorkflow"?: string;

    /**
     * Start date time of the run.
     */
    "startDate"?: string;

    /**
     * The state of the run. Valid states - NotStarted, InProgress, Waiting
     */
    "state"?: string;
    "testConfigurationsMapping"?: string;

    /**
     * ID of the test environment associated with the run.
     */
    "testEnvironmentId"?: string;

    /**
     * An abstracted reference to the test settings resource.
     */
    "testSettings"?: ShallowReference;

    /**
     * Type of the run(RunType)
     */
    "type"?: string;
}

/**
 * This class is used to provide the filters used for discovery
 */
export interface RunFilter {

    /**
     * filter for the test case sources (test containers)
     */
    "sourceFilter"?: string;

    /**
     * filter for the test cases
     */
    "testCaseFilter"?: string;
}

/**
 * 
 */
export interface RunOnServerDeployPhase extends DeployPhase {
}

/**
 * Test run statistics.
 */
export interface RunStatistic {
    "count"?: number;

    /**
     * Test run outcome
     */
    "outcome"?: string;
    "resolutionState"?: TestResolutionState;

    /**
     * State of the test run
     */
    "state"?: string;
}

/**
 * Run summary for each output type of test.
 */
export interface RunSummaryModel {

    /**
     * Total time taken in milliseconds.
     */
    "duration"?: number;

    /**
     * Number of results for Outcome TestOutcome
     */
    "resultCount"?: number;
}

/**
 * 
 */
export interface RunUpdateModel {

    /**
     * An abstracted reference to the build that it belongs.
     */
    "build"?: ShallowReference;
    "buildDropLocation"?: string;
    "buildFlavor"?: string;
    "buildPlatform"?: string;

    /**
     * Comments entered by those analyzing the run.
     */
    "comment"?: string;

    /**
     * Completed date time of the run.
     */
    "completedDate"?: string;

    /**
     * Name of the test controller used for automated run.
     */
    "controller"?: string;
    "deleteInProgressResults"?: boolean;

    /**
     * An abstracted reference to DtlAutEnvironment.
     */
    "dtlAutEnvironment"?: ShallowReference;

    /**
     * An abstracted reference to DtlEnvironment.
     */
    "dtlEnvironment"?: ShallowReference;
    "dtlEnvironmentDetails"?: DtlEnvironmentDetails;

    /**
     * Due date and time for test run.
     */
    "dueDate"?: string;

    /**
     * Error message associated with the run.
     */
    "errorMessage"?: string;

    /**
     * The iteration in which to create the run.
     */
    "iteration"?: string;

    /**
     * Log entries associated with the run. Use a comma-separated list of multiple log entry objects. { logEntry }, { logEntry }, ...
     */
    "logEntries"?: Array<TestMessageLogDetails>;

    /**
     * Name of the test run.
     */
    "name"?: string;
    "releaseEnvironmentUri"?: string;
    "releaseUri"?: string;

    /**
     * Run summary for run Type = NoConfigRun.
     */
    "runSummary"?: Array<RunSummaryModel>;
    "sourceWorkflow"?: string;

    /**
     * Start date time of the run.
     */
    "startedDate"?: string;

    /**
     * The state of the test run Below are the valid values - NotStarted, InProgress, Completed, Aborted, Waiting
     */
    "state"?: string;
    "testEnvironmentId"?: string;

    /**
     * An abstracted reference to test setting resource.
     */
    "testSettings"?: ShallowReference;
}

/**
 * 
 */
export interface SaveCachedPackagesData extends FeedBatchOperationData {
}

/**
 * 
 */
export interface ScenarioSummary {
    "maxUserLoad"?: number;
    "minUserLoad"?: number;
    "scenarioName"?: string;
}

/**
 * 
 */
export interface Schedule {
    "branchFilters"?: Array<string>;

    /**
     * The Job Id of the Scheduled job that will queue the scheduled build. Since a single trigger can have multiple schedules and we want a single job to process a single schedule (since each schedule has a list of branches to build), the schedule itself needs to define the Job Id. This value will be filled in when a definition is added or updated.  The UI does not provide it or use it.
     */
    "scheduleJobId"?: string;

    /**
     * Flag to determine if this schedule should only build if the associated source has been changed.
     */
    "scheduleOnlyWithChanges"?: boolean;

    /**
     * Local timezone hour to start
     */
    "startHours"?: number;

    /**
     * Local timezone minute to start
     */
    "startMinutes"?: number;

    /**
     * Time zone of the build schedule (String representation of the time zone ID)
     */
    "timeZoneId"?: string;
}

/**
 * Represents a schedule trigger.
 */
export interface ScheduleTrigger extends BuildTrigger {
}

/**
 * 
 */
export interface ScheduledReleaseTrigger extends ReleaseTriggerBase {
}

/**
 * 
 */
export interface Scope {
    "description"?: string;
    "title"?: string;
    "value"?: string;
}

/**
 * Defines a scroll code search request.
 */
export interface ScrollSearchRequest extends EntitySearchRequestBase {
}

/**
 * A layout node holding groups together in a page
 */
export interface Section {

    /**
     * List of child groups in this section
     */
    "groups"?: Array<Group>;

    /**
     * The id for the layout node.
     */
    "id"?: string;

    /**
     * A value indicating whether this layout node has been overridden by a child layout.
     */
    "overridden"?: boolean;
}

/**
 * 
 */
export interface SecureFile {
    "createdBy"?: IdentityRef;
    "createdOn"?: Date;
    "id"?: string;
    "modifiedBy"?: IdentityRef;
    "modifiedOn"?: Date;
    "name"?: string;
    "properties"?: { [key: string]: string; };
    "ticket"?: string;
}

/**
 * 
 */
export interface SecureFileEvent {
    "eventType"?: string;
    "projectId"?: string;
    "secureFiles"?: Array<SecureFile>;
}

/**
 * Represents a reference to a secure file.
 */
export interface SecureFileReference extends ResourceReference {
}

/**
 * Class for describing the details of a TeamFoundationSecurityNamespace.
 */
export interface SecurityNamespaceDescription {

    /**
     * The list of actions that this Security Namespace is responsible for securing.
     */
    "actions"?: Array<ActionDefinition>;

    /**
     * This is the dataspace category that describes where the security information for this SecurityNamespace should be stored.
     */
    "dataspaceCategory"?: string;

    /**
     * This localized name for this namespace.
     */
    "displayName"?: string;

    /**
     * If the security tokens this namespace will be operating on need to be split on certain character lengths to determine its elements, that length should be specified here. If not, this value will be -1.
     */
    "elementLength"?: number;

    /**
     * This is the type of the extension that should be loaded from the plugins directory for extending this security namespace.
     */
    "extensionType"?: string;

    /**
     * If true, the security namespace is remotable, allowing another service to proxy the namespace.
     */
    "isRemotable"?: boolean;

    /**
     * This non-localized for this namespace.
     */
    "name"?: string;

    /**
     * The unique identifier for this namespace.
     */
    "namespaceId"?: string;

    /**
     * The permission bits needed by a user in order to read security data on the Security Namespace.
     */
    "readPermission"?: number;

    /**
     * If the security tokens this namespace will be operating on need to be split on certain characters to determine its elements that character should be specified here. If not, this value will be the null character.
     */
    "separatorValue"?: string;

    /**
     * Used to send information about the structure of the security namespace over the web service.
     */
    "structureValue"?: number;

    /**
     * The bits reserved by system store
     */
    "systemBitMask"?: number;

    /**
     * If true, the security service will expect an ISecurityDataspaceTokenTranslator plugin to exist for this namespace
     */
    "useTokenTranslator"?: boolean;

    /**
     * The permission bits needed by a user in order to modify security data on the Security Namespace.
     */
    "writePermission"?: number;
}

/**
 * versioning for an artifact as described at: http://semver.org/, of the form major.minor.patch.
 */
export interface SemanticVersion {

    /**
     * Major version when you make incompatible API changes
     */
    "major"?: number;

    /**
     * Minor version when you add functionality in a backwards-compatible manner
     */
    "minor"?: number;

    /**
     * Patch version when you make backwards-compatible bug fixes
     */
    "patch"?: number;
}

/**
 * 
 */
export interface SendJobResponse {
    "events"?: JobEventsConfig;
    "variables"?: { [key: string]: string; };
}

/**
 * 
 */
export interface ServerDeploymentInput extends BaseDeploymentInput {
}

/**
 * 
 */
export interface ServerExecutionDefinition {
    "events"?: EventsConfig;
    "handlerName"?: string;
}

/**
 * Represents a phase target that runs on the server.
 */
export interface ServerTarget extends PhaseTarget {
}

/**
 * Represents options for running a phase on the server.
 */
export interface ServerTargetExecutionOptions {

    /**
     * The type.
     */
    "type"?: number;
}

/**
 * 
 */
export interface ServerTaskRequestMessage extends JobRequestMessage {
}

/**
 * 
 */
export interface ServiceBusSubscriptionChannel {
    "type"?: string;
}

/**
 * Represents an endpoint which may be used by an orchestration job.
 */
export interface ServiceEndpoint {

    /**
     * Gets or sets the identity reference for the administrators group of the service endpoint.
     */
    "administratorsGroup"?: IdentityRef;

    /**
     * Gets or sets the authorization data for talking to the endpoint.
     */
    "authorization"?: EndpointAuthorization;

    /**
     * Gets or sets the identity reference for the user who created the Service endpoint.
     */
    "createdBy"?: IdentityRef;
    "data"?: { [key: string]: string; };

    /**
     * Gets or sets the description of endpoint.
     */
    "description"?: string;
    "groupScopeId"?: string;

    /**
     * Gets or sets the identifier of this endpoint.
     */
    "id"?: string;

    /**
     * EndPoint state indictor
     */
    "isReady"?: boolean;

    /**
     * Indicates whether service endpoint is shared with other projects or not.
     */
    "isShared"?: boolean;

    /**
     * Gets or sets the friendly name of the endpoint.
     */
    "name"?: string;

    /**
     * Error message during creation/deletion of endpoint
     */
    "operationStatus"?: JObject;

    /**
     * Owner of the endpoint Supported values are "library", "agentcloud"
     */
    "owner"?: string;

    /**
     * Gets or sets the identity reference for the readers group of the service endpoint.
     */
    "readersGroup"?: IdentityRef;

    /**
     * Gets or sets the type of the endpoint.
     */
    "type"?: string;

    /**
     * Gets or sets the url of the endpoint.
     */
    "url"?: string;
}

/**
 * 
 */
export interface ServiceEndpointAuthenticationScheme {

    /**
     * Gets or sets the authorization headers of service endpoint authentication scheme.
     */
    "authorizationHeaders"?: Array<AuthorizationHeader>;

    /**
     * Gets or sets the Authorization url required to authenticate using OAuth2
     */
    "authorizationUrl"?: string;

    /**
     * Gets or sets the certificates of service endpoint authentication scheme.
     */
    "clientCertificates"?: Array<ClientCertificate>;
    "dataSourceBindings"?: Array<DataSourceBinding>;

    /**
     * Gets or sets the display name for the service endpoint authentication scheme.
     */
    "displayName"?: string;

    /**
     * Gets or sets the input descriptors for the service endpoint authentication scheme.
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets the scheme for service endpoint authentication.
     */
    "scheme"?: string;
}

/**
 * 
 */
export interface ServiceEndpointDetails {

    /**
     * Gets or sets the authorization of service endpoint.
     */
    "authorization"?: EndpointAuthorization;

    /**
     * Gets or sets the data of service endpoint.
     */
    "data"?: { [key: string]: string; };

    /**
     * Gets or sets the type of service endpoint.
     */
    "type"?: string;

    /**
     * Gets or sets the connection url of service endpoint.
     */
    "url"?: string;
}

/**
 * Represents service endpoint execution data.
 */
export interface ServiceEndpointExecutionData {

    /**
     * Gets the definition of service endpoint execution owner.
     */
    "definition"?: TaskOrchestrationOwner;

    /**
     * Gets the finish time of service endpoint execution.
     */
    "finishTime"?: Date;

    /**
     * Gets the Id of service endpoint execution data.
     */
    "id"?: number;

    /**
     * Gets the owner of service endpoint execution data.
     */
    "owner"?: TaskOrchestrationOwner;

    /**
     * Gets the plan type of service endpoint execution data.
     */
    "planType"?: string;

    /**
     * Gets the start time of service endpoint execution.
     */
    "startTime"?: Date;
}

/**
 * Represents execution owner of the service endpoint.
 */
export interface ServiceEndpointExecutionOwner {
    "links"?: ReferenceLinks;

    /**
     * Gets or sets the Id of service endpoint execution owner.
     */
    "id"?: number;

    /**
     * Gets or sets the name of service endpoint execution owner.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ServiceEndpointExecutionRecord {

    /**
     * Gets the execution data of service endpoint execution.
     */
    "data"?: ServiceEndpointExecutionData;

    /**
     * Gets the Id of service endpoint.
     */
    "endpointId"?: string;
}

/**
 * 
 */
export interface ServiceEndpointExecutionRecordsInput {
    "data"?: ServiceEndpointExecutionData;
    "endpointIds"?: Array<string>;
}

/**
 * 
 */
export interface ServiceEndpointOAuthConfigurationReference {
    "configurationId"?: string;
    "serviceEndpointId"?: string;
    "serviceEndpointProjectId"?: string;
}

/**
 * Represents a referenec to a service endpoint.
 */
export interface ServiceEndpointReference extends ResourceReference {
}

/**
 * 
 */
export interface ServiceEndpointRequest {

    /**
     * Gets or sets the data source details for the service endpoint request.
     */
    "dataSourceDetails"?: DataSourceDetails;

    /**
     * Gets or sets the result transformation details for the service endpoint request.
     */
    "resultTransformationDetails"?: ResultTransformationDetails;

    /**
     * Gets or sets the service endpoint details for the service endpoint request.
     */
    "serviceEndpointDetails"?: ServiceEndpointDetails;
}

/**
 * 
 */
export interface ServiceEndpointRequestResult {

    /**
     * Gets or sets the parameters used to make subsequent calls to the data source
     */
    "callbackContextParameters"?: { [key: string]: string; };

    /**
     * Gets or sets the flat that decides if another call to the data source is to be made
     */
    "callbackRequired"?: boolean;

    /**
     * Gets or sets the error message of the service endpoint request result.
     */
    "errorMessage"?: string;

    /**
     * Gets or sets the result of service endpoint request.
     */
    "result"?: JToken;
}

/**
 * Represents type of the service endpoint.
 */
export interface ServiceEndpointType {

    /**
     * Authentication scheme of service endpoint type.
     */
    "authenticationSchemes"?: Array<ServiceEndpointAuthenticationScheme>;

    /**
     * Data sources of service endpoint type.
     */
    "dataSources"?: Array<DataSource>;

    /**
     * Dependency data of service endpoint type.
     */
    "dependencyData"?: Array<DependencyData>;

    /**
     * Gets or sets the description of service endpoint type.
     */
    "description"?: string;

    /**
     * Gets or sets the display name of service endpoint type.
     */
    "displayName"?: string;

    /**
     * Gets or sets the endpoint url of service endpoint type.
     */
    "endpointUrl"?: EndpointUrl;

    /**
     * Gets or sets the help link of service endpoint type.
     */
    "helpLink"?: HelpLink;
    "helpMarkDown"?: string;

    /**
     * Gets or sets the icon url of service endpoint type.
     */
    "iconUrl"?: string;

    /**
     * Input descriptor of service endpoint type.
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets the name of service endpoint type.
     */
    "name"?: string;

    /**
     * Trusted hosts of a service endpoint type.
     */
    "trustedHosts"?: Array<string>;

    /**
     * Gets or sets the ui contribution id of service endpoint type.
     */
    "uiContributionId"?: string;
}

/**
 * 
 */
export interface ServiceGroup {
    "createdBy"?: IdentityRef;
    "createdOn"?: Date;
    "environmentReference"?: EnvironmentReference;
    "id"?: number;
    "lastModifiedBy"?: IdentityRef;
    "lastModifiedOn"?: Date;
    "name"?: string;
}

/**
 * ServiceGroupReference.
 */
export interface ServiceGroupReference {

    /**
     * Id of the Service Group.
     */
    "id"?: number;

    /**
     * Name of the service group.
     */
    "name"?: string;
}

/**
 * 
 */
export interface ServiceHooksSubscriptionChannel {
    "type"?: string;
}

/**
 * 
 */
export interface SessionRequest {

    /**
     * Generic property bag to store data about the session
     */
    "data"?: { [key: string]: string; };

    /**
     * The feed name or id for the session
     */
    "feed"?: string;

    /**
     * The type of session If a known value is provided, the Data dictionary will be validated for the presence of properties required by that type
     */
    "source"?: string;
}

/**
 * 
 */
export interface SessionResponse {

    /**
     * The unique identifier for the session
     */
    "sessionId"?: string;

    /**
     * The name for the session
     */
    "sessionName"?: string;
}

/**
 * 
 */
export interface SessionToken {

    /**
     * The error message in case of error
     */
    "error"?: string;

    /**
     * This is computed and not returned in Get queries
     */
    "token"?: string;

    /**
     * The expiration date in UTC
     */
    "validTo"?: Date;
    "accessId"?: string;

    /**
     * This is populated when user requests a compact token. The alternate token value is self describing token.
     */
    "alternateToken"?: string;
    "authorizationId"?: string;
    "clientId"?: string;
    "displayName"?: string;
    "hostAuthorizationId"?: string;
    "isPublic"?: boolean;
    "isValid"?: boolean;
    "publicData"?: string;
    "scope"?: string;
    "source"?: string;
    "targetAccounts"?: Array<string>;
    "userId"?: string;
    "validFrom"?: Date;
}

/**
 * An abstracted reference to some other resource. This class is used to provide the build data contracts with a uniform way to reference other resources in a way that provides easy traversal through links.
 */
export interface ShallowReference {

    /**
     * ID of the resource
     */
    "id"?: string;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface ShallowTestCaseResult {
    "automatedTestName"?: string;
    "automatedTestStorage"?: string;
    "durationInMs"?: number;
    "id"?: number;
    "isReRun"?: boolean;
    "outcome"?: string;
    "owner"?: string;
    "priority"?: number;
    "refId"?: number;
    "runId"?: number;
    "tags"?: Array<string>;
    "testCaseTitle"?: string;
}

/**
 * Context used while sharing a pull request.
 */
export interface ShareNotificationContext {

    /**
     * Optional user note or message.
     */
    "message"?: string;

    /**
     * Identities of users who will receive a share notification.
     */
    "receivers"?: Array<IdentityRef>;
}

/**
 * Reference to shared step workitem.
 */
export interface SharedStepModel {

    /**
     * WorkItem shared step ID.
     */
    "id"?: number;

    /**
     * Shared step workitem revision.
     */
    "revision"?: number;
}

/**
 * 
 */
export interface SoapSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * Defines how to sort the result.
 */
export interface SortOption {

    /**
     * Field name on which sorting should be done.
     */
    "field"?: string;

    /**
     * Order (ASC/DESC) in which the results should be sorted.
     */
    "sortOrder"?: string;
}

/**
 * 
 */
export interface SourceIdInput {

    /**
     * ID of source.
     */
    "id"?: string;

    /**
     * Name of the source.
     */
    "name"?: string;
}

/**
 * 
 */
export interface SourceProviderAttributes {

    /**
     * The name of the source provider.
     */
    "name"?: string;

    /**
     * The capabilities supported by this source provider.
     */
    "supportedCapabilities"?: { [key: string]: boolean; };

    /**
     * The types of triggers supported by this source provider.
     */
    "supportedTriggers"?: Array<SupportedTrigger>;
}

/**
 * 
 */
export interface SourcePullRequestVersion {

    /**
     * Pull Request Id for which the release will publish status.
     */
    "pullRequestId"?: string;

    /**
     * Date and time of the pull request merge creation. It is required to keep timeline record of Releases created by pull request.
     */
    "pullRequestMergedAt"?: Date;

    /**
     * Source branch commit Id of the Pull Request for which the release will publish status.
     */
    "sourceBranchCommitId"?: string;

    /**
     * Target branch of the Pull Request.
     */
    "targetBranch"?: string;
}

/**
 * Represents a work item related to some source item. These are retrieved from Source Providers.
 */
export interface SourceRelatedWorkItem {
    "links"?: ReferenceLinks;

    /**
     * Identity ref for the person that the work item is assigned to.
     */
    "assignedTo"?: IdentityRef;

    /**
     * Current state of the work item, e.g. Active, Resolved, Closed, etc.
     */
    "currentState"?: string;

    /**
     * Long description for the work item.
     */
    "description"?: string;

    /**
     * Unique identifier for the work item
     */
    "id"?: string;

    /**
     * The name of the provider the work item is associated with.
     */
    "providerName"?: string;

    /**
     * Short name for the work item.
     */
    "title"?: string;

    /**
     * Type of work item, e.g. Bug, Task, User Story, etc.
     */
    "type"?: string;
}

/**
 * 
 */
export interface SourceRepoTrigger extends ReleaseTriggerBase {
}

/**
 * A set of repositories returned from the source provider.
 */
export interface SourceRepositories {

    /**
     * A token used to continue this paged request; 'null' if the request is complete
     */
    "continuationToken"?: string;

    /**
     * The number of repositories requested for each page
     */
    "pageLength"?: number;

    /**
     * A list of repositories
     */
    "repositories"?: Array<SourceRepository>;

    /**
     * The total number of pages, or '-1' if unknown
     */
    "totalPageCount"?: number;
}

/**
 * Represents a repository returned from a source provider.
 */
export interface SourceRepository {

    /**
     * The name of the default branch.
     */
    "defaultBranch"?: string;

    /**
     * The full name of the repository.
     */
    "fullName"?: string;

    /**
     * The ID of the repository.
     */
    "id"?: string;

    /**
     * The friendly name of the repository.
     */
    "name"?: string;
    "properties"?: { [key: string]: string; };

    /**
     * The name of the source provider the repository is from.
     */
    "sourceProviderName"?: string;

    /**
     * The URL of the repository.
     */
    "url"?: string;
}

/**
 * Represents an item in a repository from a source provider.
 */
export interface SourceRepositoryItem {

    /**
     * Whether the item is able to have sub-items (e.g., is a folder).
     */
    "isContainer"?: boolean;

    /**
     * The full path of the item, relative to the root of the repository.
     */
    "path"?: string;

    /**
     * The type of the item (folder, file, etc).
     */
    "type"?: string;

    /**
     * The URL of the item.
     */
    "url"?: string;
}

/**
 * Source Test Plan information for Test Plan clone operation
 */
export interface SourceTestPlanInfo {

    /**
     * ID of the source Test Plan
     */
    "id"?: number;

    /**
     * Id of suites to be cloned inside source Test Plan
     */
    "suiteIds"?: Array<number>;
}

/**
 * Source Test Suite information for Test Suite clone operation
 */
export interface SourceTestSuiteInfo {

    /**
     * Id of the Source Test Suite
     */
    "id"?: number;
}

/**
 * Source Test Plan Response for Test Plan clone operation
 */
export interface SourceTestplanResponse extends TestPlanReference {
}

/**
 * 
 */
export interface SourceToTargetRef {

    /**
     * The source ref to copy. For example, refs/heads/master.
     */
    "sourceRef"?: string;

    /**
     * The target ref to update. For example, refs/heads/master.
     */
    "targetRef"?: string;
}

/**
 * 
 */
export interface StaticAgentRunSetting {
    "staticAgentGroupName"?: string;
}

/**
 * Real time event (SignalR) for an added status on a pull request
 */
export interface StatusAddedEvent extends RealTimePullRequestEvent {
}

/**
 * Real time event (SignalR) for a status update on a pull request
 */
export interface StatusUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * Real time event (SignalR) for deleted statuses on a pull request
 */
export interface StatusesDeletedEvent extends RealTimePullRequestEvent {
}

/**
 * 
 */
export interface StreamedBatch {
    "continuationToken"?: string;
    "isLastBatch"?: boolean;
    "nextLink"?: string;
    "values"?: Array<string>;
}

/**
 * 
 */
export interface SubType {
    "count"?: number;
    "errorDetailList"?: Array<ErrorDetails>;
    "occurrences"?: number;
    "subTypeName"?: string;
    "url"?: string;
}

/**
 * Encapsulates an event subscription.
 */
export interface Subscription {

    /**
     * Reference Links
     */
    "links"?: ReferenceLinks;
    "actionDescription"?: string;
    "consumerActionId"?: string;
    "consumerId"?: string;

    /**
     * Consumer input values
     */
    "consumerInputs"?: { [key: string]: string; };
    "createdBy"?: IdentityRef;
    "createdDate"?: Date;
    "eventDescription"?: string;
    "eventType"?: string;
    "id"?: string;
    "modifiedBy"?: IdentityRef;
    "modifiedDate"?: Date;
    "probationRetries"?: string;
    "publisherId"?: string;

    /**
     * Publisher input values
     */
    "publisherInputs"?: { [key: string]: string; };
    "resourceVersion"?: string;
    "subscriber"?: IdentityRef;
    "url"?: string;
}

/**
 * Admin-managed settings for a group subscription.
 */
export interface SubscriptionAdminSettings {

    /**
     * If true, members of the group subscribed to the associated subscription cannot opt (choose not to get notified)
     */
    "blockUserOptOut"?: boolean;
}

/**
 * 
 */
export interface SubscriptionChannelWithAddress {
    "address"?: string;
    "type"?: string;
    "useCustomAddress"?: boolean;
}

/**
 * 
 */
export interface SubscriptionDiagnostics {
    "deliveryResults"?: SubscriptionTracing;
    "deliveryTracing"?: SubscriptionTracing;
    "evaluationTracing"?: SubscriptionTracing;
}

/**
 * 
 */
export interface SubscriptionEvaluation {
    "clauses"?: Array<SubscriptionEvaluationClause>;
    "user"?: DiagnosticIdentity;
}

/**
 * 
 */
export interface SubscriptionEvaluationClause {
    "clause"?: string;
    "order"?: number;
    "result"?: boolean;
}

/**
 * Encapsulates the properties of a SubscriptionEvaluationRequest. It defines the subscription to be evaluated and time interval for events used in evaluation.
 */
export interface SubscriptionEvaluationRequest {

    /**
     * The min created date for the events used for matching in UTC. Use all events created since this date
     */
    "minEventsCreatedDate"?: Date;

    /**
     * User or group that will receive notifications for events matching the subscription's filter criteria. If not specified, defaults to the calling user.
     */
    "subscriptionCreateParameters"?: NotificationSubscriptionCreateParameters;
}

/**
 * Ecapsulates the subscription evaluation results. It defines the Date Interval that was used, number of events evaluated and events and notifications results
 */
export interface SubscriptionEvaluationResult {

    /**
     * Subscription evaluation events results.
     */
    "events"?: EventsEvaluationResult;

    /**
     * The requestId which is the subscription evaluation jobId
     */
    "id"?: string;

    /**
     * Subscription evaluation  notification results.
     */
    "notifications"?: NotificationsEvaluationResult;
}

/**
 * Encapsulates the subscription evaluation settings needed for the UI
 */
export interface SubscriptionEvaluationSettings {

    /**
     * Indicates whether subscription evaluation before saving is enabled or not
     */
    "enabled"?: boolean;

    /**
     * Time interval to check on subscription evaluation job in seconds
     */
    "interval"?: number;

    /**
     * Threshold on the number of notifications for considering a subscription too noisy
     */
    "threshold"?: number;

    /**
     * Time out for the subscription evaluation check in seconds
     */
    "timeOut"?: number;
}

/**
 * Encapsulates the properties needed to manage subscriptions, opt in and out of subscriptions.
 */
export interface SubscriptionManagement {
    "serviceInstanceType"?: string;
    "url"?: string;
}

/**
 * Notification subscriptions query input.
 */
export interface SubscriptionQuery {

    /**
     * One or more conditions to query on. If more than 2 conditions are specified, the combined results of each condition is returned (i.e. conditions are logically OR'ed).
     */
    "conditions"?: Array<SubscriptionQueryCondition>;
}

/**
 * Conditions a subscription must match to qualify for the query result set. Not all fields are required. A subscription must match all conditions specified in order to qualify for the result set.
 */
export interface SubscriptionQueryCondition {

    /**
     * Filter conditions that matching subscriptions must have. Typically only the filter's type and event type are used for matching.
     */
    "filter"?: ISubscriptionFilter;

    /**
     * Scope that matching subscriptions must have.
     */
    "scope"?: string;

    /**
     * ID of the subscriber (user or group) that matching subscriptions must be subscribed to.
     */
    "subscriberId"?: string;

    /**
     * ID of the subscription to query for.
     */
    "subscriptionId"?: string;
}

/**
 * A resource, typically an account or project, in which events are published from.
 */
export interface SubscriptionScope extends EventScope {
}

/**
 * 
 */
export interface SubscriptionTraceDiagnosticLog extends NotificationDiagnosticLog {
}

/**
 * 
 */
export interface SubscriptionTraceEventProcessingLog extends SubscriptionTraceDiagnosticLog {
}

/**
 * 
 */
export interface SubscriptionTraceNotificationDeliveryLog extends SubscriptionTraceDiagnosticLog {
}

/**
 * 
 */
export interface SubscriptionTracing {
    "enabled"?: boolean;

    /**
     * Trace until the specified end date.
     */
    "endDate"?: Date;

    /**
     * The maximum number of result details to trace.
     */
    "maxTracedEntries"?: number;

    /**
     * The date and time tracing started.
     */
    "startDate"?: Date;

    /**
     * Trace until remaining count reaches 0.
     */
    "tracedEntries"?: number;
}

/**
 * User-managed settings for a group subscription.
 */
export interface SubscriptionUserSettings {

    /**
     * Indicates whether the user will receive notifications for the associated group subscription.
     */
    "optedOut"?: boolean;
}

/**
 * Defines a query for service hook subscriptions.
 */
export interface SubscriptionsQuery {

    /**
     * Optional consumer action id to restrict the results to (null for any)
     */
    "consumerActionId"?: string;

    /**
     * Optional consumer id to restrict the results to (null for any)
     */
    "consumerId"?: string;

    /**
     * Filter for subscription consumer inputs
     */
    "consumerInputFilters"?: Array<InputFilter>;

    /**
     * Optional event type id to restrict the results to (null for any)
     */
    "eventType"?: string;

    /**
     * Optional publisher id to restrict the results to (null for any)
     */
    "publisherId"?: string;

    /**
     * Filter for subscription publisher inputs
     */
    "publisherInputFilters"?: Array<InputFilter>;

    /**
     * Results from the query
     */
    "results"?: Array<Subscription>;

    /**
     * Optional subscriber filter.
     */
    "subscriberId"?: string;
}

/**
 * Suite create model
 */
export interface SuiteCreateModel {

    /**
     * Name of test suite.
     */
    "name"?: string;

    /**
     * For query based suites, query string that defines the suite.
     */
    "queryString"?: string;

    /**
     * For requirements test suites, the IDs of the requirements.
     */
    "requirementIds"?: Array<number>;

    /**
     * Type of test suite to create. It can have value from DynamicTestSuite, StaticTestSuite and RequirementTestSuite.
     */
    "suiteType"?: string;
}

/**
 * A suite entry defines properties for a test suite.
 */
export interface SuiteEntry extends SuiteEntryUpdateParams {
}

/**
 * A model to define sequence of test suite entries in a test suite.
 */
export interface SuiteEntryUpdateModel {

    /**
     * Id of the child suite in the test suite.
     */
    "childSuiteId"?: number;

    /**
     * Updated sequence number for the test case or child test suite in the test suite.
     */
    "sequenceNumber"?: number;

    /**
     * Id of the test case in the test suite.
     */
    "testCaseId"?: number;
}

/**
 * A suite entry defines properties for a test suite.
 */
export interface SuiteEntryUpdateParams {

    /**
     * Id of the suite entry in the test suite: either a test case id or child suite id.
     */
    "id"?: number;

    /**
     * Sequence number for the suite entry object in the test suite.
     */
    "sequenceNumber"?: number;
}

/**
 * Test case for the suite.
 */
export interface SuiteTestCase {

    /**
     * Point Assignment for test suite's test case.
     */
    "pointAssignments"?: Array<PointAssignment>;

    /**
     * Test case workItem reference.
     */
    "testCase"?: WorkItemReference;
}

/**
 * Create and Update Suite Test Case Parameters
 */
export interface SuiteTestCaseCreateUpdateParameters {

    /**
     * Configurations Ids
     */
    "pointAssignments"?: Array<Configuration>;

    /**
     * Id of Test Case to be updated or created
     */
    "workItem"?: WorkItem;
}

/**
 * Test suite update model.
 */
export interface SuiteTestCaseUpdateModel {

    /**
     * Shallow reference of configurations for the test cases in the suite.
     */
    "configurations"?: Array<ShallowReference>;
}

/**
 * Test suite update model.
 */
export interface SuiteUpdateModel {

    /**
     * Shallow reference of default configurations for the suite.
     */
    "defaultConfigurations"?: Array<ShallowReference>;

    /**
     * Shallow reference of test suite.
     */
    "defaultTesters"?: Array<ShallowReference>;

    /**
     * Specifies if the default configurations have to be inherited from the parent test suite in which the test suite is created.
     */
    "inheritDefaultConfigurations"?: boolean;

    /**
     * Test suite name
     */
    "name"?: string;

    /**
     * Shallow reference of the parent.
     */
    "parent"?: ShallowReference;

    /**
     * For query based suites, the new query string.
     */
    "queryString"?: string;
}

/**
 * 
 */
export interface SummaryData {

    /**
     * Count of Licenses already assigned.
     */
    "assigned"?: number;

    /**
     * Available Count.
     */
    "available"?: number;

    /**
     * Quantity
     */
    "includedQuantity"?: number;

    /**
     * Total Count.
     */
    "total"?: number;
}

/**
 * 
 */
export interface SummaryMailSection {

    /**
     * Html content of summary mail.
     */
    "htmlContent"?: string;

    /**
     * Rank of the summary mail.
     */
    "rank"?: number;

    /**
     * Title of the summary mail.
     */
    "title"?: string;
}

/**
 * 
 */
export interface SummaryPercentileData {
    "percentile"?: number;
    "percentileValue"?: number;
}

/**
 * Information about the extension
 */
export interface SupportedExtension {

    /**
     * Unique Identifier for this extension
     */
    "extension"?: string;

    /**
     * Unique Identifier for this publisher
     */
    "publisher"?: string;

    /**
     * Supported version for this extension
     */
    "version"?: string;
}

/**
 * Represents a Supported IDE entity.
 */
export interface SupportedIde {

    /**
     * The download URL for the IDE.
     */
    "downloadUrl"?: string;

    /**
     * The name of the IDE.
     */
    "name"?: string;

    /**
     * The URL to open the protocol handler for the IDE.
     */
    "protocolHandlerUrl"?: string;

    /**
     * A list of SupportedPlatforms.
     */
    "supportedPlatforms"?: Array<string>;
}

/**
 * 
 */
export interface SupportedTrigger {

    /**
     * The default interval to wait between polls (only relevant when NotificationType is Polling).
     */
    "defaultPollingInterval"?: number;

    /**
     * How the trigger is notified of changes.
     */
    "notificationType"?: string;

    /**
     * The capabilities supported by this trigger.
     */
    "supportedCapabilities"?: any;
}

/**
 * Represents a Subversion mapping entry.
 */
export interface SvnMappingDetails {

    /**
     * The depth.
     */
    "depth"?: number;

    /**
     * Indicates whether to ignore externals.
     */
    "ignoreExternals"?: boolean;

    /**
     * The local path.
     */
    "localPath"?: string;

    /**
     * The revision.
     */
    "revision"?: string;

    /**
     * The server path.
     */
    "serverPath"?: string;
}

/**
 * Represents a subversion workspace.
 */
export interface SvnWorkspace {
    "mappings"?: Array<SvnMappingDetails>;
}

/**
 * 
 */
export interface TCMPropertyBag2 {
    "artifactId"?: number;
    "artifactType"?: number;
    "name"?: string;
    "value"?: string;
}

/**
 * 
 */
export interface TagFilter {

    /**
     * Gets or sets the tag filter pattern.
     */
    "pattern"?: string;
}

/**
 * 
 */
export interface TaskAgent extends TaskAgentReference {
}

/**
 * Provides data necessary for authorizing the agent using OAuth 2.0 authentication flows.
 */
export interface TaskAgentAuthorization {

    /**
     * Gets or sets the endpoint used to obtain access tokens from the configured token service.
     */
    "authorizationUrl"?: string;

    /**
     * Gets or sets the client identifier for this agent.
     */
    "clientId"?: string;

    /**
     * Gets or sets the public key used to verify the identity of this agent.
     */
    "publicKey"?: TaskAgentPublicKey;
}

/**
 * 
 */
export interface TaskAgentCloud {

    /**
     * Gets or sets a AcquireAgentEndpoint using which a request can be made to acquire new agent
     */
    "acquireAgentEndpoint"?: string;
    "acquisitionTimeout"?: number;
    "agentCloudId"?: number;
    "getAgentDefinitionEndpoint"?: string;
    "getAgentRequestStatusEndpoint"?: string;

    /**
     * Signifies that this Agent Cloud is internal and should not be user-manageable
     */
    "internal"?: boolean;
    "name"?: string;
    "releaseAgentEndpoint"?: string;
    "sharedSecret"?: string;

    /**
     * Gets or sets the type of the endpoint.
     */
    "type"?: string;
}

/**
 * 
 */
export interface TaskAgentCloudRequest {
    "agent"?: TaskAgentReference;
    "agentCloudId"?: number;
    "agentConnectedTime"?: Date;
    "agentData"?: JObject;
    "agentSpecification"?: JObject;
    "pool"?: TaskAgentPoolReference;
    "provisionedTime"?: Date;
    "provisionRequestTime"?: Date;
    "releaseRequestTime"?: Date;
    "requestId"?: string;
}

/**
 * 
 */
export interface TaskAgentCloudType {

    /**
     * Gets or sets the display name of agnet cloud type.
     */
    "displayName"?: string;

    /**
     * Gets or sets the input descriptors
     */
    "inputDescriptors"?: Array<InputDescriptor>;

    /**
     * Gets or sets the name of agent cloud type.
     */
    "name"?: string;
}

/**
 * 
 */
export interface TaskAgentDelaySource {
    "delays"?: Array<string>;
    "taskAgent"?: TaskAgentReference;
}

/**
 * 
 */
export interface TaskAgentJobRequest {
    "agentDelays"?: Array<TaskAgentDelaySource>;
    "agentSpecification"?: JObject;
    "assignTime"?: Date;
    "data"?: { [key: string]: string; };
    "definition"?: TaskOrchestrationOwner;
    "demands"?: Array<Demand>;
    "expectedDuration"?: string;
    "finishTime"?: Date;
    "hostId"?: string;
    "jobId"?: string;
    "jobName"?: string;
    "lockedUntil"?: Date;
    "matchedAgents"?: Array<TaskAgentReference>;
    "matchesAllAgentsInPool"?: boolean;
    "orchestrationId"?: string;
    "owner"?: TaskOrchestrationOwner;
    "planGroup"?: string;
    "planId"?: string;
    "planType"?: string;
    "poolId"?: number;
    "queueId"?: number;
    "queueTime"?: Date;
    "receiveTime"?: Date;
    "requestId"?: number;
    "reservedAgent"?: TaskAgentReference;
    "scopeId"?: string;
    "serviceOwner"?: string;
    "statusMessage"?: string;
}

/**
 * 
 */
export interface TaskAgentManualUpdate extends TaskAgentUpdateReason {
}

/**
 * Provides a contract for receiving messages from the task orchestrator.
 */
export interface TaskAgentMessage {

    /**
     * Gets or sets the body of the message. If the <c>IV</c> property is provided the body will need to be decrypted using the <c>TaskAgentSession.EncryptionKey</c> value in addition to the <c>IV</c>.
     */
    "body"?: string;

    /**
     * Gets or sets the intialization vector used to encrypt this message.
     */
    "iv"?: Array<string>;

    /**
     * Gets or sets the message identifier.
     */
    "messageId"?: number;

    /**
     * Gets or sets the message type, describing the data contract found in <c>TaskAgentMessage.Body</c>.
     */
    "messageType"?: string;
}

/**
 * 
 */
export interface TaskAgentMinAgentVersionRequiredUpdate extends TaskAgentUpdateReason {
}

/**
 * 
 */
export interface TaskAgentPool extends TaskAgentPoolReference {
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceDefinition {

    /**
     * Enable maintenance
     */
    "enabled"?: boolean;

    /**
     * Id
     */
    "id"?: number;

    /**
     * Maintenance job timeout per agent
     */
    "jobTimeoutInMinutes"?: number;

    /**
     * Max percentage of agents within a pool running maintenance job at given time
     */
    "maxConcurrentAgentsPercentage"?: number;
    "options"?: TaskAgentPoolMaintenanceOptions;

    /**
     * Pool reference for the maintenance definition
     */
    "pool"?: TaskAgentPoolReference;
    "retentionPolicy"?: TaskAgentPoolMaintenanceRetentionPolicy;
    "scheduleSetting"?: TaskAgentPoolMaintenanceSchedule;
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceJob {

    /**
     * The maintenance definition for the maintenance job
     */
    "definitionId"?: number;

    /**
     * The total error counts during the maintenance job
     */
    "errorCount"?: number;

    /**
     * Time that the maintenance job was completed
     */
    "finishTime"?: Date;

    /**
     * Id of the maintenance job
     */
    "jobId"?: number;

    /**
     * The log download url for the maintenance job
     */
    "logsDownloadUrl"?: string;

    /**
     * Orchestration/Plan Id for the maintenance job
     */
    "orchestrationId"?: string;

    /**
     * Pool reference for the maintenance job
     */
    "pool"?: TaskAgentPoolReference;

    /**
     * Time that the maintenance job was queued
     */
    "queueTime"?: Date;

    /**
     * The identity that queued the maintenance job
     */
    "requestedBy"?: IdentityRef;

    /**
     * Time that the maintenance job was started
     */
    "startTime"?: Date;
    "targetAgents"?: Array<TaskAgentPoolMaintenanceJobTargetAgent>;

    /**
     * The total warning counts during the maintenance job
     */
    "warningCount"?: number;
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceJobTargetAgent {
    "agent"?: TaskAgentReference;
    "jobId"?: number;
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceOptions {

    /**
     * time to consider a System.DefaultWorkingDirectory is stale
     */
    "workingDirectoryExpirationInDays"?: number;
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceRetentionPolicy {

    /**
     * Number of records to keep for maintenance job executed with this definition.
     */
    "numberOfHistoryRecordsToKeep"?: number;
}

/**
 * 
 */
export interface TaskAgentPoolMaintenanceSchedule {

    /**
     * The Job Id of the Scheduled job that will queue the pool maintenance job.
     */
    "scheduleJobId"?: string;

    /**
     * Local timezone hour to start
     */
    "startHours"?: number;

    /**
     * Local timezone minute to start
     */
    "startMinutes"?: number;

    /**
     * Time zone of the build schedule (string representation of the time zone id)
     */
    "timeZoneId"?: string;
}

/**
 * 
 */
export interface TaskAgentPoolReference {

    /**
     * The pool ID.
     */
    "id"?: number;

    /**
     * Gets or sets a value indicating whether or not this pool is managed by the service.
     */
    "isHosted"?: boolean;

    /**
     * The pool name.
     */
    "name"?: string;
    "scope"?: string;

    /**
     * Gets the current size of the pool.
     */
    "size"?: number;
}

/**
 * 
 */
export interface TaskAgentPoolStatus extends TaskAgentPoolReference {
}

/**
 * 
 */
export interface TaskAgentPoolSummary {
    "columnsHeader"?: MetricsColumnsHeader;
    "deploymentGroups"?: Array<DeploymentGroupReference>;
    "pool"?: TaskAgentPoolReference;
    "queues"?: Array<TaskAgentQueue>;
    "rows"?: Array<MetricsRow>;
}

/**
 * Represents the public key portion of an RSA asymmetric key.
 */
export interface TaskAgentPublicKey {

    /**
     * Gets or sets the exponent for the public key.
     */
    "exponent"?: Array<string>;

    /**
     * Gets or sets the modulus for the public key.
     */
    "modulus"?: Array<string>;
}

/**
 * 
 */
export interface TaskAgentQueue {

    /**
     * Id of the queue
     */
    "id"?: number;

    /**
     * Name of the queue
     */
    "name"?: string;

    /**
     * Pool reference for this queue
     */
    "pool"?: TaskAgentPoolReference;

    /**
     * Project Id
     */
    "projectId"?: string;
}

/**
 * 
 */
export interface TaskAgentReference {
    "links"?: ReferenceLinks;

    /**
     * Gets the access point of the agent.
     */
    "accessPoint"?: string;

    /**
     * Gets or sets a value indicating whether or not this agent should be enabled for job execution.
     */
    "enabled"?: boolean;

    /**
     * Gets the identifier of the agent.
     */
    "id"?: number;

    /**
     * Gets the name of the agent.
     */
    "name"?: string;

    /**
     * Gets the OS of the agent.
     */
    "osDescription"?: string;

    /**
     * Gets or sets the current provisioning state of this agent
     */
    "provisioningState"?: string;

    /**
     * Gets the version of the agent.
     */
    "version"?: string;
}

/**
 * Represents a session for performing message exchanges from an agent.
 */
export interface TaskAgentSession {

    /**
     * Gets or sets the agent which is the target of the session.
     */
    "agent"?: TaskAgentReference;

    /**
     * Gets the key used to encrypt message traffic for this session.
     */
    "encryptionKey"?: TaskAgentSessionKey;

    /**
     * Gets or sets the owner name of this session. Generally this will be the machine of origination.
     */
    "ownerName"?: string;

    /**
     * Gets the unique identifier for this session.
     */
    "sessionId"?: string;
    "systemCapabilities"?: { [key: string]: string; };
}

/**
 * Represents a symmetric key used for message-level encryption for communication sent to an agent.
 */
export interface TaskAgentSessionKey {

    /**
     * Gets or sets a value indicating whether or not the key value is encrypted. If this value is true, the Value property should be decrypted using the <c>RSA</c> key exchanged with the server during registration.
     */
    "encrypted"?: boolean;

    /**
     * Gets or sets the symmetric key value.
     */
    "value"?: Array<string>;
}

/**
 * 
 */
export interface TaskAgentUpdate {

    /**
     * The current state of this agent update
     */
    "currentState"?: string;

    /**
     * The reason of this agent update
     */
    "reason"?: TaskAgentUpdateReason;

    /**
     * The identity that request the agent update
     */
    "requestedBy"?: IdentityRef;

    /**
     * Gets the date on which this agent update was requested.
     */
    "requestTime"?: Date;

    /**
     * Gets or sets the source agent version of the agent update
     */
    "sourceVersion"?: PackageVersion;

    /**
     * Gets or sets the target agent version of the agent update
     */
    "targetVersion"?: PackageVersion;
}

/**
 * 
 */
export interface TaskAgentUpdateReason {
}

/**
 * 
 */
export interface TaskAssignedEvent extends TaskEvent {
}

/**
 * 
 */
export interface TaskAttachment {
    "links"?: ReferenceLinks;
    "createdOn"?: Date;
    "lastChangedBy"?: string;
    "lastChangedOn"?: Date;
    "name"?: string;
    "recordId"?: string;
    "timelineId"?: string;
    "type"?: string;
}

/**
 * 
 */
export interface TaskCompletedEvent extends TaskEvent {
}

/**
 * 
 */
export interface TaskDefinition {
    "agentExecution"?: TaskExecution;
    "author"?: string;
    "category"?: string;
    "contentsUploaded"?: boolean;
    "contributionIdentifier"?: string;
    "contributionVersion"?: string;
    "dataSourceBindings"?: Array<DataSourceBinding>;
    "definitionType"?: string;
    "demands"?: Array<Demand>;
    "deprecated"?: boolean;
    "description"?: string;
    "disabled"?: boolean;
    "ecosystem"?: string;
    "execution"?: { [key: string]: JObject; };
    "friendlyName"?: string;
    "groups"?: Array<TaskGroupDefinition>;
    "helpMarkDown"?: string;
    "hostType"?: string;
    "iconUrl"?: string;
    "id"?: string;
    "inputs"?: Array<TaskInputDefinition>;
    "instanceNameFormat"?: string;
    "minimumAgentVersion"?: string;
    "name"?: string;
    "outputVariables"?: Array<TaskOutputVariable>;
    "packageLocation"?: string;
    "packageType"?: string;
    "postJobExecution"?: { [key: string]: JObject; };
    "preJobExecution"?: { [key: string]: JObject; };
    "preview"?: boolean;
    "releaseNotes"?: string;
    "runsOn"?: Array<string>;
    "satisfies"?: Array<string>;
    "serverOwned"?: boolean;
    "showEnvironmentVariables"?: boolean;
    "sourceDefinitions"?: Array<TaskSourceDefinition>;
    "sourceLocation"?: string;
    "version"?: TaskVersion;
    "visibility"?: Array<string>;
}

/**
 * 
 */
export interface TaskDefinitionEndpoint {

    /**
     * An ID that identifies a service connection to be used for authenticating endpoint requests.
     */
    "connectionId"?: string;

    /**
     * An Json based keyselector to filter response returned by fetching the endpoint <c>Url</c>.A Json based keyselector must be prefixed with "jsonpath:". KeySelector can be used to specify the filter to get the keys for the values specified with Selector. <example> The following keyselector defines an Json for extracting nodes named 'ServiceName'. <code> endpoint.KeySelector = "jsonpath://ServiceName"; </code></example>
     */
    "keySelector"?: string;

    /**
     * The scope as understood by Connected Services. Essentialy, a project-id for now.
     */
    "scope"?: string;

    /**
     * An XPath/Json based selector to filter response returned by fetching the endpoint <c>Url</c>. An XPath based selector must be prefixed with the string "xpath:". A Json based selector must be prefixed with "jsonpath:". <example> The following selector defines an XPath for extracting nodes named 'ServiceName'. <code> endpoint.Selector = "xpath://ServiceName"; </code></example>
     */
    "selector"?: string;

    /**
     * TaskId that this endpoint belongs to.
     */
    "taskId"?: string;

    /**
     * URL to GET.
     */
    "url"?: string;
}

/**
 * 
 */
export interface TaskDefinitionReference {

    /**
     * Gets or sets the definition type. Values can be 'task' or 'metaTask'.
     */
    "definitionType"?: string;

    /**
     * Gets or sets the unique identifier of task.
     */
    "id"?: string;

    /**
     * Gets or sets the version specification of task.
     */
    "versionSpec"?: string;
}

/**
 * 
 */
export interface TaskEvent extends JobEvent {
}

/**
 * 
 */
export interface TaskExecution {

    /**
     * The utility task to run.  Specifying this means that this task definition is simply a meta task to call another task. This is useful for tasks that call utility tasks like powershell and commandline
     */
    "execTask"?: TaskReference;

    /**
     * If a task is going to run code, then this provides the type/script etc... information by platform. For example, it might look like. net45: { typeName: "Microsoft.TeamFoundation.Automation.Tasks.PowerShellTask", assemblyName: "Microsoft.TeamFoundation.Automation.Tasks.PowerShell.dll" } net20: { typeName: "Microsoft.TeamFoundation.Automation.Tasks.PowerShellTask", assemblyName: "Microsoft.TeamFoundation.Automation.Tasks.PowerShell.dll" } java: { jar: "powershelltask.tasks.automation.teamfoundation.microsoft.com", } node: { script: "powershellhost.js", }
     */
    "platformInstructions"?: { [key: string]: { [key: string]: string; }; };
}

/**
 * 
 */
export interface TaskGroup extends TaskDefinition {
}

/**
 * 
 */
export interface TaskGroupCreateParameter {

    /**
     * Sets author name of the task group.
     */
    "author"?: string;

    /**
     * Sets category of the task group.
     */
    "category"?: string;

    /**
     * Sets description of the task group.
     */
    "description"?: string;

    /**
     * Sets friendly name of the task group.
     */
    "friendlyName"?: string;

    /**
     * Sets url icon of the task group.
     */
    "iconUrl"?: string;

    /**
     * Sets input for the task group.
     */
    "inputs"?: Array<TaskInputDefinition>;

    /**
     * Sets display name of the task group.
     */
    "instanceNameFormat"?: string;

    /**
     * Sets name of the task group.
     */
    "name"?: string;

    /**
     * Sets parent task group Id. This is used while creating a draft task group.
     */
    "parentDefinitionId"?: string;

    /**
     * Sets RunsOn of the task group. Value can be 'Agent', 'Server' or 'DeploymentGroup'.
     */
    "runsOn"?: Array<string>;

    /**
     * Sets tasks for the task group.
     */
    "tasks"?: Array<TaskGroupStep>;

    /**
     * Sets version of the task group.
     */
    "version"?: TaskVersion;
}

/**
 * 
 */
export interface TaskGroupDefinition {
    "displayName"?: string;
    "isExpanded"?: boolean;
    "name"?: string;
    "tags"?: Array<string>;
    "visibleRule"?: string;
}

/**
 * 
 */
export interface TaskGroupRevision {
    "changedBy"?: IdentityRef;
    "changedDate"?: Date;
    "comment"?: string;
    "fileId"?: number;
    "revision"?: number;
    "taskGroupId"?: string;
}

/**
 * Represents tasks in the task group.
 */
export interface TaskGroupStep {

    /**
     * Gets or sets as 'true' to run the task always, 'false' otherwise.
     */
    "alwaysRun"?: boolean;

    /**
     * Gets or sets condition for the task.
     */
    "condition"?: string;

    /**
     * Gets or sets as 'true' to continue on error, 'false' otherwise.
     */
    "continueOnError"?: boolean;

    /**
     * Gets or sets the display name.
     */
    "displayName"?: string;

    /**
     * Gets or sets as task is enabled or not.
     */
    "enabled"?: boolean;

    /**
     * Gets dictionary of environment variables.
     */
    "environment"?: { [key: string]: string; };

    /**
     * Gets or sets dictionary of inputs.
     */
    "inputs"?: { [key: string]: string; };

    /**
     * Gets or sets the reference of the task.
     */
    "task"?: TaskDefinitionReference;

    /**
     * Gets or sets the maximum time, in minutes, that a task is allowed to execute on agent before being cancelled by server. A zero value indicates an infinite timeout.
     */
    "timeoutInMinutes"?: number;
}

/**
 * 
 */
export interface TaskGroupUpdateParameter {

    /**
     * Sets author name of the task group.
     */
    "author"?: string;

    /**
     * Sets category of the task group.
     */
    "category"?: string;

    /**
     * Sets comment of the task group.
     */
    "comment"?: string;

    /**
     * Sets description of the task group.
     */
    "description"?: string;

    /**
     * Sets friendly name of the task group.
     */
    "friendlyName"?: string;

    /**
     * Sets url icon of the task group.
     */
    "iconUrl"?: string;

    /**
     * Sets the unique identifier of this field.
     */
    "id"?: string;

    /**
     * Sets input for the task group.
     */
    "inputs"?: Array<TaskInputDefinition>;

    /**
     * Sets display name of the task group.
     */
    "instanceNameFormat"?: string;

    /**
     * Sets name of the task group.
     */
    "name"?: string;

    /**
     * Gets or sets parent task group Id. This is used while creating a draft task group.
     */
    "parentDefinitionId"?: string;

    /**
     * Sets revision of the task group.
     */
    "revision"?: number;

    /**
     * Sets RunsOn of the task group. Value can be 'Agent', 'Server' or 'DeploymentGroup'.
     */
    "runsOn"?: Array<string>;

    /**
     * Sets tasks for the task group.
     */
    "tasks"?: Array<TaskGroupStep>;

    /**
     * Sets version of the task group.
     */
    "version"?: TaskVersion;
}

/**
 * 
 */
export interface TaskHubLicenseDetails {
    "enterpriseUsersCount"?: number;
    "failedToReachAllProviders"?: boolean;
    "freeHostedLicenseCount"?: number;
    "freeLicenseCount"?: number;
    "hasLicenseCountEverUpdated"?: boolean;
    "hostedAgentMinutesFreeCount"?: number;
    "hostedAgentMinutesUsedCount"?: number;
    "hostedLicensesArePremium"?: boolean;
    "marketplacePurchasedHostedLicenses"?: Array<MarketplacePurchasedLicense>;
    "msdnUsersCount"?: number;

    /**
     * Microsoft-hosted licenses purchased from VSTS directly.
     */
    "purchasedHostedLicenseCount"?: number;

    /**
     * Self-hosted licenses purchased from VSTS directly.
     */
    "purchasedLicenseCount"?: number;
    "totalHostedLicenseCount"?: number;
    "totalLicenseCount"?: number;
    "totalPrivateLicenseCount"?: number;
}

/**
 * 
 */
export interface TaskInputDefinition extends TaskInputDefinitionBase {
}

/**
 * 
 */
export interface TaskInputDefinitionBase {
    "aliases"?: Array<string>;
    "defaultValue"?: string;
    "groupName"?: string;
    "helpMarkDown"?: string;
    "label"?: string;
    "name"?: string;
    "options"?: { [key: string]: string; };
    "properties"?: { [key: string]: string; };
    "required"?: boolean;
    "type"?: string;
    "validation"?: TaskInputValidation;
    "visibleRule"?: string;
}

/**
 * 
 */
export interface TaskInputValidation {

    /**
     * Conditional expression
     */
    "expression"?: string;

    /**
     * Message explaining how user can correct if validation fails
     */
    "message"?: string;
}

/**
 * 
 */
export interface TaskInstance extends TaskReference {
}

/**
 * 
 */
export interface TaskLog extends TaskLogReference {
}

/**
 * 
 */
export interface TaskLogReference {
    "id"?: number;
    "location"?: string;
}

/**
 * 
 */
export interface TaskOrchestrationContainer extends TaskOrchestrationItem {
}

/**
 * 
 */
export interface TaskOrchestrationItem {
}

/**
 * 
 */
export interface TaskOrchestrationJob extends TaskOrchestrationItem {
}

/**
 * 
 */
export interface TaskOrchestrationOwner {
    "links"?: ReferenceLinks;
    "id"?: number;
    "name"?: string;
}

/**
 * 
 */
export interface TaskOrchestrationPlan extends TaskOrchestrationPlanReference {
}

/**
 * 
 */
export interface TaskOrchestrationPlanGroup {
    "planGroup"?: string;
    "project"?: ProjectReference;
    "runningRequests"?: Array<TaskAgentJobRequest>;
}

/**
 * 
 */
export interface TaskOrchestrationPlanGroupReference {

    /**
     * Gets or sets the plan group.
     */
    "planGroup"?: string;

    /**
     * ID of the Project.
     */
    "projectId"?: string;
}

/**
 * 
 */
export interface TaskOrchestrationPlanGroupsQueueMetrics {
    "count"?: number;
}

/**
 * 
 */
export interface TaskOrchestrationPlanGroupsStartedEvent {
    "planGroups"?: Array<TaskOrchestrationPlanGroupReference>;
}

/**
 * 
 */
export interface TaskOrchestrationPlanReference {

    /**
     * The type of the plan.
     */
    "orchestrationType"?: number;

    /**
     * The ID of the plan.
     */
    "planId"?: string;
    "artifactLocation"?: string;
    "artifactUri"?: string;
    "definition"?: TaskOrchestrationOwner;
    "owner"?: TaskOrchestrationOwner;
    "planGroup"?: string;
    "planType"?: string;
    "scopeIdentifier"?: string;
    "version"?: number;
}

/**
 * 
 */
export interface TaskOrchestrationQueuedPlan {
    "assignTime"?: Date;
    "definition"?: TaskOrchestrationOwner;
    "owner"?: TaskOrchestrationOwner;
    "planGroup"?: string;
    "planId"?: string;
    "poolId"?: number;
    "queuePosition"?: number;
    "queueTime"?: Date;
    "scopeIdentifier"?: string;
}

/**
 * 
 */
export interface TaskOrchestrationQueuedPlanGroup {
    "definition"?: TaskOrchestrationOwner;
    "owner"?: TaskOrchestrationOwner;
    "planGroup"?: string;
    "plans"?: Array<TaskOrchestrationQueuedPlan>;
    "project"?: ProjectReference;
    "queuePosition"?: number;
}

/**
 * 
 */
export interface TaskOutputVariable {
    "description"?: string;
    "name"?: string;
}

/**
 * 
 */
export interface TaskPackageMetadata {

    /**
     * Gets the name of the package.
     */
    "type"?: string;

    /**
     * Gets the url of the package.
     */
    "url"?: string;

    /**
     * Gets the version of the package.
     */
    "version"?: string;
}

/**
 * 
 */
export interface TaskReference {

    /**
     * The ID of the task definition.
     */
    "id"?: string;

    /**
     * The name of the task definition.
     */
    "name"?: string;

    /**
     * The version of the task definition.
     */
    "version"?: string;
    "inputs"?: { [key: string]: string; };
}

/**
 * 
 */
export interface TaskSourceDefinition extends TaskSourceDefinitionBase {
}

/**
 * 
 */
export interface TaskSourceDefinitionBase {
    "authKey"?: string;
    "endpoint"?: string;
    "keySelector"?: string;
    "selector"?: string;
    "target"?: string;
}

/**
 * 
 */
export interface TaskStartedEvent extends TaskEvent {
}

/**
 * 
 */
export interface TaskVersion {
    "isTest"?: boolean;
    "major"?: number;
    "minor"?: number;
    "patch"?: number;
}

/**
 * Mapping of teams to the corresponding work item category
 */
export interface TeamBacklogMapping {
    "categoryReferenceName"?: string;
    "teamId"?: string;
}

/**
 * The Team Context for an operation.
 */
export interface TeamContext {

    /**
     * The team project Id or name.  Ignored if ProjectId is set.
     */
    "project"?: string;

    /**
     * The Team Project ID.  Required if Project is not set.
     */
    "projectId"?: string;

    /**
     * The Team Id or name.  Ignored if TeamId is set.
     */
    "team"?: string;

    /**
     * The Team Id
     */
    "teamId"?: string;
}

/**
 * Represents a single TeamFieldValue
 */
export interface TeamFieldValue {
    "includeChildren"?: boolean;
    "value"?: string;
}

/**
 * Essentially a collection of team field values
 */
export interface TeamFieldValues extends TeamSettingsDataContractBase {
}

/**
 * Expected data from PATCH
 */
export interface TeamFieldValuesPatch {
    "defaultValue"?: string;
    "values"?: Array<TeamFieldValue>;
}

/**
 * 
 */
export interface TeamIterationAttributes {
    "finishDate"?: Date;
    "startDate"?: Date;
}

/**
 * 
 */
export interface TeamMember {
    "identity"?: IdentityRef;
    "isTeamAdmin"?: boolean;
}

/**
 * Represents capacity for a specific team member
 */
export interface TeamMemberCapacity extends TeamSettingsDataContractBase {
}

/**
 * Represents a Team Project object.
 */
export interface TeamProject extends TeamProjectReference {
}

/**
 * Data contract for a TeamProjectCollection.
 */
export interface TeamProjectCollection extends TeamProjectCollectionReference {
}

/**
 * Reference object for a TeamProjectCollection.
 */
export interface TeamProjectCollectionReference {

    /**
     * Collection Id.
     */
    "id"?: string;

    /**
     * Collection Name.
     */
    "name"?: string;

    /**
     * Collection REST Url.
     */
    "url"?: string;
}

/**
 * Represents a shallow reference to a TeamProject.
 */
export interface TeamProjectReference {

    /**
     * Project abbreviation.
     */
    "abbreviation"?: string;

    /**
     * Url to default team identity image.
     */
    "defaultTeamImageUrl"?: string;

    /**
     * The project's description (if any).
     */
    "description"?: string;

    /**
     * Project identifier.
     */
    "id"?: string;

    /**
     * Project last update time.
     */
    "lastUpdateTime"?: Date;

    /**
     * Project name.
     */
    "name"?: string;

    /**
     * Project revision.
     */
    "revision"?: number;

    /**
     * Url to the full version of the object.
     */
    "url"?: string;
}

/**
 * A reference to a team
 */
export interface TeamRef {

    /**
     * Team ID
     */
    "id"?: string;

    /**
     * Team Name
     */
    "name"?: string;
}

/**
 * Data contract for TeamSettings
 */
export interface TeamSetting extends TeamSettingsDataContractBase {
}

/**
 * Base class for TeamSettings data contracts. Anything common goes here.
 */
export interface TeamSettingsDataContractBase {

    /**
     * Collection of links relevant to resource
     */
    "links"?: ReferenceLinks;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface TeamSettingsDaysOff extends TeamSettingsDataContractBase {
}

/**
 * 
 */
export interface TeamSettingsDaysOffPatch {
    "daysOff"?: Array<DateRange>;
}

/**
 * Represents a shallow ref for a single iteration
 */
export interface TeamSettingsIteration extends TeamSettingsDataContractBase {
}

/**
 * Data contract for what we expect to receive when PATCH
 */
export interface TeamSettingsPatch {
    "backlogIteration"?: string;
    "backlogVisibilities"?: { [key: string]: boolean; };
    "defaultIteration"?: string;
    "defaultIterationMacro"?: string;
    "workingDays"?: Array<ERRORUNKNOWN>;
}

/**
 * A data transfer object that stores the metadata associated with the creation of temporary data.
 */
export interface TemporaryDataCreatedDTO extends TemporaryDataDTO {
}

/**
 * A data transfer object that stores the metadata associated with the temporary data.
 */
export interface TemporaryDataDTO {
    "expirationSeconds"?: number;
    "origin"?: string;
    "value"?: any;
}

/**
 * 
 */
export interface TenantDetails {
    "accessDetails"?: Array<AgentGroupAccessData>;
    "id"?: string;
    "staticMachines"?: Array<WebApiTestMachine>;
    "userLoadAgentInput"?: WebApiUserLoadTestMachineInput;
    "userLoadAgentResourcesUri"?: string;
    "validGeoLocations"?: Array<string>;
}

/**
 * 
 */
export interface TestActionResult {
    "actionPath"?: string;
    "comment"?: string;
    "creationDate"?: Date;
    "dateCompleted"?: Date;
    "dateStarted"?: Date;
    "duration"?: number;
    "errorMessage"?: string;
    "id"?: LegacyTestCaseResultIdentifier;
    "iterationId"?: number;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "outcome"?: string;
    "sharedStepId"?: number;
    "sharedStepRevision"?: number;
}

/**
 * 
 */
export interface TestActionResult2 {
    "actionPath"?: string;
    "comment"?: string;
    "creationDate"?: Date;
    "dateCompleted"?: Date;
    "dateStarted"?: Date;
    "duration"?: number;
    "errorMessage"?: string;
    "iterationId"?: number;
    "lastUpdated"?: Date;
    "outcome"?: string;
    "sharedStepId"?: number;
    "sharedStepRevision"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * Represents a test step result.
 */
export interface TestActionResultModel extends TestResultModelBase {
}

/**
 * 
 */
export interface TestAttachment {

    /**
     * Comment associated with attachment.
     */
    "comment"?: string;

    /**
     * Attachment created date.
     */
    "createdDate"?: Date;

    /**
     * Attachment file name
     */
    "fileName"?: string;

    /**
     * ID of the attachment.
     */
    "id"?: number;

    /**
     * Attachment size.
     */
    "size"?: number;

    /**
     * Attachment Url.
     */
    "url"?: string;
}

/**
 * Reference to test attachment.
 */
export interface TestAttachmentReference {

    /**
     * ID of the attachment.
     */
    "id"?: number;

    /**
     * Url to download the attachment.
     */
    "url"?: string;
}

/**
 * Test attachment request model
 */
export interface TestAttachmentRequestModel {

    /**
     * Attachment type By Default it will be GeneralAttachment. It can be one of the following type. { GeneralAttachment, AfnStrip, BugFilingData, CodeCoverage, IntermediateCollectorData, RunConfig, TestImpactDetails, TmiTestRunDeploymentFiles, TmiTestRunReverseDeploymentFiles, TmiTestResultDetail, TmiTestRunSummary }
     */
    "attachmentType"?: string;

    /**
     * Comment associated with attachment
     */
    "comment"?: string;

    /**
     * Attachment filename
     */
    "fileName"?: string;

    /**
     * Base64 encoded file stream
     */
    "stream"?: string;
}

/**
 * 
 */
export interface TestAuthoringDetails {
    "configurationId"?: number;
    "isAutomated"?: boolean;
    "lastUpdated"?: Date;
    "pointId"?: number;
    "priority"?: string;
    "runBy"?: string;
    "suiteId"?: number;
    "testerId"?: string;
}

/**
 * Test Case Class
 */
export interface TestCase {

    /**
     * Reference links
     */
    "links"?: ReferenceLinks;

    /**
     * List of Points associated with the Test Case
     */
    "pointAssignments"?: Array<PointAssignment>;

    /**
     * Project under which the Test Case is
     */
    "project"?: TeamProjectReference;

    /**
     * Test Plan under which the Test Case is
     */
    "testPlan"?: TestPlanReference;

    /**
     * Test Suite under which the Test Case is
     */
    "testSuite"?: TestSuiteReference;

    /**
     * Work Item details of the TestCase
     */
    "workItem"?: WorkItemDetails;
}

/**
 * 
 */
export interface TestCaseMetadata2 {
    "container"?: string;
    "name"?: string;
    "projectId"?: string;
    "testMetadataId"?: number;
}

/**
 * Test Case Reference
 */
export interface TestCaseReference {

    /**
     * Test Case Id
     */
    "id"?: number;

    /**
     * Test Case Name
     */
    "name"?: string;
}

/**
 * 
 */
export interface TestCaseReference2 {
    "areaId"?: number;
    "automatedTestId"?: string;
    "automatedTestName"?: string;
    "automatedTestNameHash"?: Array<string>;
    "automatedTestStorage"?: string;
    "automatedTestStorageHash"?: Array<string>;
    "automatedTestType"?: string;
    "configurationId"?: number;
    "createdBy"?: string;
    "creationDate"?: Date;
    "lastRefTestRunDate"?: Date;
    "owner"?: string;
    "priority"?: string;
    "projectId"?: string;
    "testCaseId"?: number;
    "testCaseRefId"?: number;
    "testCaseRevision"?: number;
    "testCaseTitle"?: string;
    "testPointId"?: number;
}

/**
 * Represents a test result.
 */
export interface TestCaseResult {

    /**
     * Test attachment ID of action recording.
     */
    "afnStripId"?: number;

    /**
     * Reference to area path of test.
     */
    "area"?: ShallowReference;

    /**
     * Reference to bugs linked to test result.
     */
    "associatedBugs"?: Array<ShallowReference>;

    /**
     * ID representing test method in a dll.
     */
    "automatedTestId"?: string;

    /**
     * Fully qualified name of test executed.
     */
    "automatedTestName"?: string;

    /**
     * Container to which test belongs.
     */
    "automatedTestStorage"?: string;

    /**
     * Type of automated test.
     */
    "automatedTestType"?: string;
    "automatedTestTypeId"?: string;

    /**
     * Shallow reference to build associated with test result.
     */
    "build"?: ShallowReference;

    /**
     * Reference to build associated with test result.
     */
    "buildReference"?: BuildReference;

    /**
     * Comment in a test result.
     */
    "comment"?: string;

    /**
     * Time when test execution completed.
     */
    "completedDate"?: Date;

    /**
     * Machine name where test executed.
     */
    "computerName"?: string;

    /**
     * Test configuration of a test result.
     */
    "configuration"?: ShallowReference;

    /**
     * Timestamp when test result created.
     */
    "createdDate"?: Date;

    /**
     * Additional properties of test result.
     */
    "customFields"?: Array<CustomTestField>;

    /**
     * Duration of test execution in milliseconds.
     */
    "durationInMs"?: number;

    /**
     * Error message in test execution.
     */
    "errorMessage"?: string;

    /**
     * Information when test results started failing.
     */
    "failingSince"?: FailingSince;

    /**
     * Failure type of test result.
     */
    "failureType"?: string;

    /**
     * ID of a test result.
     */
    "id"?: number;

    /**
     * Test result details of test iterations.
     */
    "iterationDetails"?: Array<TestIterationDetailsModel>;

    /**
     * Reference to identity last updated test result.
     */
    "lastUpdatedBy"?: IdentityRef;

    /**
     * Last updated datetime of test result.
     */
    "lastUpdatedDate"?: Date;

    /**
     * Test outcome of test result.
     */
    "outcome"?: string;

    /**
     * Reference to test owner.
     */
    "owner"?: IdentityRef;

    /**
     * Priority of test executed.
     */
    "priority"?: number;

    /**
     * Reference to team project.
     */
    "project"?: ShallowReference;

    /**
     * Shallow reference to release associated with test result.
     */
    "release"?: ShallowReference;

    /**
     * Reference to release associated with test result.
     */
    "releaseReference"?: ReleaseReference;
    "resetCount"?: number;

    /**
     * Resolution state of test result.
     */
    "resolutionState"?: string;

    /**
     * ID of resolution state.
     */
    "resolutionStateId"?: number;

    /**
     * Revision number of test result.
     */
    "revision"?: number;

    /**
     * Reference to identity executed the test.
     */
    "runBy"?: IdentityRef;

    /**
     * Stacktrace.
     */
    "stackTrace"?: string;

    /**
     * Time when test execution started.
     */
    "startedDate"?: Date;

    /**
     * State of test result.
     */
    "state"?: string;

    /**
     * List of sub results inside a test result, if ResultGroupType is not None, it holds corresponding type sub results.
     */
    "subResults"?: Array<TestSubResult>;

    /**
     * Reference to the test executed.
     */
    "testCase"?: ShallowReference;

    /**
     * Reference ID of test used by test result.
     */
    "testCaseReferenceId"?: number;

    /**
     * Name of test.
     */
    "testCaseRevision"?: number;

    /**
     * Name of test.
     */
    "testCaseTitle"?: string;

    /**
     * Reference to test plan test case workitem is part of.
     */
    "testPlan"?: ShallowReference;

    /**
     * Reference to the test point executed.
     */
    "testPoint"?: ShallowReference;

    /**
     * Reference to test run.
     */
    "testRun"?: ShallowReference;

    /**
     * Reference to test suite test case workitem is part of.
     */
    "testSuite"?: ShallowReference;

    /**
     * Url of test result.
     */
    "url"?: string;
}

/**
 * Test attachment information in a test iteration.
 */
export interface TestCaseResultAttachmentModel {

    /**
     * Path identifier test step in test case workitem.
     */
    "actionPath"?: string;

    /**
     * Attachment ID.
     */
    "id"?: number;

    /**
     * Iteration ID.
     */
    "iterationId"?: number;

    /**
     * Name of attachment.
     */
    "name"?: string;

    /**
     * Attachment size.
     */
    "size"?: number;

    /**
     * Url to attachment.
     */
    "url"?: string;
}

/**
 * 
 */
export interface TestCaseResultIdAndRev {
    "id"?: LegacyTestCaseResultIdentifier;
    "revision"?: number;
}

/**
 * Reference to a test result.
 */
export interface TestCaseResultIdentifier {

    /**
     * Test result ID.
     */
    "testResultId"?: number;

    /**
     * Test run ID.
     */
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestCaseResultUpdateModel {
    "associatedWorkItems"?: Array<number>;
    "automatedTestTypeId"?: string;
    "comment"?: string;
    "completedDate"?: string;
    "computerName"?: string;
    "customFields"?: Array<CustomTestField>;
    "durationInMs"?: string;
    "errorMessage"?: string;
    "failureType"?: string;
    "outcome"?: string;
    "owner"?: IdentityRef;
    "resolutionState"?: string;
    "runBy"?: IdentityRef;
    "stackTrace"?: string;
    "startedDate"?: string;
    "state"?: string;
    "testCasePriority"?: string;
    "testResult"?: ShallowReference;
}

/**
 * Test configuration
 */
export interface TestConfiguration extends TestConfigurationCreateUpdateParameters {
}

/**
 * Test Configuration Create or Update Parameters
 */
export interface TestConfigurationCreateUpdateParameters {

    /**
     * Description of the configuration
     */
    "description"?: string;

    /**
     * Is the configuration a default for the test plans
     */
    "isDefault"?: boolean;

    /**
     * Name of the configuration
     */
    "name"?: string;

    /**
     * Dictionary of Test Variable, Selected Value
     */
    "values"?: Array<NameValuePair>;
}

/**
 * Test Configuration Reference
 */
export interface TestConfigurationReference {

    /**
     * Id of the configuration
     */
    "id"?: number;

    /**
     * Name of the configuration
     */
    "name"?: string;
}

/**
 * 
 */
export interface TestDefinition extends TestDefinitionBasic {
}

/**
 * 
 */
export interface TestDefinitionBasic {
    "accessData"?: DropAccessData;
    "createdBy"?: string;
    "createdDate"?: Date;
    "id"?: string;
    "lastModifiedBy"?: string;
    "lastModifiedDate"?: Date;
    "name"?: string;
}

/**
 * 
 */
export interface TestDrop {
    "accessData"?: DropAccessData;
    "createdDate"?: Date;
    "dropType"?: string;
    "id"?: string;
    "loadTestDefinition"?: LoadTestDefinition;
    "testRunId"?: string;
}

/**
 * 
 */
export interface TestDropRef {
    "id"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface TestEnvironment {
    "environmentId"?: string;
    "environmentName"?: string;
}

/**
 * 
 */
export interface TestExecutionReportData {
    "reportData"?: Array<DatedTestFieldData>;
}

/**
 * 
 */
export interface TestExtensionField {
    "field"?: TestExtensionFieldDetails;
    "value"?: any;
}

/**
 * 
 */
export interface TestExtensionFieldDetails {
    "id"?: number;
    "isResultScoped"?: boolean;
    "isRunScoped"?: boolean;
    "isSystemField"?: boolean;
    "name"?: string;
}

/**
 * 
 */
export interface TestFailureDetails {
    "count"?: number;
    "testResults"?: Array<TestCaseResultIdentifier>;
}

/**
 * 
 */
export interface TestFailureType {
    "id"?: number;
    "name"?: string;
    "project"?: ShallowReference;
}

/**
 * 
 */
export interface TestFailuresAnalysis {
    "existingFailures"?: TestFailureDetails;
    "fixedTests"?: TestFailureDetails;
    "newFailures"?: TestFailureDetails;
    "previousContext"?: TestResultsContext;
}

/**
 * 
 */
export interface TestFieldData {
    "dimensions"?: { [key: string]: any; };
    "measure"?: number;
}

/**
 * 
 */
export interface TestFieldsEx2 {
    "fieldId"?: number;
    "fieldName"?: string;
    "fieldType"?: string;
    "isResultScoped"?: boolean;
    "isRunScoped"?: boolean;
    "isSystemField"?: boolean;
    "projectId"?: string;
}

/**
 * Filter to get TestCase result history.
 */
export interface TestHistoryQuery {

    /**
     * Automated test name of the TestCase.
     */
    "automatedTestName"?: string;

    /**
     * Results to be get for a particular branches.
     */
    "branch"?: string;

    /**
     * Get the results history only for this BuildDefinationId. This to get used in query GroupBy should be Branch. If this is provided, Branch will have no use.
     */
    "buildDefinitionId"?: number;

    /**
     * It will be filled by server. If not null means there are some results still to be get, and we need to call this REST API with this ContinuousToken. It is not supposed to be created (or altered, if received from server in last batch) by user.
     */
    "continuationToken"?: string;

    /**
     * History to get between time interval MaxCompleteDate and  (MaxCompleteDate - TrendDays). Default is current date time.
     */
    "maxCompleteDate"?: Date;

    /**
     * Get the results history only for this ReleaseEnvDefinitionId. This to get used in query GroupBy should be Environment.
     */
    "releaseEnvDefinitionId"?: number;

    /**
     * List of TestResultHistoryForGroup which are grouped by GroupBy
     */
    "resultsForGroup"?: Array<TestResultHistoryForGroup>;

    /**
     * Get the results history only for this testCaseId. This to get used in query to filter the result along with automatedtestname
     */
    "testCaseId"?: number;

    /**
     * Number of days for which history to collect. Maximum supported value is 7 days. Default is 7 days.
     */
    "trendDays"?: number;
}

/**
 * Represents a test iteration result.
 */
export interface TestIterationDetailsModel {

    /**
     * Test step results in an iteration.
     */
    "actionResults"?: Array<TestActionResultModel>;

    /**
     * Refence to attachments in test iteration result.
     */
    "attachments"?: Array<TestCaseResultAttachmentModel>;

    /**
     * Comment in test iteration result.
     */
    "comment"?: string;

    /**
     * Time when execution completed.
     */
    "completedDate"?: Date;

    /**
     * Duration of execution.
     */
    "durationInMs"?: number;

    /**
     * Error message in test iteration result execution.
     */
    "errorMessage"?: string;

    /**
     * ID of test iteration result.
     */
    "id"?: number;

    /**
     * Test outcome if test iteration result.
     */
    "outcome"?: string;

    /**
     * Test parameters in an iteration.
     */
    "parameters"?: Array<TestResultParameterModel>;

    /**
     * Time when execution started.
     */
    "startedDate"?: Date;

    /**
     * Url to test iteration result.
     */
    "url"?: string;
}

/**
 * Represents Test Log Result object.
 */
export interface TestLog {

    /**
     * Test Log Context run, build
     */
    "logReference"?: TestLogReference;
    "metaData"?: { [key: string]: string; };

    /**
     * LastUpdatedDate for Log file
     */
    "modifiedOn"?: Date;

    /**
     * Size in Bytes for Log file
     */
    "size"?: number;
}

/**
 * 
 */
export interface TestLogReference {

    /**
     * BuildId for test log, if context is build
     */
    "buildId"?: number;

    /**
     * FileName for log file
     */
    "filePath"?: string;

    /**
     * Resultid for test log, if context is run and log is related to result
     */
    "resultId"?: number;

    /**
     * runid for test log, if context is run
     */
    "runId"?: number;

    /**
     * SubResultid for test log, if context is run and log is related to subresult
     */
    "subResultId"?: number;
}

/**
 * Represents Test Log Status object.
 */
export interface TestLogStatus {

    /**
     * Exception message
     */
    "exception"?: string;

    /**
     * Blob Transfer Error code
     */
    "transferFailureType"?: string;
}

/**
 * Represents Test Log store endpoint details.
 */
export interface TestLogStoreEndpointDetails {

    /**
     * Test log store connection Uri.
     */
    "endpointSASUri"?: string;
}

/**
 * 
 */
export interface TestMessageLog2 {
    "testMessageLogId"?: number;
}

/**
 * An abstracted reference to some other resource. This class is used to provide the build data contracts with a uniform way to reference other resources in a way that provides easy traversal through links.
 */
export interface TestMessageLogDetails {

    /**
     * Date when the resource is created
     */
    "dateCreated"?: Date;

    /**
     * Id of the resource
     */
    "entryId"?: number;

    /**
     * Message of the resource
     */
    "message"?: string;
}

/**
 * 
 */
export interface TestMessageLogEntry {
    "dateCreated"?: Date;
    "entryId"?: number;
    "logLevel"?: string;
    "logUser"?: string;
    "logUserName"?: string;
    "message"?: string;
    "testMessageLogId"?: number;
}

/**
 * 
 */
export interface TestMessageLogEntry2 {
    "dateCreated"?: Date;
    "entryId"?: number;
    "logLevel"?: string;
    "logUser"?: string;
    "message"?: string;
    "testMessageLogId"?: number;
}

/**
 * 
 */
export interface TestMethod {
    "container"?: string;
    "name"?: string;
}

/**
 * Class representing a reference to an operation.
 */
export interface TestOperationReference {
    "id"?: string;
    "status"?: string;
    "url"?: string;
}

/**
 * Test outcome settings
 */
export interface TestOutcomeSettings {

    /**
     * Value to configure how test outcomes for the same tests across suites are shown
     */
    "syncOutcomeAcrossSuites"?: boolean;
}

/**
 * 
 */
export interface TestParameter2 {
    "actionPath"?: string;
    "actual"?: Array<string>;
    "creationDate"?: Date;
    "dataType"?: string;
    "dateModified"?: Date;
    "expected"?: Array<string>;
    "iterationId"?: number;
    "parameterName"?: string;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * The test plan resource.
 */
export interface TestPlan extends TestPlanUpdateParams {
}

/**
 * 
 */
export interface TestPlanCloneRequest {
    "destinationTestPlan"?: TestPlan;
    "options"?: CloneOptions;
    "suiteIds"?: Array<number>;
}

/**
 * The test plan cerate parameters.
 */
export interface TestPlanCreateParams {

    /**
     * Area of the test plan.
     */
    "areaPath"?: string;

    /**
     * The Build Definition that generates a build associated with this test plan.
     */
    "buildDefinition"?: BuildDefinitionReference;

    /**
     * Build to be tested.
     */
    "buildId"?: number;

    /**
     * Description of the test plan.
     */
    "description"?: string;

    /**
     * End date for the test plan.
     */
    "endDate"?: Date;

    /**
     * Iteration path of the test plan.
     */
    "iteration"?: string;

    /**
     * Name of the test plan.
     */
    "name"?: string;

    /**
     * Owner of the test plan.
     */
    "owner"?: IdentityRef;

    /**
     * Release Environment to be used to deploy the build and run automated tests from this test plan.
     */
    "releaseEnvironmentDefinition"?: ReleaseEnvironmentDefinitionReference;

    /**
     * Start date for the test plan.
     */
    "startDate"?: Date;

    /**
     * State of the test plan.
     */
    "state"?: string;

    /**
     * Value to configure how same tests across test suites under a test plan need to behave
     */
    "testOutcomeSettings"?: TestOutcomeSettings;
}

/**
 * 
 */
export interface TestPlanHubData {
    "selectedSuiteId"?: number;
    "testPlan"?: TestPlan;
    "testPoints"?: Array<TestPoint>;
    "testSuites"?: Array<TestSuite>;
    "totalTestPoints"?: number;
}

/**
 * The test plan resource.
 */
export interface TestPlanReference {

    /**
     * ID of the test plan.
     */
    "id"?: number;

    /**
     * Name of the test plan.
     */
    "name"?: string;
}

/**
 * The test plan update parameters.
 */
export interface TestPlanUpdateParams extends TestPlanCreateParams {
}

/**
 * 
 */
export interface TestPlansWithSelection {
    "lastSelectedPlan"?: number;
    "lastSelectedSuite"?: number;
    "plans"?: Array<TestPlan>;
}

/**
 * Test Point Class
 */
export interface TestPoint {

    /**
     * AssignedTo. Type IdentityRef.
     */
    "assignedTo"?: IdentityRef;

    /**
     * Automated.
     */
    "automated"?: boolean;

    /**
     * Comment associated to the Test Point
     */
    "comment"?: string;

    /**
     * Configuration associated with the Test Point
     */
    "configuration"?: TestConfigurationReference;

    /**
     * Failure type of test point.
     */
    "failureType"?: string;

    /**
     * Id of the Test Point
     */
    "id"?: number;

    /**
     * Last Reset to Active Time Stamp for the Test Point
     */
    "lastResetToActive"?: Date;

    /**
     * Last resolution state id of test point.
     */
    "lastResolutionStateId"?: number;

    /**
     * Last result of test point. Type ShallowReference.
     */
    "lastResult"?: ShallowReference;

    /**
     * Last result details of test point. Type LastResultDetails.
     */
    "lastResultDetails"?: LastResultDetails;

    /**
     * Last result state of test point.
     */
    "lastResultState"?: string;

    /**
     * LastRun build number of test point.
     */
    "lastRunBuildNumber"?: string;

    /**
     * Last testRun of test point. Type ShallowReference.
     */
    "lastTestRun"?: ShallowReference;

    /**
     * Last Updated details for the Test Point
     */
    "lastUpdatedBy"?: IdentityRef;

    /**
     * Last Update Time Stamp for the Test Point
     */
    "lastUpdatedDate"?: Date;

    /**
     * Outcome of test point.
     */
    "outcome"?: string;

    /**
     * Revision number.
     */
    "revision"?: number;

    /**
     * State of test point.
     */
    "state"?: string;

    /**
     * Suite of test point. Type ShallowReference.
     */
    "suite"?: ShallowReference;

    /**
     * TestCase associated to test point. Type WorkItemReference.
     */
    "testCase"?: WorkItemReference;

    /**
     * Test Plan under which the Test Point is
     */
    "testPlan"?: TestPlanReference;

    /**
     * Test point Url.
     */
    "url"?: string;

    /**
     * Work item properties of test point.
     */
    "workItemProperties"?: Array<any>;

    /**
     * Variable to decide whether the test case is Active or not
     */
    "isActive"?: boolean;

    /**
     * Is the Test Point for Automated Test Case or Manual
     */
    "isAutomated"?: boolean;

    /**
     * Reference links
     */
    "links"?: ReferenceLinks;

    /**
     * Project under which the Test Point is
     */
    "project"?: TeamProjectReference;

    /**
     * Results associated to the Test Point
     */
    "results"?: TestPointResults;

    /**
     * Test Case Reference
     */
    "testCaseReference"?: TestCaseReference;

    /**
     * Tester associated with the Test Point
     */
    "tester"?: IdentityRef;

    /**
     * Test Suite under which the Test Point is
     */
    "testSuite"?: TestSuiteReference;
}

/**
 * 
 */
export interface TestPointReference {
    "id"?: number;
}

/**
 * Test Point Results
 */
export interface TestPointResults {

    /**
     * Last Result Details for the Test Point
     */
    "lastResultDetails"?: LastResultDetails;

    /**
     * Last Result Id
     */
    "lastResultId"?: number;

    /**
     * Last RUn Build Number for the Test Point
     */
    "lastRunBuildNumber"?: string;

    /**
     * Last Test Run Id for the Test Point
     */
    "lastTestRunId"?: number;
}

/**
 * Test Point Update Parameters
 */
export interface TestPointUpdateParams {

    /**
     * Id of Test Point to be updated
     */
    "id"?: number;

    /**
     * Reset the Test Point to Active
     */
    "isActive"?: boolean;

    /**
     * Results of the test point
     */
    "results"?: Results;

    /**
     * Tester of the Test Point
     */
    "tester"?: IdentityRef;
}

/**
 * 
 */
export interface TestPointsEvent {
    "projectName"?: string;
    "testPoints"?: Array<TestPointReference>;
}

/**
 * Test point query class.
 */
export interface TestPointsQuery {

    /**
     * Order by results.
     */
    "orderBy"?: string;

    /**
     * List of test points
     */
    "points"?: Array<TestPoint>;

    /**
     * Filter
     */
    "pointsFilter"?: PointsFilter;

    /**
     * List of workitem fields to get.
     */
    "witFields"?: Array<string>;
}

/**
 * 
 */
export interface TestPointsUpdatedEvent extends TestPointsEvent {
}

/**
 * 
 */
export interface TestResolutionState {
    "id"?: number;
    "name"?: string;
    "project"?: ShallowReference;
}

/**
 * 
 */
export interface TestResult2 {
    "afnStripId"?: number;
    "computerName"?: string;
    "creationDate"?: Date;
    "dateCompleted"?: Date;
    "dateStarted"?: Date;
    "effectivePointState"?: string;
    "failureType"?: string;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "outcome"?: string;
    "owner"?: string;
    "projectId"?: string;
    "resetCount"?: number;
    "resolutionStateId"?: number;
    "revision"?: number;
    "runBy"?: string;
    "state"?: string;
    "testCaseRefId"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestResultAcrossProjectResponse {
    "projectName"?: string;
    "testResult"?: LegacyTestCaseResult;
}

/**
 * 
 */
export interface TestResultAttachment {
    "actionPath"?: string;
    "comment"?: string;
    "creationDate"?: Date;
    "downloadQueryString"?: string;
    "fileName"?: string;
    "id"?: number;
    "isComplete"?: boolean;
    "iterationId"?: number;
    "length"?: number;
    "sessionId"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
    "tmiRunId"?: string;
}

/**
 * 
 */
export interface TestResultAttachmentIdentity {
    "attachmentId"?: number;
    "sessionId"?: number;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestResultCreateModel {
    "area"?: ShallowReference;
    "associatedWorkItems"?: Array<number>;
    "automatedTestId"?: string;
    "automatedTestName"?: string;
    "automatedTestStorage"?: string;
    "automatedTestType"?: string;
    "automatedTestTypeId"?: string;
    "comment"?: string;
    "completedDate"?: string;
    "computerName"?: string;
    "configuration"?: ShallowReference;
    "customFields"?: Array<CustomTestField>;
    "durationInMs"?: string;
    "errorMessage"?: string;
    "failureType"?: string;
    "outcome"?: string;
    "owner"?: IdentityRef;
    "resolutionState"?: string;
    "runBy"?: IdentityRef;
    "stackTrace"?: string;
    "startedDate"?: string;
    "state"?: string;
    "testCase"?: ShallowReference;
    "testCasePriority"?: string;
    "testCaseTitle"?: string;
    "testPoint"?: ShallowReference;
}

/**
 * 
 */
export interface TestResultDocument {
    "operationReference"?: TestOperationReference;
    "payload"?: TestResultPayload;
}

/**
 * 
 */
export interface TestResultHistory {
    "groupByField"?: string;
    "resultsForGroup"?: Array<TestResultHistoryDetailsForGroup>;
}

/**
 * 
 */
export interface TestResultHistoryDetailsForGroup {
    "groupByValue"?: any;
    "latestResult"?: TestCaseResult;
}

/**
 * List of test results filtered on the basis of GroupByValue
 */
export interface TestResultHistoryForGroup {

    /**
     * Display name of the group.
     */
    "displayName"?: string;

    /**
     * Name or Id of the group identifier by which results are grouped together.
     */
    "groupByValue"?: string;

    /**
     * List of results for GroupByValue
     */
    "results"?: Array<TestCaseResult>;
}

/**
 * Represents a Meta Data of a test result.
 */
export interface TestResultMetaData {

    /**
     * AutomatedTestName of test result.
     */
    "automatedTestName"?: string;

    /**
     * AutomatedTestStorage of test result.
     */
    "automatedTestStorage"?: string;

    /**
     * Owner of test result.
     */
    "owner"?: string;

    /**
     * Priority of test result.
     */
    "priority"?: number;

    /**
     * ID of TestCaseReference.
     */
    "testCaseReferenceId"?: number;

    /**
     * TestCaseTitle of test result.
     */
    "testCaseTitle"?: string;
}

/**
 * 
 */
export interface TestResultModelBase {

    /**
     * Comment in result.
     */
    "comment"?: string;

    /**
     * Time when execution completed.
     */
    "completedDate"?: Date;

    /**
     * Duration of execution.
     */
    "durationInMs"?: number;

    /**
     * Error message in result.
     */
    "errorMessage"?: string;

    /**
     * Test outcome of result.
     */
    "outcome"?: string;

    /**
     * Time when execution started.
     */
    "startedDate"?: Date;
}

/**
 * 
 */
export interface TestResultParameter {
    "actionPath"?: string;
    "actual"?: Array<string>;
    "expected"?: Array<string>;
    "iterationId"?: number;
    "parameterName"?: string;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * Test parameter information in a test iteration.
 */
export interface TestResultParameterModel {

    /**
     * Test step path where parameter is referenced.
     */
    "actionPath"?: string;

    /**
     * Iteration ID.
     */
    "iterationId"?: number;

    /**
     * Name of parameter.
     */
    "parameterName"?: string;

    /**
     * This is step Id of test case. For shared step, it is step Id of shared step in test case workitem; step Id in shared step. Example: TestCase workitem has two steps: 1) Normal step with Id = 1 2) Shared Step with Id = 2. Inside shared step: a) Normal Step with Id = 1 Value for StepIdentifier for First step: "1" Second step: "2;1"
     */
    "stepIdentifier"?: string;

    /**
     * Url of test parameter.
     */
    "url"?: string;

    /**
     * Value of parameter.
     */
    "value"?: string;
}

/**
 * 
 */
export interface TestResultPayload {
    "comment"?: string;
    "name"?: string;
    "stream"?: string;
}

/**
 * 
 */
export interface TestResultReset2 {
    "auditIdentity"?: string;
    "dateModified"?: Date;
    "projectId"?: string;
    "revision"?: number;
    "testResultId"?: number;
    "testResultRV"?: Array<string>;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestResultSummary {
    "aggregatedResultsAnalysis"?: AggregatedResultsAnalysis;
    "noConfigRunsCount"?: number;
    "teamProject"?: TeamProjectReference;
    "testFailures"?: TestFailuresAnalysis;
    "testResultsContext"?: TestResultsContext;
    "totalRunsCount"?: number;
}

/**
 * 
 */
export interface TestResultTrendFilter {
    "branchNames"?: Array<string>;
    "buildCount"?: number;
    "definitionIds"?: Array<number>;
    "envDefinitionIds"?: Array<number>;
    "maxCompleteDate"?: Date;
    "publishContext"?: string;
    "testRunTitles"?: Array<string>;
    "trendDays"?: number;
}

/**
 * 
 */
export interface TestResults {
    "cloudLoadTestSolutionUrl"?: string;
    "counterGroups"?: Array<CounterGroup>;
    "diagnostics"?: Diagnostics;
    "resultsUrl"?: string;
}

/**
 * 
 */
export interface TestResultsContext {
    "build"?: BuildReference;
    "release"?: ReleaseReference;
}

/**
 * 
 */
export interface TestResultsDetails {
    "groupByField"?: string;
    "resultsForGroup"?: Array<TestResultsDetailsForGroup>;
}

/**
 * 
 */
export interface TestResultsDetailsForGroup {
    "groupByValue"?: any;
    "results"?: Array<TestCaseResult>;
    "resultsCountByOutcome"?: { [key: string]: AggregatedResultsByOutcome; };
    "tags"?: Array<string>;
}

/**
 * 
 */
export interface TestResultsEx2 {
    "bitValue"?: boolean;
    "creationDate"?: Date;
    "dateTimeValue"?: Date;
    "fieldId"?: number;
    "fieldName"?: string;
    "floatValue"?: number;
    "guidValue"?: string;
    "intValue"?: number;
    "projectId"?: string;
    "stringValue"?: string;
    "testResultId"?: number;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestResultsGroupsForBuild {

    /**
     * BuildId for which groupby result is fetched.
     */
    "buildId"?: number;

    /**
     * The group by results
     */
    "fields"?: Array<FieldDetailsForTestResults>;
}

/**
 * 
 */
export interface TestResultsGroupsForRelease {

    /**
     * The group by results
     */
    "fields"?: Array<FieldDetailsForTestResults>;

    /**
     * Release Environment Id for which groupby result is fetched.
     */
    "releaseEnvId"?: number;

    /**
     * ReleaseId for which groupby result is fetched.
     */
    "releaseId"?: number;
}

/**
 * 
 */
export interface TestResultsQuery {
    "fields"?: Array<string>;
    "results"?: Array<TestCaseResult>;
    "resultsFilter"?: ResultsFilter;
}

/**
 * 
 */
export interface TestResultsSummary {
    "overallPageSummary"?: PageSummary;
    "overallRequestSummary"?: RequestSummary;
    "overallScenarioSummary"?: ScenarioSummary;
    "overallTestSummary"?: TestSummary;
    "overallTransactionSummary"?: TransactionSummary;
    "topSlowPages"?: Array<PageSummary>;
    "topSlowRequests"?: Array<RequestSummary>;
    "topSlowTests"?: Array<TestSummary>;
    "topSlowTransactions"?: Array<TransactionSummary>;
}

/**
 * Test run details.
 */
export interface TestRun extends TestRunBasic {
}

/**
 * 
 */
export interface TestRun2 {
    "buildConfigurationId"?: number;
    "buildNumber"?: string;
    "comment"?: string;
    "completeDate"?: Date;
    "controller"?: string;
    "coverageId"?: number;
    "creationDate"?: Date;
    "deletedOn"?: Date;
    "dropLocation"?: string;
    "dueDate"?: Date;
    "errorMessage"?: string;
    "incompleteTests"?: number;
    "isAutomated"?: boolean;
    "isBvt"?: boolean;
    "isMigrated"?: boolean;
    "iterationId"?: number;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "legacySharePath"?: string;
    "maxReservedResultId"?: number;
    "notApplicableTests"?: number;
    "owner"?: string;
    "passedTests"?: number;
    "postProcessState"?: string;
    "projectId"?: string;
    "publicTestSettingsId"?: number;
    "releaseEnvironmentUri"?: string;
    "releaseUri"?: string;
    "revision"?: number;
    "startDate"?: Date;
    "state"?: string;
    "testEnvironmentId"?: string;
    "testMessageLogId"?: number;
    "testPlanId"?: number;
    "testRunContextId"?: number;
    "testRunId"?: number;
    "testSettingsId"?: number;
    "title"?: string;
    "totalTests"?: number;
    "type"?: string;
    "unanalyzedTests"?: number;
    "version"?: number;
}

/**
 * 
 */
export interface TestRunAbortMessage {
    "action"?: string;
    "cause"?: string;
    "details"?: Array<string>;
    "loggedDate"?: Date;
    "source"?: string;
}

/**
 * 
 */
export interface TestRunBasic {
    "createdBy"?: string;
    "createdDate"?: Date;
    "deletedBy"?: string;
    "deletedDate"?: Date;
    "finishedDate"?: Date;
    "id"?: string;
    "loadGenerationGeoLocations"?: Array<LoadGenerationGeoLocation>;
    "loadTestFileName"?: string;
    "name"?: string;
    "runNumber"?: number;
    "runSource"?: string;
    "runSpecificDetails"?: LoadTestRunDetails;
    "url"?: string;
}

/**
 * 
 */
export interface TestRunCanceledEvent extends TestRunEvent {
}

/**
 * 
 */
export interface TestRunContext2 {
    "buildRefId"?: number;
    "projectId"?: string;
    "releaseRefId"?: number;
    "sourceWorkflow"?: string;
    "testRunContextId"?: number;
}

/**
 * 
 */
export interface TestRunCounterInstance {
    "categoryName"?: string;
    "counterInstanceId"?: string;
    "counterName"?: string;
    "counterUnits"?: string;
    "instanceName"?: string;
    "isPreselectedCounter"?: boolean;
    "machineName"?: string;
    "partOfCounterGroups"?: Array<string>;
    "summaryData"?: WebInstanceSummaryData;
    "uniqueName"?: string;
}

/**
 * Test Run Code Coverage Details
 */
export interface TestRunCoverage {

    /**
     * Last Error
     */
    "lastError"?: string;

    /**
     * List of Modules Coverage
     */
    "modules"?: Array<ModuleCoverage>;

    /**
     * State
     */
    "state"?: string;

    /**
     * Reference of test Run.
     */
    "testRun"?: ShallowReference;
}

/**
 * 
 */
export interface TestRunCreatedEvent extends TestRunEvent {
}

/**
 * 
 */
export interface TestRunEvent {
    "testRun"?: TestRun;
}

/**
 * 
 */
export interface TestRunEx2 {
    "bitValue"?: boolean;
    "createdDate"?: Date;
    "dateTimeValue"?: Date;
    "fieldId"?: number;
    "fieldName"?: string;
    "floatValue"?: number;
    "guidValue"?: string;
    "intValue"?: number;
    "projectId"?: string;
    "stringValue"?: string;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestRunExtended2 {
    "autEnvironmentUrl"?: string;
    "csmContent"?: string;
    "csmParameters"?: string;
    "projectId"?: string;
    "sourceFilter"?: string;
    "subscriptionName"?: string;
    "substate"?: string;
    "testCaseFilter"?: string;
    "testEnvironmentUrl"?: string;
    "testRunId"?: number;
}

/**
 * 
 */
export interface TestRunMessage {
    "agentId"?: string;
    "errorCode"?: string;
    "loggedDate"?: Date;
    "message"?: string;
    "messageId"?: string;
    "testRunId"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface TestRunStartedEvent extends TestRunEvent {
}

/**
 * Test run statistics.
 */
export interface TestRunStatistic {
    "run"?: ShallowReference;
    "runStatistics"?: Array<RunStatistic>;
}

/**
 * 
 */
export interface TestRunSummary2 {
    "isRerun"?: boolean;
    "projectId"?: string;
    "resultCount"?: number;
    "resultDuration"?: number;
    "runDuration"?: number;
    "testOutcome"?: string;
    "testRunCompletedDate"?: Date;
    "testRunContextId"?: number;
    "testRunId"?: number;
    "testRunStatsId"?: number;
}

/**
 * 
 */
export interface TestRunWithDtlEnvEvent extends TestRunEvent {
}

/**
 * Test Session
 */
export interface TestSession {

    /**
     * Area path of the test session
     */
    "area"?: ShallowReference;

    /**
     * Comments in the test session
     */
    "comment"?: string;

    /**
     * Duration of the session
     */
    "endDate"?: Date;

    /**
     * Id of the test session
     */
    "id"?: number;

    /**
     * Last Updated By  Reference
     */
    "lastUpdatedBy"?: IdentityRef;

    /**
     * Last updated date
     */
    "lastUpdatedDate"?: Date;

    /**
     * Owner of the test session
     */
    "owner"?: IdentityRef;

    /**
     * Project to which the test session belongs
     */
    "project"?: ShallowReference;

    /**
     * Generic store for test session data
     */
    "propertyBag"?: PropertyBag;

    /**
     * Revision of the test session
     */
    "revision"?: number;

    /**
     * Start date
     */
    "startDate"?: Date;

    /**
     * Title of the test session
     */
    "title"?: string;

    /**
     * Url of Test Session Resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface TestSessionExploredWorkItemReference extends TestSessionWorkItemReference {
}

/**
 * 
 */
export interface TestSessionWorkItemReference {

    /**
     * Id of the workitem
     */
    "id"?: number;

    /**
     * Type of the workitem
     */
    "type"?: string;
}

/**
 * Represents the test settings of the run. Used to create test settings and fetch test settings
 */
export interface TestSettings {
    "cleanupCommand"?: string;
    "setupCommand"?: string;

    /**
     * Area path required to create test settings
     */
    "areaPath"?: string;

    /**
     * Description of the test settings. Used in create test settings.
     */
    "description"?: string;

    /**
     * Indicates if the tests settings is public or private.Used in create test settings.
     */
    "isPublic"?: boolean;

    /**
     * Xml string of machine roles. Used in create test settings.
     */
    "machineRoles"?: string;

    /**
     * Test settings content.
     */
    "testSettingsContent"?: string;

    /**
     * Test settings id.
     */
    "testSettingsId"?: number;

    /**
     * Test settings name.
     */
    "testSettingsName"?: string;
}

/**
 * Represents the test settings of the run. Used to create test settings and fetch test settings
 */
export interface TestSettings2 {

    /**
     * Area path required to create test settings
     */
    "areaPath"?: string;
    "createdBy"?: IdentityRef;
    "createdDate"?: Date;

    /**
     * Description of the test settings. Used in create test settings.
     */
    "description"?: string;

    /**
     * Indicates if the tests settings is public or private.Used in create test settings.
     */
    "isPublic"?: boolean;
    "lastUpdatedBy"?: IdentityRef;
    "lastUpdatedDate"?: Date;

    /**
     * Xml string of machine roles. Used in create test settings.
     */
    "machineRoles"?: string;

    /**
     * Test settings content.
     */
    "testSettingsContent"?: string;

    /**
     * Test settings id.
     */
    "testSettingsId"?: number;

    /**
     * Test settings name.
     */
    "testSettingsName"?: string;
}

/**
 * 
 */
export interface TestSettingsMachineRole {
    "isExecution"?: boolean;
    "name"?: string;
}

/**
 * Represents a sub result of a test result.
 */
export interface TestSubResult {

    /**
     * Comment in sub result.
     */
    "comment"?: string;

    /**
     * Time when test execution completed.
     */
    "completedDate"?: Date;

    /**
     * Machine where test executed.
     */
    "computerName"?: string;

    /**
     * Reference to test configuration.
     */
    "configuration"?: ShallowReference;

    /**
     * Additional properties of sub result.
     */
    "customFields"?: Array<CustomTestField>;

    /**
     * Name of sub result.
     */
    "displayName"?: string;

    /**
     * Duration of test execution.
     */
    "durationInMs"?: number;

    /**
     * Error message in sub result.
     */
    "errorMessage"?: string;

    /**
     * ID of sub result.
     */
    "id"?: number;

    /**
     * Time when result last updated.
     */
    "lastUpdatedDate"?: Date;

    /**
     * Outcome of sub result.
     */
    "outcome"?: string;

    /**
     * Immediate parent ID of sub result.
     */
    "parentId"?: number;

    /**
     * Index number of sub result.
     */
    "sequenceId"?: number;

    /**
     * Stacktrace.
     */
    "stackTrace"?: string;

    /**
     * Time when test execution started.
     */
    "startedDate"?: Date;

    /**
     * List of sub results inside a sub result, if ResultGroupType is not None, it holds corresponding type sub results.
     */
    "subResults"?: Array<TestSubResult>;

    /**
     * Reference to test result.
     */
    "testResult"?: TestCaseResultIdentifier;

    /**
     * Url of sub result.
     */
    "url"?: string;
}

/**
 * Test suite
 */
export interface TestSuite extends TestSuiteCreateParams {
}

/**
 * Test suite clone request
 */
export interface TestSuiteCloneRequest {

    /**
     * Clone options for cloning the test suite.
     */
    "cloneOptions"?: CloneOptions;

    /**
     * Suite id under which, we have to clone the suite.
     */
    "destinationSuiteId"?: number;

    /**
     * Destination suite project name.
     */
    "destinationSuiteProjectName"?: string;
}

/**
 * Test suite Create Parameters
 */
export interface TestSuiteCreateParams extends TestSuiteCreateUpdateCommonParams {
}

/**
 * Test Suite Create/Update Common Parameters
 */
export interface TestSuiteCreateUpdateCommonParams {

    /**
     * Test suite default configurations.
     */
    "defaultConfigurations"?: Array<TestConfigurationReference>;

    /**
     * Test suite default testers.
     */
    "defaultTesters"?: Array<IdentityRef>;

    /**
     * Default configuration was inherited or not.
     */
    "inheritDefaultConfigurations"?: boolean;

    /**
     * Name of test suite.
     */
    "name"?: string;

    /**
     * Test suite parent shallow reference.
     */
    "parentSuite"?: TestSuiteReference;

    /**
     * Test suite query string, for dynamic suites.
     */
    "queryString"?: string;
}

/**
 * The test suite reference resource.
 */
export interface TestSuiteReference {

    /**
     * ID of the test suite.
     */
    "id"?: number;

    /**
     * Name of the test suite.
     */
    "name"?: string;
}

/**
 * Test Suite Reference with Project
 */
export interface TestSuiteReferenceWithProject extends TestSuiteReference {
}

/**
 * Test Suite Update Parameters
 */
export interface TestSuiteUpdateParams extends TestSuiteCreateUpdateCommonParams {
}

/**
 * 
 */
export interface TestSummary {
    "averageTestTime"?: number;
    "failedTests"?: number;
    "passedTests"?: number;
    "percentileData"?: Array<SummaryPercentileData>;
    "scenarioName"?: string;
    "testName"?: string;
    "totalTests"?: number;
}

/**
 * 
 */
export interface TestSummaryForWorkItem {
    "summary"?: AggregatedDataForResultTrend;
    "workItem"?: WorkItemReference;
}

/**
 * 
 */
export interface TestToWorkItemLinks {
    "test"?: TestMethod;
    "workItems"?: Array<WorkItemReference>;
}

/**
 * Test Variable
 */
export interface TestVariable extends TestVariableCreateUpdateParameters {
}

/**
 * Test Variable Create or Update Parameters
 */
export interface TestVariableCreateUpdateParameters {

    /**
     * Description of the test variable
     */
    "description"?: string;

    /**
     * Name of the test variable
     */
    "name"?: string;

    /**
     * List of allowed values
     */
    "values"?: Array<string>;
}

/**
 * 
 */
export interface TfvcArtifactDownloadInput extends ArtifactDownloadInputBase {
}

/**
 * 
 */
export interface TfvcBranch extends TfvcBranchRef {
}

/**
 * 
 */
export interface TfvcBranchMapping {

    /**
     * Depth of the branch.
     */
    "depth"?: string;

    /**
     * Server item for the branch.
     */
    "serverItem"?: string;

    /**
     * Type of the branch.
     */
    "type"?: string;
}

/**
 * 
 */
export interface TfvcBranchRef extends TfvcShallowBranchRef {
}

/**
 * 
 */
export interface TfvcChange extends Change {
}

export namespace TfvcChange {
}
/**
 * 
 */
export interface TfvcChangeset extends TfvcChangesetRef {
}

/**
 * 
 */
export interface TfvcChangesetRef {

    /**
     * A collection of REST reference links.
     */
    "links"?: ReferenceLinks;

    /**
     * Alias or display name of user
     */
    "author"?: IdentityRef;

    /**
     * Id of the changeset.
     */
    "changesetId"?: number;

    /**
     * Alias or display name of user
     */
    "checkedInBy"?: IdentityRef;

    /**
     * Comment for the changeset.
     */
    "comment"?: string;

    /**
     * Was the Comment result truncated?
     */
    "commentTruncated"?: boolean;

    /**
     * Creation date of the changeset.
     */
    "createdDate"?: Date;

    /**
     * URL to retrieve the item.
     */
    "url"?: string;
}

/**
 * Criteria used in a search for change lists
 */
export interface TfvcChangesetSearchCriteria {

    /**
     * Alias or display name of user who made the changes
     */
    "author"?: string;

    /**
     * Whether or not to follow renames for the given item being queried
     */
    "followRenames"?: boolean;

    /**
     * If provided, only include changesets created after this date (string) Think of a better name for this.
     */
    "fromDate"?: string;

    /**
     * If provided, only include changesets after this changesetID
     */
    "fromId"?: number;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;

    /**
     * Path of item to search under
     */
    "itemPath"?: string;
    "mappings"?: Array<TfvcMappingFilter>;

    /**
     * If provided, only include changesets created before this date (string) Think of a better name for this.
     */
    "toDate"?: string;

    /**
     * If provided, a version descriptor for the latest change list to include
     */
    "toId"?: number;
}

/**
 * 
 */
export interface TfvcChangesetsRequestData {

    /**
     * List of changeset Ids.
     */
    "changesetIds"?: Array<number>;

    /**
     * Length of the comment.
     */
    "commentLength"?: number;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;
}

/**
 * 
 */
export interface TfvcCheckinEventData {
    "changeset"?: TfvcChangeset;
    "project"?: TeamProjectReference;
}

/**
 * 
 */
export interface TfvcHistoryEntry extends HistoryEntry {
}

/**
 * 
 */
export interface TfvcItem extends ItemModel {
}

/**
 * Item path and Version descriptor properties
 */
export interface TfvcItemDescriptor {
    "path"?: string;
    "version"?: string;
}

/**
 * 
 */
export interface TfvcItemPreviousHash extends TfvcItem {
}

/**
 * 
 */
export interface TfvcItemRequestData {

    /**
     * If true, include metadata about the file type
     */
    "includeContentMetadata"?: boolean;

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;
    "itemDescriptors"?: Array<TfvcItemDescriptor>;
}

/**
 * 
 */
export interface TfvcLabel extends TfvcLabelRef {
}

/**
 * 
 */
export interface TfvcLabelRef {
    "links"?: ReferenceLinks;
    "description"?: string;
    "id"?: number;
    "labelScope"?: string;
    "modifiedDate"?: Date;
    "name"?: string;
    "owner"?: IdentityRef;
    "url"?: string;
}

/**
 * 
 */
export interface TfvcLabelRequestData {

    /**
     * Whether to include the _links field on the shallow references
     */
    "includeLinks"?: boolean;
    "itemLabelFilter"?: string;
    "labelScope"?: string;
    "maxItemCount"?: number;
    "name"?: string;
    "owner"?: string;
}

/**
 * 
 */
export interface TfvcMappingFilter {
    "exclude"?: boolean;
    "serverPath"?: string;
}

/**
 * 
 */
export interface TfvcMergeSource {

    /**
     * Indicates if this a rename source. If false, it is a merge source.
     */
    "isRename"?: boolean;

    /**
     * The server item of the merge source
     */
    "serverItem"?: string;

    /**
     * Start of the version range
     */
    "versionFrom"?: number;

    /**
     * End of the version range
     */
    "versionTo"?: number;
}

/**
 * 
 */
export interface TfvcPolicyFailureInfo {
    "message"?: string;
    "policyName"?: string;
}

/**
 * 
 */
export interface TfvcPolicyOverrideInfo {
    "comment"?: string;
    "policyFailures"?: Array<TfvcPolicyFailureInfo>;
}

/**
 * 
 */
export interface TfvcShallowBranchRef {

    /**
     * Path for the branch.
     */
    "path"?: string;
}

/**
 * This is the deep shelveset class
 */
export interface TfvcShelveset extends TfvcShelvesetRef {
}

/**
 * This is the shallow shelveset class
 */
export interface TfvcShelvesetRef {
    "links"?: ReferenceLinks;
    "comment"?: string;
    "commentTruncated"?: boolean;
    "createdDate"?: Date;
    "id"?: string;
    "name"?: string;
    "owner"?: IdentityRef;
    "url"?: string;
}

/**
 * 
 */
export interface TfvcShelvesetRequestData {

    /**
     * Whether to include policyOverride and notes Only applies when requesting a single deep shelveset
     */
    "includeDetails"?: boolean;

    /**
     * Whether to include the _links field on the shallow references. Does not apply when requesting a single deep shelveset object. Links will always be included in the deep shelveset.
     */
    "includeLinks"?: boolean;

    /**
     * Whether to include workItems
     */
    "includeWorkItems"?: boolean;

    /**
     * Max number of changes to include
     */
    "maxChangeCount"?: number;

    /**
     * Max length of comment
     */
    "maxCommentLength"?: number;

    /**
     * Shelveset's name
     */
    "name"?: string;

    /**
     * Owner's ID. Could be a name or a guid.
     */
    "owner"?: string;
}

/**
 * 
 */
export interface TfvcStatistics {

    /**
     * Id of the last changeset the stats are based on.
     */
    "changesetId"?: number;

    /**
     * Count of files at the requested scope.
     */
    "fileCountTotal"?: number;
}

/**
 * 
 */
export interface TfvcVersionDescriptor {
    "version"?: string;
}

/**
 * 
 */
export interface TimeZone {

    /**
     * Display name of the time zone.
     */
    "displayName"?: string;

    /**
     * Id of the time zone.
     */
    "id"?: string;
}

/**
 * 
 */
export interface TimeZoneList {

    /**
     * UTC timezone.
     */
    "utcTimeZone"?: TimeZone;

    /**
     * List of valid timezones.
     */
    "validTimeZones"?: Array<TimeZone>;
}

/**
 * 
 */
export interface Timeline extends TimelineReference {
}

/**
 * 
 */
export interface TimelineAttempt {

    /**
     * Gets or sets the attempt of the record.
     */
    "attempt"?: number;

    /**
     * Gets or sets the record identifier located within the specified timeline.
     */
    "recordId"?: string;

    /**
     * Gets or sets the timeline identifier which owns the record representing this attempt.
     */
    "timelineId"?: string;

    /**
     * Gets or sets the unique identifier for the record.
     */
    "identifier"?: string;
}

/**
 * 
 */
export interface TimelineCriteriaStatus {
    "message"?: string;
}

/**
 * 
 */
export interface TimelineIterationStatus {
    "message"?: string;
}

/**
 * 
 */
export interface TimelineRecord {
    "links"?: ReferenceLinks;

    /**
     * Attempt number of record.
     */
    "attempt"?: number;

    /**
     * The change ID.
     */
    "changeId"?: number;

    /**
     * A string that indicates the current operation.
     */
    "currentOperation"?: string;

    /**
     * A reference to a sub-timeline.
     */
    "details"?: TimelineReference;

    /**
     * The number of errors produced by this operation.
     */
    "errorCount"?: number;

    /**
     * The finish time.
     */
    "finishTime"?: Date;

    /**
     * The ID of the record.
     */
    "id"?: string;

    /**
     * String identifier that is consistent across attempts.
     */
    "identifier"?: string;
    "issues"?: Array<Issue>;

    /**
     * The time the record was last modified.
     */
    "lastModified"?: Date;

    /**
     * A reference to the log produced by this operation.
     */
    "log"?: TaskLogReference;

    /**
     * The name.
     */
    "name"?: string;

    /**
     * An ordinal value relative to other records.
     */
    "order"?: number;

    /**
     * The ID of the record's parent.
     */
    "parentId"?: string;

    /**
     * The current completion percentage.
     */
    "percentComplete"?: number;
    "previousAttempts"?: Array<TimelineAttempt>;

    /**
     * The result code.
     */
    "resultCode"?: string;

    /**
     * The start time.
     */
    "startTime"?: Date;

    /**
     * A reference to the task represented by this timeline record.
     */
    "task"?: TaskReference;

    /**
     * The type of the record.
     */
    "type"?: string;

    /**
     * The REST URL of the timeline record.
     */
    "url"?: string;

    /**
     * The number of warnings produced by this operation.
     */
    "warningCount"?: number;

    /**
     * The name of the agent running the operation.
     */
    "workerName"?: string;
    "location"?: string;
    "refName"?: string;
    "variables"?: { [key: string]: VariableValue; };
}

/**
 * 
 */
export interface TimelineRecordFeedLinesWrapper {
    "count"?: number;
    "stepId"?: string;
    "value"?: Array<string>;
}

/**
 * 
 */
export interface TimelineRecordsUpdatedEvent extends RealtimeBuildEvent {
}

/**
 * 
 */
export interface TimelineReference {

    /**
     * The change ID.
     */
    "changeId"?: number;

    /**
     * The ID of the timeline.
     */
    "id"?: string;

    /**
     * The REST URL of the timeline.
     */
    "url"?: string;
    "location"?: string;
}

/**
 * 
 */
export interface TimelineTeamData {

    /**
     * Backlog matching the mapped backlog associated with this team.
     */
    "backlog"?: BacklogLevel;

    /**
     * The field reference names of the work item data
     */
    "fieldReferenceNames"?: Array<string>;

    /**
     * The id of the team
     */
    "id"?: string;

    /**
     * Was iteration and work item data retrieved for this team. <remarks> Teams with IsExpanded false have not had their iteration, work item, and field related data queried and will never contain this data. If true then these items are queried and, if there are items in the queried range, there will be data. </remarks>
     */
    "isExpanded"?: boolean;

    /**
     * The iteration data, including the work items, in the queried date range.
     */
    "iterations"?: Array<TimelineTeamIteration>;

    /**
     * The name of the team
     */
    "name"?: string;

    /**
     * The order by field name of this team
     */
    "orderByField"?: string;

    /**
     * The field reference names of the partially paged work items, such as ID, WorkItemType
     */
    "partiallyPagedFieldReferenceNames"?: Array<string>;

    /**
     * The project id the team belongs team
     */
    "projectId"?: string;

    /**
     * Status for this team.
     */
    "status"?: TimelineTeamStatus;

    /**
     * The team field default value
     */
    "teamFieldDefaultValue"?: string;

    /**
     * The team field name of this team
     */
    "teamFieldName"?: string;

    /**
     * The team field values
     */
    "teamFieldValues"?: Array<TeamFieldValue>;

    /**
     * Colors for the work item types.
     */
    "workItemTypeColors"?: Array<WorkItemColor>;
}

/**
 * 
 */
export interface TimelineTeamIteration {

    /**
     * The end date of the iteration
     */
    "finishDate"?: Date;

    /**
     * The iteration name
     */
    "name"?: string;

    /**
     * All the partially paged workitems in this iteration.
     */
    "partiallyPagedWorkItems"?: Array<Array<any>>;

    /**
     * The iteration path
     */
    "path"?: string;

    /**
     * The start date of the iteration
     */
    "startDate"?: Date;

    /**
     * The status of this iteration
     */
    "status"?: TimelineIterationStatus;

    /**
     * The work items that have been paged in this iteration
     */
    "workItems"?: Array<Array<any>>;
}

/**
 * 
 */
export interface TimelineTeamStatus {
    "message"?: string;
}

/**
 * Real time event (SignalR) for a title/description update on a pull request
 */
export interface TitleDescriptionUpdatedEvent extends RealTimePullRequestEvent {
}

/**
 * A paginatated list of session tokens. Session tokens correspond to OAuth credentials such as personal access tokens (PATs) and other OAuth authorizations.
 */
export interface TokenAdminPagedSessionTokens {

    /**
     * The continuation token that can be used to retrieve the next page of session tokens, or <code>null</code> if there is no next page.
     */
    "continuationToken"?: string;

    /**
     * The list of all session tokens in the current page.
     */
    "value"?: Array<SessionToken>;
}

/**
 * A request to revoke a particular delegated authorization.
 */
export interface TokenAdminRevocation {

    /**
     * The authorization ID of the OAuth authorization to revoke.
     */
    "authorizationId"?: string;
}

/**
 * A rule which is applied to disable any incoming delegated authorization which matches the given properties.
 */
export interface TokenAdminRevocationRule {

    /**
     * A datetime cutoff. Tokens created before this time will be rejected. This is an optional paramter. If omitted, defaults to the time at which the rule was created.
     */
    "createdBefore"?: Date;

    /**
     * A string containing a space-delimited list of OAuth scopes. A token matching any one of the scopes will be rejected. For a list of all OAuth scopes supported by VSTS, see: https://docs.microsoft.com/en-us/vsts/integrate/get-started/authentication/oauth?view=vsts#scopes. This is a mandatory parameter.
     */
    "scopes"?: string;
}

/**
 * 
 */
export interface TokenAdministrationRevocation {

    /**
     * A list of audience (target accounts) to limit the revocations to
     */
    "audience"?: Array<string>;

    /**
     * A list of authorization ID of the OAuth authorization to revoke.
     */
    "authorizationIds"?: Array<string>;
}

/**
 * 
 */
export interface TransactionSummary {
    "averageResponseTime"?: number;
    "averageTransactionTime"?: number;
    "percentileData"?: Array<SummaryPercentileData>;
    "scenarioName"?: string;
    "testName"?: string;
    "totalTransactions"?: number;
    "transactionName"?: string;
}

/**
 * 
 */
export interface Type {
    "count"?: number;
    "occurrences"?: number;
    "subTypes"?: Array<SubType>;
    "typeName"?: string;
    "url"?: string;
}

/**
 * Deletion state of a Universal package.
 */
export interface UPackPackageVersionDeletionState {

    /**
     * UTC date the package was deleted.
     */
    "deletedDate"?: Date;

    /**
     * Name of the package.
     */
    "name"?: string;

    /**
     * Version of the package.
     */
    "version"?: string;
}

/**
 * A batch of operations to apply to package versions.
 */
export interface UPackPackagesBatchRequest {

    /**
     * Data required to perform the operation. This is optional based on the type of the operation. Use BatchPromoteData if performing a promote operation.
     */
    "data"?: BatchOperationData;

    /**
     * The packages onto which the operation will be performed.
     */
    "packages"?: Array<MinimalPackageDetails>;
}

/**
 * 
 */
export interface UPackRecycleBinPackageVersionDetails {

    /**
     * Setting to false will undo earlier deletion and restore the package to feed.
     */
    "deleted"?: boolean;
}

/**
 * 
 */
export interface UnsupportedFilter extends BaseSubscriptionFilter {
}

/**
 * 
 */
export interface UnsupportedSubscriptionChannel {
    "type"?: string;
}

/**
 * 
 */
export interface UpdatePlan {

    /**
     * Description of the plan
     */
    "description"?: string;

    /**
     * Name of the plan to create.
     */
    "name"?: string;

    /**
     * Plan properties.
     */
    "properties"?: any;

    /**
     * Revision of the plan that was updated - the value used here should match the one the server gave the client in the Plan.
     */
    "revision"?: number;
}

/**
 * Describes a request to update a process
 */
export interface UpdateProcessModel {

    /**
     * New description of the process
     */
    "description"?: string;

    /**
     * If true new projects will use this process by default
     */
    "isDefault"?: boolean;

    /**
     * If false the process will be disabled and cannot be used to create projects
     */
    "isEnabled"?: boolean;

    /**
     * New name of the process
     */
    "name"?: string;
}

/**
 * Request class/object to update the rule.
 */
export interface UpdateProcessRuleRequest extends CreateProcessRuleRequest {
}

/**
 * Class to describe a request that updates a field's properties in a work item type.
 */
export interface UpdateProcessWorkItemTypeFieldRequest {

    /**
     * Allow setting field value to a group identity. Only applies to identity fields.
     */
    "allowGroups"?: boolean;

    /**
     * The default value of the field.
     */
    "defaultValue"?: any;

    /**
     * If true the field cannot be edited.
     */
    "readOnly"?: boolean;

    /**
     * The default value of the field.
     */
    "required"?: boolean;
}

/**
 * Class for update request on a work item type
 */
export interface UpdateProcessWorkItemTypeRequest {

    /**
     * Color of the work item type
     */
    "color"?: string;

    /**
     * Description of the work item type
     */
    "description"?: string;

    /**
     * Icon of the work item type
     */
    "icon"?: string;

    /**
     * If set will disable the work item type
     */
    "isDisabled"?: boolean;
}

/**
 * 
 */
export interface UpdateRefsRequest {
    "refUpdateRequests"?: Array<GitRefUpdate>;
}

/**
 * 
 */
export interface UpdateSubscripitonDiagnosticsParameters {
    "deliveryResults"?: UpdateSubscripitonTracingParameters;
    "deliveryTracing"?: UpdateSubscripitonTracingParameters;
    "evaluationTracing"?: UpdateSubscripitonTracingParameters;
}

/**
 * 
 */
export interface UpdateSubscripitonTracingParameters {
    "enabled"?: boolean;
}

/**
 * 
 */
export interface UpdateTestRunRequest {
    "attachmentsToAdd"?: Array<TestResultAttachment>;
    "attachmentsToDelete"?: Array<TestResultAttachmentIdentity>;
    "projectName"?: string;
    "shouldHyderate"?: boolean;
    "testRun"?: LegacyTestRun;
}

/**
 * 
 */
export interface UpdateTestRunResponse {
    "attachmentIds"?: Array<number>;
    "updatedProperties"?: UpdatedProperties;
}

/**
 * 
 */
export interface UpdatedProperties {
    "id"?: number;
    "lastUpdated"?: Date;
    "lastUpdatedBy"?: string;
    "lastUpdatedByName"?: string;
    "revision"?: number;
}

/**
 * 
 */
export interface UploadAttachmentsRequest {
    "attachments"?: Array<HttpPostedTcmAttachment>;
    "requestParams"?: { [key: string]: string; };
}

/**
 * Upstream source definition, including its Identity, package type, and other associated information.
 */
export interface UpstreamSource {

    /**
     * UTC date that this upstream was deleted.
     */
    "deletedDate"?: Date;

    /**
     * Identity of the upstream source.
     */
    "id"?: string;

    /**
     * For an internal upstream type, track the Azure DevOps organization that contains it.
     */
    "internalUpstreamCollectionId"?: string;

    /**
     * For an internal upstream type, track the feed id being referenced.
     */
    "internalUpstreamFeedId"?: string;

    /**
     * For an internal upstream type, track the view of the feed being referenced.
     */
    "internalUpstreamViewId"?: string;

    /**
     * Locator for connecting to the upstream source.
     */
    "location"?: string;

    /**
     * Display name.
     */
    "name"?: string;

    /**
     * Package type associated with the upstream source.
     */
    "protocol"?: string;
}

/**
 * Upstream source definition, including its Identity, package type, and other associated information.
 */
export interface UpstreamSourceInfo {

    /**
     * Identity of the upstream source.
     */
    "id"?: string;

    /**
     * Locator for connecting to the upstream source.
     */
    "location"?: string;

    /**
     * Display name.
     */
    "name"?: string;
}

/**
 * A user entity with additional properties including thier license, extensions, and project membership
 */
export interface UserEntitlement {

    /**
     * User's access level denoted by a license.
     */
    "accessLevel"?: AccessLevel;

    /**
     * [Readonly] Date the user was added to the collection.
     */
    "dateCreated"?: Date;

    /**
     * User's extensions.
     */
    "extensions"?: Array<Extension>;

    /**
     * [Readonly] GroupEntitlements that this user belongs to.
     */
    "groupAssignments"?: Array<GroupEntitlement>;

    /**
     * The unique identifier which matches the Id of the Identity associated with the GraphMember.
     */
    "id"?: string;

    /**
     * [Readonly] Date the user last accessed the collection.
     */
    "lastAccessedDate"?: Date;

    /**
     * Relation between a project and the user's effective permissions in that project.
     */
    "projectEntitlements"?: Array<ProjectEntitlement>;

    /**
     * User reference.
     */
    "user"?: GraphUser;
}

/**
 * 
 */
export interface UserEntitlementOperationReference extends OperationReference {
}

/**
 * 
 */
export interface UserEntitlementOperationResult {

    /**
     * List of error codes paired with their corresponding error messages.
     */
    "errors"?: Array<{ [key: string]: string; }>;

    /**
     * Success status of the operation.
     */
    "isSuccess"?: boolean;

    /**
     * Result of the MemberEntitlement after the operation.
     */
    "result"?: UserEntitlement;

    /**
     * Identifier of the Member being acted upon.
     */
    "userId"?: string;
}

/**
 * 
 */
export interface UserEntitlementsPatchResponse extends UserEntitlementsResponseBase {
}

/**
 * 
 */
export interface UserEntitlementsPostResponse extends UserEntitlementsResponseBase {
}

/**
 * 
 */
export interface UserEntitlementsResponseBase {

    /**
     * True if all operations were successful.
     */
    "isSuccess"?: boolean;

    /**
     * Result of the user entitlement after the operations have been applied.
     */
    "userEntitlement"?: UserEntitlement;
}

/**
 * Represents the extension policy applied to a given user
 */
export interface UserExtensionPolicy {

    /**
     * User display name that this policy refers to
     */
    "displayName"?: string;

    /**
     * The extension policy applied to the user
     */
    "permissions"?: ExtensionPolicy;

    /**
     * User id that this policy refers to
     */
    "userId"?: string;
}

/**
 * 
 */
export interface UserSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * 
 */
export interface UserSystemSubscriptionChannel extends SubscriptionChannelWithAddress {
}

/**
 * Summary of licenses and extensions assigned to users in the organization
 */
export interface UsersSummary {

    /**
     * Available Access Levels
     */
    "availableAccessLevels"?: Array<AccessLevel>;

    /**
     * Summary of Extensions in the organization
     */
    "extensions"?: Array<ExtensionSummaryData>;

    /**
     * Group Options
     */
    "groupOptions"?: Array<GroupOption>;

    /**
     * Summary of Licenses in the organization
     */
    "licenses"?: Array<LicenseSummaryData>;

    /**
     * Summary of Projects in the organization
     */
    "projectRefs"?: Array<ProjectRef>;
}

/**
 * 
 */
export interface ValidationIssue {
    "description"?: string;
    "file"?: string;
    "helpLink"?: string;
    "line"?: number;
}

/**
 * 
 */
export interface ValidationItem {

    /**
     * Tells whether the current input is valid or not
     */
    "isValid"?: boolean;

    /**
     * Reason for input validation failure
     */
    "reason"?: string;

    /**
     * Type of validation item
     */
    "type"?: string;

    /**
     * Value to validate. The conditional expression to validate for the input for "expression" type Eg:eq(variables['Build.SourceBranch'], 'refs/heads/master');eq(value, 'refs/heads/master')
     */
    "value"?: string;
}

/**
 * Encapsulates the properties of a field value definition. It has the information needed to retrieve the list of possible values for a certain field and how to handle that field values in the UI. This information includes what type of object this value represents, which property to use for UI display and which property to use for saving the subscription
 */
export interface ValueDefinition {

    /**
     * Gets or sets the data source.
     */
    "dataSource"?: Array<InputValue>;

    /**
     * Gets or sets the rest end point.
     */
    "endPoint"?: string;

    /**
     * Gets or sets the result template.
     */
    "resultTemplate"?: string;
}

/**
 * A variable group is a collection of related variables.
 */
export interface VariableGroup extends VariableGroupReference {
}

/**
 * 
 */
export interface VariableGroupParameters {

    /**
     * Sets description of the variable group.
     */
    "description"?: string;

    /**
     * Sets name of the variable group.
     */
    "name"?: string;

    /**
     * Sets provider data.
     */
    "providerData"?: VariableGroupProviderData;

    /**
     * Sets type of the variable group.
     */
    "type"?: string;

    /**
     * Sets variables contained in the variable group.
     */
    "variables"?: { [key: string]: VariableValue; };
}

/**
 * Defines provider data of the variable group.
 */
export interface VariableGroupProviderData {
}

/**
 * Represents a reference to a variable group.
 */
export interface VariableGroupReference {

    /**
     * The Name of the variable group.
     */
    "alias"?: string;

    /**
     * The ID of the variable group.
     */
    "id"?: number;
}

/**
 * Represents options for running a phase based on values specified by a list of variables.
 */
export interface VariableMultipliersAgentExecutionOptions extends AgentTargetExecutionOptions {
}

/**
 * Represents options for running a phase based on values specified by a list of variables.
 */
export interface VariableMultipliersServerExecutionOptions extends ServerTargetExecutionOptions {
}

/**
 * 
 */
export interface VariableValue {

    /**
     * Gets or sets as the variable is secret or not.
     */
    "isSecret"?: boolean;

    /**
     * Gets or sets the value.
     */
    "value"?: string;
}

/**
 * Describes the details pertaining to a version of the result file.
 */
export interface Version {

    /**
     * Name of the branch.
     */
    "branchName"?: string;

    /**
     * ChangeId in the given branch associated with this match.
     */
    "changeId"?: string;
}

/**
 * 
 */
export interface VersionControlProjectInfo {
    "project"?: TeamProjectReference;
    "supportsGit"?: boolean;
    "supportsTFVC"?: boolean;
}

/**
 * A particular revision for a policy configuration.
 */
export interface VersionedPolicyConfigurationRef extends PolicyConfigurationRef {
}

/**
 * Encapsulates the resource version and its data or reference to the compatible version. Only one of the two last fields should be not null.
 */
export interface VersionedResource {

    /**
     * Gets or sets the reference to the compatible version.
     */
    "compatibleWith"?: string;

    /**
     * Gets or sets the resource data.
     */
    "resource"?: any;

    /**
     * Gets or sets the version of the resource data.
     */
    "resourceVersion"?: string;
}

/**
 * 
 */
export interface VirtualMachine {
    "agent"?: TaskAgent;
    "id"?: number;
    "tags"?: Array<string>;
}

/**
 * 
 */
export interface VirtualMachineGroup extends ServiceGroup {
}

/**
 * 
 */
export interface VirtualMachineGroupCreateParameters {
    "name"?: string;
}

/**
 * This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
 */
export interface VssJsonCollectionWrapper extends VssJsonCollectionWrapperBase {
}

/**
 * 
 */
export interface VssJsonCollectionWrapperBase {
    "count"?: number;
}

/**
 * This is the type used for firing notifications intended for the subsystem in the Notifications SDK. For components that can't take a dependency on the Notifications SDK directly, they can use ITeamFoundationEventService.PublishNotification and the Notifications SDK ISubscriber implementation will get it.
 */
export interface VssNotificationEvent {

    /**
     * Optional: A list of actors which are additional identities with corresponding roles that are relevant to the event.
     */
    "actors"?: Array<EventActor>;

    /**
     * Optional: A list of artifacts referenced or impacted by this event.
     */
    "artifactUris"?: Array<string>;

    /**
     * Required: The event payload.  If Data is a string, it must be in Json or XML format.  Otherwise it must have a serialization format attribute.
     */
    "data"?: any;

    /**
     * Required: The name of the event.  This event must be registered in the context it is being fired.
     */
    "eventType"?: string;

    /**
     * How long before the event expires and will be cleaned up.  The default is to use the system default.
     */
    "expiresIn"?: string;

    /**
     * The id of the item, artifact, extension, project, etc.
     */
    "itemId"?: string;

    /**
     * How long to wait before processing this event.  The default is to process immediately.
     */
    "processDelay"?: string;

    /**
     * Optional: A list of scopes which are are relevant to the event.
     */
    "scopes"?: Array<EventScope>;

    /**
     * This is the time the original source event for this VssNotificationEvent was created.  For example, for something like a build completion notification SourceEventCreatedTime should be the time the build finished not the time this event was raised.
     */
    "sourceEventCreatedTime"?: Date;
}

/**
 * 
 */
export interface WebApiConnectedService extends WebApiConnectedServiceRef {
}

/**
 * 
 */
export interface WebApiConnectedServiceDetails extends WebApiConnectedServiceRef {
}

/**
 * 
 */
export interface WebApiConnectedServiceRef {
    "id"?: string;
    "url"?: string;
}

/**
 * The representation of data needed to create a tag definition which is sent across the wire.
 */
export interface WebApiCreateTagRequestData {

    /**
     * Name of the tag definition that will be created.
     */
    "name"?: string;
}

/**
 * 
 */
export interface WebApiLoadTestMachineInput {
    "machineGroupId"?: string;
    "setupConfiguration"?: WebApiSetupParamaters;
    "supportedRunTypes"?: Array<ERRORUNKNOWN>;
}

/**
 * 
 */
export interface WebApiProject extends TeamProjectReference {
}

/**
 * 
 */
export interface WebApiProjectCollection extends WebApiProjectCollectionRef {
}

/**
 * 
 */
export interface WebApiProjectCollectionRef {

    /**
     * Collection Tfs Url (Host Url)
     */
    "collectionUrl"?: string;

    /**
     * Collection Guid
     */
    "id"?: string;

    /**
     * Collection Name
     */
    "name"?: string;

    /**
     * Collection REST Url
     */
    "url"?: string;
}

/**
 * 
 */
export interface WebApiSetupParamaters {
    "configurations"?: { [key: string]: string; };
}

/**
 * The representation of a tag definition which is sent across the wire.
 */
export interface WebApiTagDefinition {

    /**
     * Whether or not the tag definition is active.
     */
    "active"?: boolean;

    /**
     * ID of the tag definition.
     */
    "id"?: string;

    /**
     * The name of the tag definition.
     */
    "name"?: string;

    /**
     * Resource URL for the Tag Definition.
     */
    "url"?: string;
}

/**
 * 
 */
export interface WebApiTeam extends WebApiTeamRef {
}

/**
 * 
 */
export interface WebApiTeamRef {

    /**
     * Team (Identity) Guid. A Team Foundation ID.
     */
    "id"?: string;

    /**
     * Team name
     */
    "name"?: string;

    /**
     * Team REST API Url
     */
    "url"?: string;
}

/**
 * 
 */
export interface WebApiTestMachine {
    "lastHeartBeat"?: Date;
    "machineName"?: string;
    "status"?: string;
}

/**
 * 
 */
export interface WebApiUserLoadTestMachineInput extends WebApiLoadTestMachineInput {
}

/**
 * 
 */
export interface WebInstanceSummaryData {
    "average"?: number;
    "max"?: number;
    "min"?: number;
}

/**
 * Widget data
 */
export interface Widget {
    "links"?: ReferenceLinks;

    /**
     * Refers to the allowed sizes for the widget. This gets populated when user wants to configure the widget
     */
    "allowedSizes"?: Array<WidgetSize>;

    /**
     * Read-Only Property from Dashboard Service. Indicates if settings are blocked for the current user.
     */
    "areSettingsBlockedForUser"?: boolean;

    /**
     * Refers to unique identifier of a feature artifact. Used for pinning+unpinning a specific artifact.
     */
    "artifactId"?: string;
    "configurationContributionId"?: string;
    "configurationContributionRelativeId"?: string;
    "contentUri"?: string;

    /**
     * The id of the underlying contribution defining the supplied Widget Configuration.
     */
    "contributionId"?: string;

    /**
     * Optional partial dashboard content, to support exchanging dashboard-level version ETag for widget-level APIs
     */
    "dashboard"?: Dashboard;
    "eTag"?: string;
    "id"?: string;
    "isEnabled"?: boolean;
    "isNameConfigurable"?: boolean;
    "lightboxOptions"?: LightboxOptions;
    "loadingImageUrl"?: string;
    "name"?: string;
    "position"?: WidgetPosition;
    "settings"?: string;
    "settingsVersion"?: SemanticVersion;
    "size"?: WidgetSize;
    "typeId"?: string;
    "url"?: string;
}

/**
 * Contribution based information describing Dashboard Widgets.
 */
export interface WidgetMetadata {

    /**
     * Sizes supported by the Widget.
     */
    "allowedSizes"?: Array<WidgetSize>;

    /**
     * Opt-in boolean that indicates if the widget requires the Analytics Service to function. Widgets requiring the analytics service are hidden from the catalog if the Analytics Service is not available.
     */
    "analyticsServiceRequired"?: boolean;

    /**
     * Resource for an icon in the widget catalog.
     */
    "catalogIconUrl"?: string;

    /**
     * Opt-in URL string pointing at widget information. Defaults to extension marketplace URL if omitted
     */
    "catalogInfoUrl"?: string;

    /**
     * The id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
     */
    "configurationContributionId"?: string;

    /**
     * The relative id of the underlying contribution defining the supplied Widget custom configuration UI. Null if custom configuration UI is not available.
     */
    "configurationContributionRelativeId"?: string;

    /**
     * Indicates if the widget requires configuration before being added to dashboard.
     */
    "configurationRequired"?: boolean;

    /**
     * Uri for the widget content to be loaded from .
     */
    "contentUri"?: string;

    /**
     * The id of the underlying contribution defining the supplied Widget.
     */
    "contributionId"?: string;

    /**
     * Optional default settings to be copied into widget settings.
     */
    "defaultSettings"?: string;

    /**
     * Summary information describing the widget.
     */
    "description"?: string;

    /**
     * Widgets can be disabled by the app store.  We'll need to gracefully handle for: - persistence (Allow) - Requests (Tag as disabled, and provide context)
     */
    "isEnabled"?: boolean;

    /**
     * Opt-out boolean that indicates if the widget supports widget name/title configuration. Widgets ignoring the name should set it to false in the manifest.
     */
    "isNameConfigurable"?: boolean;

    /**
     * Opt-out boolean indicating if the widget is hidden from the catalog. Commonly, this is used to allow developers to disable creation of a deprecated widget. A widget must have a functional default state, or have a configuration experience, in order to be visible from the catalog.
     */
    "isVisibleFromCatalog"?: boolean;

    /**
     * Opt-in properties for customizing widget presentation in a "lightbox" dialog.
     */
    "lightboxOptions"?: LightboxOptions;

    /**
     * Resource for a loading placeholder image on dashboard
     */
    "loadingImageUrl"?: string;

    /**
     * User facing name of the widget type. Each widget must use a unique value here.
     */
    "name"?: string;

    /**
     * Publisher Name of this kind of widget.
     */
    "publisherName"?: string;

    /**
     * Data contract required for the widget to function and to work in its container.
     */
    "supportedScopes"?: Array<ERRORUNKNOWN>;

    /**
     * Contribution target IDs
     */
    "targets"?: Array<string>;

    /**
     * Deprecated: locally unique developer-facing id of this kind of widget. ContributionId provides a globally unique identifier for widget types.
     */
    "typeId"?: string;
}

/**
 * 
 */
export interface WidgetMetadataResponse {
    "uri"?: string;
    "widgetMetadata"?: WidgetMetadata;
}

/**
 * 
 */
export interface WidgetPosition {
    "column"?: number;
    "row"?: number;
}

/**
 * Response from RestAPI when saving and editing Widget
 */
export interface WidgetResponse extends Widget {
}

/**
 * 
 */
export interface WidgetSize {

    /**
     * The Width of the widget, expressed in dashboard grid columns.
     */
    "columnSpan"?: number;

    /**
     * The height of the widget, expressed in dashboard grid rows.
     */
    "rowSpan"?: number;
}

/**
 * 
 */
export interface WidgetTypesResponse {
    "links"?: ReferenceLinks;
    "uri"?: string;
    "widgetTypes"?: Array<WidgetMetadata>;
}

/**
 * Wrapper class to support HTTP header generation using CreateResponse, ClientHeaderParameter and ClientResponseType in WidgetV2Controller
 */
export interface WidgetsVersionedList {
    "eTag"?: Array<string>;
    "widgets"?: Array<Widget>;
}

/**
 * Defines a wiki repository which encapsulates the git repository backing the wiki.
 */
export interface Wiki extends WikiCreateParameters {
}

/**
 * Defines properties for wiki attachment file.
 */
export interface WikiAttachment {

    /**
     * Name of the wiki attachment file.
     */
    "name"?: string;

    /**
     * Path of the wiki attachment file.
     */
    "path"?: string;
}

/**
 * Response contract for the Wiki Attachments API
 */
export interface WikiAttachmentResponse {

    /**
     * Defines properties for wiki attachment file.
     */
    "attachment"?: WikiAttachment;

    /**
     * Contains the list of ETag values from the response header of the attachments API call. The first item in the list contains the version of the wiki attachment.
     */
    "eTag"?: Array<string>;
}

/**
 * Base wiki creation parameters.
 */
export interface WikiCreateBaseParameters {

    /**
     * Folder path inside repository which is shown as Wiki. Not required for ProjectWiki type.
     */
    "mappedPath"?: string;

    /**
     * Wiki name.
     */
    "name"?: string;

    /**
     * ID of the project in which the wiki is to be created.
     */
    "projectId"?: string;

    /**
     * ID of the git repository that backs up the wiki. Not required for ProjectWiki type.
     */
    "repositoryId"?: string;
}

/**
 * Wiki creations parameters.
 */
export interface WikiCreateParameters {

    /**
     * Wiki name.
     */
    "name"?: string;

    /**
     * ID of the project in which the wiki is to be created.
     */
    "projectId"?: string;
}

/**
 * Wiki creation parameters.
 */
export interface WikiCreateParametersV2 extends WikiCreateBaseParameters {
}

/**
 * Defines the matched terms in the field of the wiki result.
 */
export interface WikiHit {

    /**
     * Reference name of the highlighted field.
     */
    "fieldReferenceName"?: string;

    /**
     * Matched/highlighted snippets of the field.
     */
    "highlights"?: Array<string>;
}

/**
 * Defines a page in a wiki.
 */
export interface WikiPage extends WikiPageCreateOrUpdateParameters {
}

/**
 * Contract encapsulating parameters for the page create or update operations.
 */
export interface WikiPageCreateOrUpdateParameters {

    /**
     * Content of the wiki page.
     */
    "content"?: string;
}

/**
 * Request contract for Wiki Page Move.
 */
export interface WikiPageMove extends WikiPageMoveParameters {
}

/**
 * Contract encapsulating parameters for the page move operation.
 */
export interface WikiPageMoveParameters {

    /**
     * New order of the wiki page.
     */
    "newOrder"?: number;

    /**
     * New path of the wiki page.
     */
    "newPath"?: string;

    /**
     * Current path of the wiki page.
     */
    "path"?: string;
}

/**
 * Response contract for the Wiki Page Move API.
 */
export interface WikiPageMoveResponse {

    /**
     * Contains the list of ETag values from the response header of the page move API call. The first item in the list contains the version of the wiki page subject to page move.
     */
    "eTag"?: Array<string>;

    /**
     * Defines properties for wiki page move.
     */
    "pageMove"?: WikiPageMove;
}

/**
 * Response contract for the Wiki Pages PUT, PATCH and DELETE APIs.
 */
export interface WikiPageResponse {

    /**
     * Contains the list of ETag values from the response header of the pages API call. The first item in the list contains the version of the wiki page.
     */
    "eTag"?: Array<string>;

    /**
     * Defines properties for wiki page.
     */
    "page"?: WikiPage;
}

/**
 * Defines properties for wiki page view stats.
 */
export interface WikiPageViewStats {

    /**
     * Wiki page view count.
     */
    "count"?: number;

    /**
     * Wiki page last viewed time.
     */
    "lastViewedTime"?: Date;

    /**
     * Wiki page path.
     */
    "path"?: string;
}

/**
 * Defines the wiki result that matched a wiki search request.
 */
export interface WikiResult {

    /**
     * Collection of the result file.
     */
    "collection"?: Collection;

    /**
     * ContentId of the result file.
     */
    "contentId"?: string;

    /**
     * Name of the result file.
     */
    "fileName"?: string;

    /**
     * Highlighted snippets of fields that match the search request. The list is sorted by relevance of the snippets.
     */
    "hits"?: Array<WikiHit>;

    /**
     * Path at which result file is present.
     */
    "path"?: string;

    /**
     * Project details of the wiki document.
     */
    "project"?: ProjectReference;

    /**
     * Wiki information for the result.
     */
    "wiki"?: Wiki;
}

/**
 * Defines a wiki search request.
 */
export interface WikiSearchRequest extends EntitySearchRequest {
}

/**
 * Defines a wiki search response item.
 */
export interface WikiSearchResponse extends EntitySearchResponse {
}

/**
 * Wiki update parameters.
 */
export interface WikiUpdateParameters {

    /**
     * Name for wiki.
     */
    "name"?: string;

    /**
     * Versions of the wiki.
     */
    "versions"?: Array<GitVersionDescriptor>;
}

/**
 * 
 */
export interface WikiUpdatedNotificationMessage {

    /**
     * Collection host Id for which the wikis are updated.
     */
    "collectionId"?: string;

    /**
     * Project Id for which the wikis are updated.
     */
    "projectId"?: string;

    /**
     * Repository Id associated with the particular wiki which is added, updated or deleted.
     */
    "repositoryId"?: string;
}

/**
 * Defines a wiki resource.
 */
export interface WikiV2 extends WikiCreateBaseParameters {
}

/**
 * A WIQL query
 */
export interface Wiql {

    /**
     * The text of the WIQL query
     */
    "query"?: string;
}

/**
 * 
 */
export interface WitContribution {

    /**
     * The id for the contribution.
     */
    "contributionId"?: string;

    /**
     * The height for the contribution.
     */
    "height"?: number;

    /**
     * A dictionary holding key value pairs for contribution inputs.
     */
    "inputs"?: { [key: string]: any; };

    /**
     * A value indicating if the contribution should be show on deleted workItem.
     */
    "showOnDeletedWorkItem"?: boolean;
}

/**
 * A work artifact link describes an outbound artifact link type.
 */
export interface WorkArtifactLink {

    /**
     * Target artifact type.
     */
    "artifactType"?: string;

    /**
     * Outbound link type.
     */
    "linkType"?: string;

    /**
     * Target tool type.
     */
    "toolType"?: string;
}

/**
 * Describes a work item.
 */
export interface WorkItem extends WorkItemTrackingResource {
}

/**
 * Describes a request to get a set of work items
 */
export interface WorkItemBatchGetRequest {

    /**
     * AsOf UTC date time string
     */
    "asOf"?: Date;

    /**
     * The requested fields
     */
    "fields"?: Array<string>;

    /**
     * The requested work item ids
     */
    "ids"?: Array<number>;
}

/**
 * 
 */
export interface WorkItemBehavior {
    "abstract"?: boolean;
    "color"?: string;
    "description"?: string;
    "fields"?: Array<WorkItemBehaviorField>;
    "id"?: string;
    "inherits"?: WorkItemBehaviorReference;
    "name"?: string;
    "overriden"?: boolean;
    "rank"?: number;
    "url"?: string;
}

/**
 * 
 */
export interface WorkItemBehaviorField {
    "behaviorFieldId"?: string;
    "id"?: string;
    "url"?: string;
}

/**
 * 
 */
export interface WorkItemBehaviorReference {

    /**
     * The ID of the reference behavior
     */
    "id"?: string;

    /**
     * The url of the reference behavior
     */
    "url"?: string;
}

/**
 * Defines a classification node for work item tracking.
 */
export interface WorkItemClassificationNode extends WorkItemTrackingResource {
}

/**
 * Work item color and icon.
 */
export interface WorkItemColor {
    "icon"?: string;
    "primaryColor"?: string;
    "workItemTypeName"?: string;
}

/**
 * Comment on Work Item
 */
export interface WorkItemComment extends WorkItemTrackingResource {
}

/**
 * Represents a request to create a work item comment.
 */
export interface WorkItemCommentCreateRequest {

    /**
     * The text of the comment.
     */
    "text"?: string;
}

/**
 * Contains information about work item comment reaction for a particular reaction type.
 */
export interface WorkItemCommentReactionResponse extends WorkItemTrackingResource {
}

/**
 * Comment on a Work Item.
 */
export interface WorkItemCommentResponse extends WorkItemTrackingResource {
}

/**
 * Represents a request to update a work item comment.
 */
export interface WorkItemCommentUpdateRequest {

    /**
     * The updated text of the comment.
     */
    "text"?: string;
}

/**
 * Represents the reference to a specific version of a comment on a Work Item.
 */
export interface WorkItemCommentVersionRef extends WorkItemTrackingResourceReference {
}

/**
 * Represents a specific version of a comment on a work item.
 */
export interface WorkItemCommentVersionResponse extends WorkItemTrackingResource {
}

/**
 * Collection of comments.
 */
export interface WorkItemComments extends WorkItemTrackingResource {
}

/**
 * Represents a response of work item comments reporting operations.
 */
export interface WorkItemCommentsReportingResponse extends WorkItemCommentsResponse {
}

/**
 * Represents a list of work item comments.
 */
export interface WorkItemCommentsResponse extends WorkItemTrackingResource {
}

/**
 * Full deleted work item object. Includes the work item itself.
 */
export interface WorkItemDelete extends WorkItemDeleteReference {
}

/**
 * Reference to a deleted work item.
 */
export interface WorkItemDeleteReference {

    /**
     * The HTTP status code for work item operation in a batch request.
     */
    "code"?: number;

    /**
     * The user who deleted the work item type.
     */
    "deletedBy"?: string;

    /**
     * The work item deletion date.
     */
    "deletedDate"?: string;

    /**
     * Work item ID.
     */
    "id"?: number;

    /**
     * The exception message for work item operation in a batch request.
     */
    "message"?: string;

    /**
     * Name or title of the work item.
     */
    "name"?: string;

    /**
     * Parent project of the deleted work item.
     */
    "project"?: string;

    /**
     * Type of work item.
     */
    "type"?: string;

    /**
     * REST API URL of the resource
     */
    "url"?: string;
}

/**
 * Shallow Reference to a deleted work item.
 */
export interface WorkItemDeleteShallowReference {

    /**
     * Work item ID.
     */
    "id"?: number;

    /**
     * REST API URL of the resource
     */
    "url"?: string;
}

/**
 * Describes an update request for a deleted work item.
 */
export interface WorkItemDeleteUpdate {

    /**
     * Sets a value indicating whether this work item is deleted.
     */
    "isDeleted"?: boolean;
}

/**
 * Work Item Class
 */
export interface WorkItemDetails {

    /**
     * Work Item Id
     */
    "id"?: number;

    /**
     * Work Item Name
     */
    "name"?: string;

    /**
     * Work Item Fields
     */
    "workItemFields"?: Array<any>;
}

/**
 * Describes a field on a work item and it's properties specific to that work item type.
 */
export interface WorkItemField extends WorkItemTrackingResource {
}

/**
 * Describes a work item field operation.
 */
export interface WorkItemFieldOperation {

    /**
     * Friendly name of the operation.
     */
    "name"?: string;

    /**
     * Reference name of the operation.
     */
    "referenceName"?: string;
}

/**
 * Reference to a field in a work item
 */
export interface WorkItemFieldReference {

    /**
     * The friendly name of the field.
     */
    "name"?: string;

    /**
     * The reference name of the field.
     */
    "referenceName"?: string;

    /**
     * The REST URL of the resource.
     */
    "url"?: string;
}

/**
 * Describes an update to a work item field.
 */
export interface WorkItemFieldUpdate {

    /**
     * The new value of the field.
     */
    "newValue"?: any;

    /**
     * The old value of the field.
     */
    "oldValue"?: any;
}

/**
 * 
 */
export interface WorkItemHistory extends WorkItemTrackingResource {
}

/**
 * Defines the matched terms in the field of the work item result.
 */
export interface WorkItemHit {

    /**
     * Reference name of the highlighted field.
     */
    "fieldReferenceName"?: string;

    /**
     * Matched/highlighted snippets of the field.
     */
    "highlights"?: Array<string>;
}

/**
 * Reference to a work item icon.
 */
export interface WorkItemIcon {

    /**
     * The identifier of the icon.
     */
    "id"?: string;

    /**
     * The REST URL of the resource.
     */
    "url"?: string;
}

/**
 * A link between two work items.
 */
export interface WorkItemLink {

    /**
     * The type of link.
     */
    "rel"?: string;

    /**
     * The source work item.
     */
    "source"?: WorkItemReference;

    /**
     * The target work item.
     */
    "target"?: WorkItemReference;
}

/**
 * Describes the next state for a work item.
 */
export interface WorkItemNextStateOnTransition {

    /**
     * Error code if there is no next state transition possible.
     */
    "errorCode"?: string;

    /**
     * Work item ID.
     */
    "id"?: number;

    /**
     * Error message if there is no next state transition possible.
     */
    "message"?: string;

    /**
     * Name of the next state on transition.
     */
    "stateOnTransition"?: string;
}

/**
 * Represents a clause in a work item query. This shows the structure of a work item query.
 */
export interface WorkItemQueryClause {

    /**
     * Child clauses if the current clause is a logical operator
     */
    "clauses"?: Array<WorkItemQueryClause>;

    /**
     * Field associated with condition
     */
    "field"?: WorkItemFieldReference;

    /**
     * Right side of the condition when a field to field comparison
     */
    "fieldValue"?: WorkItemFieldReference;

    /**
     * Determines if this is a field to field comparison
     */
    "isFieldValue"?: boolean;

    /**
     * The field operator
     */
    "operator"?: WorkItemFieldOperation;

    /**
     * Right side of the condition when a field to value comparison
     */
    "value"?: string;
}

/**
 * The result of a work item query.
 */
export interface WorkItemQueryResult {

    /**
     * The date the query was run in the context of.
     */
    "asOf"?: Date;

    /**
     * The columns of the query.
     */
    "columns"?: Array<WorkItemFieldReference>;

    /**
     * The sort columns of the query.
     */
    "sortColumns"?: Array<WorkItemQuerySortColumn>;

    /**
     * The work item links returned by the query.
     */
    "workItemRelations"?: Array<WorkItemLink>;

    /**
     * The work items returned by the query.
     */
    "workItems"?: Array<WorkItemReference>;
}

/**
 * A sort column.
 */
export interface WorkItemQuerySortColumn {

    /**
     * The direction to sort by.
     */
    "descending"?: boolean;

    /**
     * A work item field.
     */
    "field"?: WorkItemFieldReference;
}

/**
 * Contains reference to a work item.
 */
export interface WorkItemReference {

    /**
     * Work item ID.
     */
    "id"?: number;
    "name"?: string;
    "type"?: string;

    /**
     * REST API URL of the resource
     */
    "url"?: string;
    "webUrl"?: string;
}

/**
 * 
 */
export interface WorkItemRelation extends Link {
}

/**
 * Represents the work item type relatiion type.
 */
export interface WorkItemRelationType extends WorkItemTrackingReference {
}

/**
 * Descrives updates to a work item's relations.
 */
export interface WorkItemRelationUpdates {

    /**
     * List of newly added relations.
     */
    "added"?: Array<WorkItemRelation>;

    /**
     * List of removed relations.
     */
    "removed"?: Array<WorkItemRelation>;

    /**
     * List of updated relations.
     */
    "updated"?: Array<WorkItemRelation>;
}

/**
 * Defines the work item result that matched a work item search request.
 */
export interface WorkItemResult {

    /**
     * A standard set of work item fields and their values.
     */
    "fields"?: { [key: string]: string; };

    /**
     * Highlighted snippets of fields that match the search request. The list is sorted by relevance of the snippets.
     */
    "hits"?: Array<WorkItemHit>;

    /**
     * Project details of the work item.
     */
    "project"?: Project;

    /**
     * Reference to the work item.
     */
    "url"?: string;
}

/**
 * Defines a work item search request.
 */
export interface WorkItemSearchRequest extends EntitySearchRequest {
}

/**
 * Defines a response item that is returned for a work item search request.
 */
export interface WorkItemSearchResponse extends EntitySearchResponse {
}

/**
 * Work item type state name, color and state category
 */
export interface WorkItemStateColor {

    /**
     * Category of state
     */
    "category"?: string;

    /**
     * Color value
     */
    "color"?: string;

    /**
     * Work item type state name
     */
    "name"?: string;
}

/**
 * 
 */
export interface WorkItemStateInputModel {

    /**
     * Color of the state
     */
    "color"?: string;

    /**
     * Name of the state
     */
    "name"?: string;

    /**
     * Order in which state should appear
     */
    "order"?: number;

    /**
     * Category of the state
     */
    "stateCategory"?: string;
}

/**
 * 
 */
export interface WorkItemStateResultModel {

    /**
     * Color of the state
     */
    "color"?: string;

    /**
     * Is the state hidden
     */
    "hidden"?: boolean;

    /**
     * The ID of the State
     */
    "id"?: string;

    /**
     * Name of the state
     */
    "name"?: string;

    /**
     * Order in which state should appear
     */
    "order"?: number;

    /**
     * Category of the state
     */
    "stateCategory"?: string;

    /**
     * Url of the state
     */
    "url"?: string;
}

/**
 * Describes a state transition in a work item.
 */
export interface WorkItemStateTransition {

    /**
     * Gets a list of actions needed to transition to that state.
     */
    "actions"?: Array<string>;

    /**
     * Name of the next state.
     */
    "to"?: string;
}

/**
 * Describes a work item template.
 */
export interface WorkItemTemplate extends WorkItemTemplateReference {
}

/**
 * Describes a shallow reference to a work item template.
 */
export interface WorkItemTemplateReference extends WorkItemTrackingResource {
}

/**
 * 
 */
export interface WorkItemToTestLinks {
    "tests"?: Array<TestMethod>;
    "workItem"?: WorkItemReference;
}

/**
 * 
 */
export interface WorkItemTrackingReference extends WorkItemTrackingResource {
}

/**
 * Base class for WIT REST resources.
 */
export interface WorkItemTrackingResource extends WorkItemTrackingResourceReference {
}

/**
 * Base class for work item tracking resource references.
 */
export interface WorkItemTrackingResourceReference {
    "url"?: string;
}

/**
 * Describes a work item type.
 */
export interface WorkItemType extends WorkItemTrackingResource {
}

/**
 * 
 */
export interface WorkItemTypeBehavior {

    /**
     * Reference to the behavior of a work item type
     */
    "behavior"?: WorkItemBehaviorReference;

    /**
     * If true the work item type is the default work item type in the behavior
     */
    "isDefault"?: boolean;

    /**
     * URL of the work item type behavior
     */
    "url"?: string;
}

/**
 * Describes a work item type category.
 */
export interface WorkItemTypeCategory extends WorkItemTrackingResource {
}

/**
 * Describes a work item type's colors.
 */
export interface WorkItemTypeColor {

    /**
     * Gets or sets the color of the primary.
     */
    "primaryColor"?: string;

    /**
     * Gets or sets the color of the secondary.
     */
    "secondaryColor"?: string;

    /**
     * The name of the work item type.
     */
    "workItemTypeName"?: string;
}

/**
 * Describes work item type nam, its icon and color.
 */
export interface WorkItemTypeColorAndIcon {

    /**
     * The color of the work item type in hex format.
     */
    "color"?: string;

    /**
     * Tthe work item type icon.
     */
    "icon"?: string;

    /**
     * The name of the work item type.
     */
    "workItemTypeName"?: string;
}

/**
 * Field instance of a work item type.
 */
export interface WorkItemTypeFieldInstance extends WorkItemTypeFieldInstanceBase {
}

/**
 * Base field instance for workItemType fields.
 */
export interface WorkItemTypeFieldInstanceBase extends WorkItemFieldReference {
}

/**
 * 
 */
export interface WorkItemTypeFieldModel {
    "allowGroups"?: boolean;
    "defaultValue"?: string;
    "name"?: string;
    "pickList"?: PickListMetadataModel;
    "readOnly"?: boolean;
    "referenceName"?: string;
    "required"?: boolean;
    "url"?: string;
}

/**
 * Field Instance of a workItemype with detailed references.
 */
export interface WorkItemTypeFieldWithReferences extends WorkItemTypeFieldInstanceBase {
}

/**
 * 
 */
export interface WorkItemTypeModel {

    /**
     * Behaviors of the work item type
     */
    "behaviors"?: Array<WorkItemTypeBehavior>;

    /**
     * Color of the work item type
     */
    "color"?: string;

    /**
     * Description of the work item type
     */
    "description"?: string;

    /**
     * Icon of the work item type
     */
    "icon"?: string;

    /**
     * The ID of the work item type
     */
    "id"?: string;

    /**
     * Parent WIT Id/Internal ReferenceName that it inherits from
     */
    "inherits"?: string;

    /**
     * Is work item type disabled
     */
    "isDisabled"?: boolean;

    /**
     * Layout of the work item type
     */
    "layout"?: FormLayout;

    /**
     * Name of the work item type
     */
    "name"?: string;

    /**
     * States of the work item type
     */
    "states"?: Array<WorkItemStateResultModel>;

    /**
     * Url of the work item type
     */
    "url"?: string;
}

/**
 * Reference to a work item type.
 */
export interface WorkItemTypeReference extends WorkItemTrackingResourceReference {
}

/**
 * State colors for a work item type
 */
export interface WorkItemTypeStateColors {

    /**
     * Work item type state colors
     */
    "stateColors"?: Array<WorkItemStateColor>;

    /**
     * Work item type name
     */
    "workItemTypeName"?: string;
}

/**
 * 
 */
export interface WorkItemTypeStateInfo {

    /**
     * State name to state category map
     */
    "states"?: { [key: string]: string; };

    /**
     * Work Item type name
     */
    "workItemTypeName"?: string;
}

/**
 * Describes a work item type template.
 */
export interface WorkItemTypeTemplate {

    /**
     * XML template in string format.
     */
    "template"?: string;
}

/**
 * Describes a update work item type template request body.
 */
export interface WorkItemTypeTemplateUpdateModel {

    /**
     * Methodology to which the template belongs, eg. Agile, Scrum, CMMI.
     */
    "methodology"?: string;

    /**
     * String representation of the work item type template.
     */
    "template"?: string;
}

/**
 * 
 */
export interface WorkItemTypeUpdateModel {

    /**
     * Color of the work item type
     */
    "color"?: string;

    /**
     * Description of the work item type
     */
    "description"?: string;

    /**
     * Icon of the work item type
     */
    "icon"?: string;

    /**
     * Is the workitem type to be disabled
     */
    "isDisabled"?: boolean;
}

/**
 * Describes an update to a work item.
 */
export interface WorkItemUpdate extends WorkItemTrackingResource {
}

/**
 * 
 */
export interface WorkflowTask {

    /**
     * Gets or sets as the task always run or not.
     */
    "alwaysRun"?: boolean;

    /**
     * Gets or sets the task condition.
     */
    "condition"?: string;

    /**
     * Gets or sets as the task continue run on error or not.
     */
    "continueOnError"?: boolean;

    /**
     * Gets or sets the task definition type. Example:- 'Agent', DeploymentGroup', 'Server' or 'ServerGate'.
     */
    "definitionType"?: string;

    /**
     * Gets or sets as the task enabled or not.
     */
    "enabled"?: boolean;

    /**
     * Gets or sets the task environment variables.
     */
    "environment"?: { [key: string]: string; };

    /**
     * Gets or sets the task inputs.
     */
    "inputs"?: { [key: string]: string; };

    /**
     * Gets or sets the name of the task.
     */
    "name"?: string;

    /**
     * Gets or sets the task override inputs.
     */
    "overrideInputs"?: { [key: string]: string; };

    /**
     * Gets or sets the reference name of the task.
     */
    "refName"?: string;

    /**
     * Gets or sets the ID of the task.
     */
    "taskId"?: string;

    /**
     * Gets or sets the task timeout.
     */
    "timeoutInMinutes"?: number;

    /**
     * Gets or sets the version of the task.
     */
    "version"?: string;
}

/**
 * 
 */
export interface WorkflowTaskReference {

    /**
     * Task identifier.
     */
    "id"?: string;

    /**
     * Name of the task.
     */
    "name"?: string;

    /**
     * Version of the task.
     */
    "version"?: string;
}

/**
 * Mapping for a workspace
 */
export interface WorkspaceMapping {

    /**
     * Uri of the associated definition
     */
    "definitionUri"?: string;

    /**
     * Depth of this mapping
     */
    "depth"?: number;

    /**
     * local location of the definition
     */
    "localItem"?: string;

    /**
     * Server location of the definition
     */
    "serverItem"?: string;

    /**
     * Id of the workspace
     */
    "workspaceId"?: number;
}

/**
 * 
 */
export interface WorkspaceTemplate {

    /**
     * Uri of the associated definition
     */
    "definitionUri"?: string;

    /**
     * The identity that last modified this template
     */
    "lastModifiedBy"?: string;

    /**
     * The last time this template was modified
     */
    "lastModifiedDate"?: Date;

    /**
     * List of workspace mappings
     */
    "mappings"?: Array<WorkspaceMapping>;

    /**
     * Id of the workspace for this template
     */
    "workspaceId"?: number;
}

/**
 * 
 */
export interface XamlBuildControllerReference {

    /**
     * Id of the resource
     */
    "id"?: number;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface XamlBuildDefinition extends DefinitionReference {
}

/**
 * 
 */
export interface XamlBuildReference {

    /**
     * Id of the resource
     */
    "id"?: number;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface XamlBuildServerReference {

    /**
     * Id of the resource
     */
    "id"?: number;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface XamlDefinitionReference {

    /**
     * Id of the resource
     */
    "id"?: number;

    /**
     * Name of the linked resource (definition name, controller name, etc.)
     */
    "name"?: string;

    /**
     * Full http link to the resource
     */
    "url"?: string;
}

/**
 * 
 */
export interface YamlFileSource {

    /**
     * Gets or sets definition reference. e.g. {"project":{"id":"fed755ea-49c5-4399-acea-fd5b5aa90a6c","name":"myProject"},"definition":{"id":"1","name":"mybuildDefinition"},"connection":{"id":"1","name":"myConnection"}}
     */
    "sourceReference"?: { [key: string]: YamlSourceReference; };
}

/**
 * 
 */
export interface YamlPipelineProcess extends PipelineProcess {
}

/**
 * 
 */
export interface YamlPipelineProcessResources {
    "endpoints"?: Array<ServiceEndpointReference>;
    "queues"?: Array<AgentPoolQueueReference>;
}

/**
 * Represents a YAML process.
 */
export interface YamlProcess extends BuildProcess {
}

/**
 * 
 */
export interface YamlSourceReference {
    "id"?: string;
    "name"?: string;
}


//export namespace  {
    'use strict';

    export class AccessControlEntriesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Remove the specified ACEs from the ACL belonging to the specified token.
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param token The token whose ACL should be modified.
         * @param descriptors String containing a list of identity descriptors separated by &#39;,&#39; whose entries should be removed.
         */
        public removeAccessControlEntries (params: {  securityNamespaceId: string; organization: string; apiVersion: string; token?: string; descriptors?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<boolean> {
            const localVarPath = this.basePath + '/{organization}/_apis/accesscontrolentries/{securityNamespaceId}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling removeAccessControlEntries');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeAccessControlEntries');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeAccessControlEntries');
            }
            if (params.token !== undefined) {
                queryParameters['token'] = params.token;
            }

            if (params.descriptors !== undefined) {
                queryParameters['descriptors'] = params.descriptors;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Add or update ACEs in the ACL for the provided token. The request body contains the target token, a list of [ACEs](https://docs.microsoft.com/en-us/rest/api/azure/devops/security/access%20control%20entries/set%20access%20control%20entries?#accesscontrolentry) and a optional merge parameter. In the case of a collision (by identity descriptor) with an existing ACE in the ACL, the &quot;merge&quot; parameter determines the behavior. If set, the existing ACE has its allow and deny merged with the incoming ACE&#39;s allow and deny. If unset, the existing ACE is displaced.
         * @param body 
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setAccessControlEntries (params: {  body: JObject; securityNamespaceId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AccessControlEntry>> {
            const localVarPath = this.basePath + '/{organization}/_apis/accesscontrolentries/{securityNamespaceId}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setAccessControlEntries');
            }
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling setAccessControlEntries');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setAccessControlEntries');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setAccessControlEntries');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccessControlListsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Return a list of access control lists for the specified security namespace and token. All ACLs in the security namespace will be retrieved if no optional parameters are provided.
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param token Security token
         * @param descriptors An optional filter string containing a list of identity descriptors separated by &#39;,&#39; whose ACEs should be retrieved. If this is left null, entire ACLs will be returned.
         * @param includeExtendedInfo If true, populate the extended information properties for the access control entries contained in the returned lists.
         * @param recurse If true and this is a hierarchical namespace, return child ACLs of the specified token.
         */
        public queryAccessControlLists (params: {  securityNamespaceId: string; organization: string; apiVersion: string; token?: string; descriptors?: string; includeExtendedInfo?: boolean; recurse?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AccessControlList>> {
            const localVarPath = this.basePath + '/{organization}/_apis/accesscontrollists/{securityNamespaceId}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling queryAccessControlLists');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryAccessControlLists');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryAccessControlLists');
            }
            if (params.token !== undefined) {
                queryParameters['token'] = params.token;
            }

            if (params.descriptors !== undefined) {
                queryParameters['descriptors'] = params.descriptors;
            }

            if (params.includeExtendedInfo !== undefined) {
                queryParameters['includeExtendedInfo'] = params.includeExtendedInfo;
            }

            if (params.recurse !== undefined) {
                queryParameters['recurse'] = params.recurse;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Remove access control lists under the specfied security namespace.
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param tokens One or more comma-separated security tokens
         * @param recurse If true and this is a hierarchical namespace, also remove child ACLs of the specified tokens.
         */
        public removeAccessControlLists (params: {  securityNamespaceId: string; organization: string; apiVersion: string; tokens?: string; recurse?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<boolean> {
            const localVarPath = this.basePath + '/{organization}/_apis/accesscontrollists/{securityNamespaceId}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling removeAccessControlLists');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeAccessControlLists');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeAccessControlLists');
            }
            if (params.tokens !== undefined) {
                queryParameters['tokens'] = params.tokens;
            }

            if (params.recurse !== undefined) {
                queryParameters['recurse'] = params.recurse;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create or update one or more access control lists. All data that currently exists for the ACLs supplied will be overwritten.
         * @param body A list of ACLs to create or update.
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setAccessControlLists (params: {  body: VssJsonCollectionWrapper; securityNamespaceId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/accesscontrollists/{securityNamespaceId}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setAccessControlLists');
            }
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling setAccessControlLists');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setAccessControlLists');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setAccessControlLists');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountMyWorkRecentActivityApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets recent work item activities
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getRecentActivityData (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AccountRecentActivityWorkItemModel2>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/accountmyworkrecentactivity'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecentActivityData');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecentActivityData');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AccountsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a list of accounts for a specific owner or a specific member.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param ownerId ID for the owner of the accounts.
         * @param memberId ID for a member of the accounts.
         * @param properties 
         */
        public getAccounts (params: {  apiVersion: string; ownerId?: string; memberId?: string; properties?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Account>> {
            const localVarPath = this.basePath + '/_apis/accounts';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAccounts');
            }
            if (params.ownerId !== undefined) {
                queryParameters['ownerId'] = params.ownerId;
            }

            if (params.memberId !== undefined) {
                queryParameters['memberId'] = params.memberId;
            }

            if (params.properties !== undefined) {
                queryParameters['properties'] = params.properties;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ActionResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the action results for an iteration in a test result.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result that contains the iterations.
         * @param iterationId ID of the iteration that contains the actions.
         * @param actionPath Path of a specific action, used to get just that action.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getActionResults (params: {  organization: string; project: string; runId: number; testCaseResultId: number; iterationId: number; actionPath: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestActionResultModel>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/Iterations/{iterationId}/actionresults/{actionPath}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'actionPath' + '}', String(params.actionPath));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getActionResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getActionResults');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getActionResults');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getActionResults');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getActionResults');
            }
            // verify required parameter 'actionPath' is set
            if (params.actionPath == null) {
                throw new Error('Missing required parameter actionPath when calling getActionResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getActionResults');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgentGroupsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body Agent group to be created
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createAgentGroup (params: {  organization: string; body: AgentGroup; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<AgentGroup> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/agentgroups'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createAgentGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createAgentGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createAgentGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentGroupId The agent group indentifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param machineSetupInput 
         * @param machineAccessData 
         * @param outgoingRequestUrls 
         * @param agentGroupName Name of the agent group
         */
        public getAgentGroups (params: {  organization: string; agentGroupId: string; apiVersion: string; machineSetupInput?: boolean; machineAccessData?: boolean; outgoingRequestUrls?: boolean; agentGroupName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<any> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/agentgroups/{agentGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentGroupId' + '}', String(params.agentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAgentGroups');
            }
            // verify required parameter 'agentGroupId' is set
            if (params.agentGroupId == null) {
                throw new Error('Missing required parameter agentGroupId when calling getAgentGroups');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAgentGroups');
            }
            if (params.machineSetupInput !== undefined) {
                queryParameters['machineSetupInput'] = params.machineSetupInput;
            }

            if (params.machineAccessData !== undefined) {
                queryParameters['machineAccessData'] = params.machineAccessData;
            }

            if (params.outgoingRequestUrls !== undefined) {
                queryParameters['outgoingRequestUrls'] = params.outgoingRequestUrls;
            }

            if (params.agentGroupName !== undefined) {
                queryParameters['agentGroupName'] = params.agentGroupName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgentcloudsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addAgentCloud (params: {  organization: string; body: TaskAgentCloud; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TaskAgentCloud> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentclouds'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addAgentCloud');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addAgentCloud');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addAgentCloud');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentCloudId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteAgentCloud (params: {  organization: string; agentCloudId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TaskAgentCloud> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentclouds/{agentCloudId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentCloudId' + '}', String(params.agentCloudId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteAgentCloud');
            }
            // verify required parameter 'agentCloudId' is set
            if (params.agentCloudId == null) {
                throw new Error('Missing required parameter agentCloudId when calling deleteAgentCloud');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteAgentCloud');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentCloudId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAgentCloud (params: {  organization: string; agentCloudId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TaskAgentCloud> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentclouds/{agentCloudId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentCloudId' + '}', String(params.agentCloudId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAgentCloud');
            }
            // verify required parameter 'agentCloudId' is set
            if (params.agentCloudId == null) {
                throw new Error('Missing required parameter agentCloudId when calling getAgentCloud');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAgentCloud');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAgentClouds (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TaskAgentCloud>> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentclouds'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAgentClouds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAgentClouds');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgentcloudtypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get agent cloud types.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAgentCloudTypes (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TaskAgentCloudType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentcloudtypes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAgentCloudTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAgentCloudTypes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AgentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentGroupId The agent group identifier
         * @param agentName Name of the static agent
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteStaticAgent (params: {  organization: string; agentGroupId: string; agentName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/agentGroups/{agentGroupId}/agents'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentGroupId' + '}', String(params.agentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteStaticAgent');
            }
            // verify required parameter 'agentGroupId' is set
            if (params.agentGroupId == null) {
                throw new Error('Missing required parameter agentGroupId when calling deleteStaticAgent');
            }
            // verify required parameter 'agentName' is set
            if (params.agentName == null) {
                throw new Error('Missing required parameter agentName when calling deleteStaticAgent');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteStaticAgent');
            }
            if (params.agentName !== undefined) {
                queryParameters['agentName'] = params.agentName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentGroupId The agent group identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param agentName Name of the static agent
         */
        public getStaticAgents (params: {  organization: string; agentGroupId: string; apiVersion: string; agentName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<any> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/agentGroups/{agentGroupId}/agents'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentGroupId' + '}', String(params.agentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStaticAgents');
            }
            // verify required parameter 'agentGroupId' is set
            if (params.agentGroupId == null) {
                throw new Error('Missing required parameter agentGroupId when calling getStaticAgents');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStaticAgents');
            }
            if (params.agentName !== undefined) {
                queryParameters['agentName'] = params.agentName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AnnotatedTagsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create an annotated tag.  Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don&#39;t need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
         * @param organization The name of the Azure DevOps organization.
         * @param body Object containing details of tag to be created.
         * @param project Project ID or project name
         * @param repositoryId ID or name of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createAnnotatedTag (params: {  organization: string; body: GitAnnotatedTag; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitAnnotatedTag> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createAnnotatedTag');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createAnnotatedTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createAnnotatedTag');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createAnnotatedTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createAnnotatedTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get an annotated tag.  Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don&#39;t need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId ID or name of the repository.
         * @param objectId ObjectId (Sha1Id) of tag to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAnnotatedTag (params: {  organization: string; project: string; repositoryId: string; objectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitAnnotatedTag> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/annotatedtags/{objectId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'objectId' + '}', String(params.objectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAnnotatedTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAnnotatedTag');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getAnnotatedTag');
            }
            // verify required parameter 'objectId' is set
            if (params.objectId == null) {
                throw new Error('Missing required parameter objectId when calling getAnnotatedTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAnnotatedTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ApplicationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param applicationId Filter by APM application identifier.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getApplication (params: {  organization: string; applicationId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Application> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/apm/applications/{applicationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'applicationId' + '}', String(params.applicationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getApplication');
            }
            // verify required parameter 'applicationId' is set
            if (params.applicationId == null) {
                throw new Error('Missing required parameter applicationId when calling getApplication');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getApplication');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param type Filters the results based on the plugin type.
         */
        public getApplications (params: {  organization: string; apiVersion: string; type?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Application>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/apm/applications'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getApplications');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getApplications');
            }
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ApprovalsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a list of approvals
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param assignedToFilter Approvals assigned to this user.
         * @param statusFilter Approvals with this status. Default is &#39;pending&#39;.
         * @param releaseIdsFilter Approvals for release id(s) mentioned in the filter. Multiple releases can be mentioned by separating them with &#39;,&#39; e.g. releaseIdsFilter&#x3D;1,2,3,4.
         * @param typeFilter Approval with this type.
         * @param top Number of approvals to get. Default is 50.
         * @param continuationToken Gets the approvals after the continuation token provided.
         * @param queryOrder Gets the results in the defined order of created approvals. Default is &#39;descending&#39;.
         * @param includeMyGroupApprovals &#39;true&#39; to include my group approvals. Default is &#39;false&#39;.
         */
        public getApprovals (params: {  organization: string; project: string; apiVersion: string; assignedToFilter?: string; statusFilter?: string; releaseIdsFilter?: string; typeFilter?: string; top?: number; continuationToken?: number; queryOrder?: string; includeMyGroupApprovals?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ReleaseApproval>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/approvals'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getApprovals');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getApprovals');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getApprovals');
            }
            if (params.assignedToFilter !== undefined) {
                queryParameters['assignedToFilter'] = params.assignedToFilter;
            }

            if (params.statusFilter !== undefined) {
                queryParameters['statusFilter'] = params.statusFilter;
            }

            if (params.releaseIdsFilter !== undefined) {
                queryParameters['releaseIdsFilter'] = params.releaseIdsFilter;
            }

            if (params.typeFilter !== undefined) {
                queryParameters['typeFilter'] = params.typeFilter;
            }

            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.includeMyGroupApprovals !== undefined) {
                queryParameters['includeMyGroupApprovals'] = params.includeMyGroupApprovals;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update status of an approval
         * @param organization The name of the Azure DevOps organization.
         * @param body ReleaseApproval object having status, approver and comments.
         * @param project Project ID or project name
         * @param approvalId Id of the approval.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public updateReleaseApproval (params: {  organization: string; body: ReleaseApproval; project: string; approvalId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseApproval> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/approvals/{approvalId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'approvalId' + '}', String(params.approvalId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateReleaseApproval');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateReleaseApproval');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateReleaseApproval');
            }
            // verify required parameter 'approvalId' is set
            if (params.approvalId == null) {
                throw new Error('Missing required parameter approvalId when calling updateReleaseApproval');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateReleaseApproval');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ArtifactDetailsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Generate a SVG badge for the latest version of a package.  The generated SVG is typically used as the image in an HTML link which takes users to the feed containing the package to accelerate discovery and consumption.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId Id of the package (GUID Id, not name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBadge (params: {  organization: string; feedId: string; packageId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/public/packaging/Feeds/{feedId}/Packages/{packageId}/badge'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBadge');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getBadge');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getBadge');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBadge');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get details about a specific package.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId The package Id (GUID Id, not the package name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeAllVersions True to return all versions of the package in the response.  Default is false (latest version only).
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         * @param isListed Only applicable for NuGet packages, setting it for other package types will result in a 404.  If false, delisted package versions will be returned. Use this to filter the response when includeAllVersions is set to true.  Default is unset (do not return delisted packages).
         * @param isRelease Only applicable for Nuget packages.  Use this to filter the response when includeAllVersions is set to true.  Default is True (only return packages without prerelease versioning).
         * @param includeDeleted Return deleted or unpublished versions of packages in the response. Default is False.
         * @param includeDescription Return the description for every version of each package in the response.  Default is False.
         */
        public getPackage (params: {  organization: string; feedId: string; packageId: string; apiVersion: string; includeAllVersions?: boolean; includeUrls?: boolean; isListed?: boolean; isRelease?: boolean; includeDeleted?: boolean; includeDescription?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/packages/{packageId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackage');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackage');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getPackage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackage');
            }
            if (params.includeAllVersions !== undefined) {
                queryParameters['includeAllVersions'] = params.includeAllVersions;
            }

            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.isListed !== undefined) {
                queryParameters['isListed'] = params.isListed;
            }

            if (params.isRelease !== undefined) {
                queryParameters['isRelease'] = params.isRelease;
            }

            if (params.includeDeleted !== undefined) {
                queryParameters['includeDeleted'] = params.includeDeleted;
            }

            if (params.includeDescription !== undefined) {
                queryParameters['includeDescription'] = params.includeDescription;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get details about a specific package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId Id of the package (GUID Id, not name).
         * @param packageVersionId Id of the package version (GUID Id, not name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeUrls True to include urls for each version.  Default is true.
         * @param isListed Only applicable for NuGet packages.  If false, delisted package versions will be returned.
         * @param isDeleted Return deleted or unpublished versions of packages in the response. Default is unset (do not return deleted versions).
         */
        public getPackageVersion (params: {  organization: string; feedId: string; packageId: string; packageVersionId: string; apiVersion: string; includeUrls?: boolean; isListed?: boolean; isDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PackageVersion> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/Packages/{packageId}/versions/{packageVersionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId))
                .replace('{' + 'packageVersionId' + '}', String(params.packageVersionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersion');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getPackageVersion');
            }
            // verify required parameter 'packageVersionId' is set
            if (params.packageVersionId == null) {
                throw new Error('Missing required parameter packageVersionId when calling getPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersion');
            }
            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.isListed !== undefined) {
                queryParameters['isListed'] = params.isListed;
            }

            if (params.isDeleted !== undefined) {
                queryParameters['isDeleted'] = params.isDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets provenance for a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId Id of the package (GUID Id, not name).
         * @param packageVersionId Id of the package version (GUID Id, not name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionProvenance (params: {  organization: string; feedId: string; packageId: string; packageVersionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PackageVersionProvenance> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/Packages/{packageId}/Versions/{packageVersionId}/provenance'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId))
                .replace('{' + 'packageVersionId' + '}', String(params.packageVersionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionProvenance');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersionProvenance');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getPackageVersionProvenance');
            }
            // verify required parameter 'packageVersionId' is set
            if (params.packageVersionId == null) {
                throw new Error('Missing required parameter packageVersionId when calling getPackageVersionProvenance');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionProvenance');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of package versions, optionally filtering by state.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId Id of the package (GUID Id, not name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeUrls True to include urls for each version.  Default is true.
         * @param isListed Only applicable for NuGet packages.  If false, delisted package versions will be returned.
         * @param isDeleted Return deleted or unpublished versions of packages in the response. Default is unset (do not return deleted versions).
         */
        public getPackageVersions (params: {  organization: string; feedId: string; packageId: string; apiVersion: string; includeUrls?: boolean; isListed?: boolean; isDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PackageVersion>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/Packages/{packageId}/versions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersions');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersions');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getPackageVersions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersions');
            }
            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.isListed !== undefined) {
                queryParameters['isListed'] = params.isListed;
            }

            if (params.isDeleted !== undefined) {
                queryParameters['isDeleted'] = params.isDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get details about all of the packages in the feed.  Use the various filters to include or exclude information from the result set.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param protocolType One of the supported artifact package types.
         * @param packageNameQuery Filter to packages that contain the provided string.  Characters in the string must conform to the package name constraints.
         * @param normalizedPackageName [Obsolete] Used for legacy scenarios and may be removed in future versions.
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         * @param includeAllVersions True to return all versions of the package in the response.  Default is false (latest version only).
         * @param isListed Only applicable for NuGet packages, setting it for other package types will result in a 404.  If false, delisted package versions will be returned. Use this to filter the response when includeAllVersions is set to true.  Default is unset (do not return delisted packages).
         * @param getTopPackageVersions Changes the behavior of $top and $skip to return all versions of each package up to $top. Must be used in conjunction with includeAllVersions&#x3D;true
         * @param isRelease Only applicable for Nuget packages.  Use this to filter the response when includeAllVersions is set to true.  Default is True (only return packages without prerelease versioning).
         * @param includeDescription Return the description for every version of each package in the response.  Default is False.
         * @param $Top Get the top N packages (or package versions where getTopPackageVersions&#x3D;true)
         * @param $Skip Skip the first N packages (or package versions where getTopPackageVersions&#x3D;true)
         * @param includeDeleted Return deleted or unpublished versions of packages in the response. Default is False.
         * @param isCached [Obsolete]  Used for legacy scenarios and may be removed in future versions.
         * @param directUpstreamId Filter results to return packages from a specific upstream.
         */
        public getPackages (params: {  organization: string; feedId: string; apiVersion: string; protocolType?: string; packageNameQuery?: string; normalizedPackageName?: string; includeUrls?: boolean; includeAllVersions?: boolean; isListed?: boolean; getTopPackageVersions?: boolean; isRelease?: boolean; includeDescription?: boolean; $Top?: number; $Skip?: number; includeDeleted?: boolean; isCached?: boolean; directUpstreamId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ModelPackage>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/packages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackages');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackages');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackages');
            }
            if (params.protocolType !== undefined) {
                queryParameters['protocolType'] = params.protocolType;
            }

            if (params.packageNameQuery !== undefined) {
                queryParameters['packageNameQuery'] = params.packageNameQuery;
            }

            if (params.normalizedPackageName !== undefined) {
                queryParameters['normalizedPackageName'] = params.normalizedPackageName;
            }

            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.includeAllVersions !== undefined) {
                queryParameters['includeAllVersions'] = params.includeAllVersions;
            }

            if (params.isListed !== undefined) {
                queryParameters['isListed'] = params.isListed;
            }

            if (params.getTopPackageVersions !== undefined) {
                queryParameters['getTopPackageVersions'] = params.getTopPackageVersions;
            }

            if (params.isRelease !== undefined) {
                queryParameters['isRelease'] = params.isRelease;
            }

            if (params.includeDescription !== undefined) {
                queryParameters['includeDescription'] = params.includeDescription;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.includeDeleted !== undefined) {
                queryParameters['includeDeleted'] = params.includeDeleted;
            }

            if (params.isCached !== undefined) {
                queryParameters['isCached'] = params.isCached;
            }

            if (params.directUpstreamId !== undefined) {
                queryParameters['directUpstreamId'] = params.directUpstreamId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryPackageMetrics (params: {  organization: string; body: PackageMetricsQuery; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PackageMetrics>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/packagemetricsbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryPackageMetrics');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryPackageMetrics');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling queryPackageMetrics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryPackageMetrics');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId 
         * @param packageId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryPackageVersionMetrics (params: {  organization: string; body: PackageVersionMetricsQuery; feedId: string; packageId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PackageVersionMetrics>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/Packages/{packageId}/versionmetricsbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryPackageVersionMetrics');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryPackageVersionMetrics');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling queryPackageVersionMetrics');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling queryPackageVersionMetrics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryPackageVersionMetrics');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ArtifactLinkTypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get the list of work item tracking outbound artifact link types.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkArtifactLinkTypes (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkArtifactLink>> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/artifactlinktypes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkArtifactLinkTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkArtifactLinkTypes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ArtifactUriQueryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Queries work items linked to a given list of artifact URI.
         * @param organization The name of the Azure DevOps organization.
         * @param body Defines a list of artifact URI for querying work items.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryWorkItemsForArtifactUris (params: {  organization: string; body: ArtifactUriQuery; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ArtifactUriQueryResult> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/artifacturiquery'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryWorkItemsForArtifactUris');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryWorkItemsForArtifactUris');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryWorkItemsForArtifactUris');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryWorkItemsForArtifactUris');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ArtifactsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Associates an artifact with a build.
         * @param organization The name of the Azure DevOps organization.
         * @param body The artifact.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         */
        public createArtifact (params: {  organization: string; body: BuildArtifact; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildArtifact> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/artifacts'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createArtifact');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createArtifact');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createArtifact');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling createArtifact');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createArtifact');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets all artifacts for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         */
        public getArtifacts (params: {  organization: string; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildArtifact>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/artifacts'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getArtifacts');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getArtifacts');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getArtifacts');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getArtifacts');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AttachmentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates an attachment in the wiki.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param name Wiki attachment name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createAttachment (params: {  organization: string; body: string; project: string; wikiIdentifier: string; name: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiAttachment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createAttachment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createAttachment');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling createAttachment');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling createAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createAttachment');
            }
            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Uploads an attachment.  On accounts with higher attachment upload limits (&gt;130MB), you will need to use chunked upload. To upload an attachment in multiple chunks, you first need to [**Start a Chunked Upload**](#start_a_chunked_upload) and then follow the example from the **Upload Chunk** section.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fileName The name of the file
         * @param uploadType Attachment upload type: Simple or Chunked
         * @param areaPath Target project Area Path
         */
        public createAttachment_1 (params: {  organization: string; body: string; project: string; apiVersion: string; fileName?: string; uploadType?: string; areaPath?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<AttachmentReference> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createAttachment_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createAttachment_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createAttachment_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createAttachment_1');
            }
            if (params.fileName !== undefined) {
                queryParameters['fileName'] = params.fileName;
            }

            if (params.uploadType !== undefined) {
                queryParameters['uploadType'] = params.uploadType;
            }

            if (params.areaPath !== undefined) {
                queryParameters['areaPath'] = params.areaPath;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Attach a file to a test result.
         * @param organization The name of the Azure DevOps organization.
         * @param body Attachment details TestAttachmentRequestModel
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result against which attachment has to be uploaded.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestResultAttachment (params: {  organization: string; body: TestAttachmentRequestModel; project: string; runId: number; testCaseResultId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestAttachmentReference> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestResultAttachment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestResultAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestResultAttachment');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling createTestResultAttachment');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling createTestResultAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestResultAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Attach a file to a test run.
         * @param organization The name of the Azure DevOps organization.
         * @param body Attachment details TestAttachmentRequestModel
         * @param project Project ID or project name
         * @param runId ID of the test run against which attachment has to be uploaded.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestRunAttachment (params: {  organization: string; body: TestAttachmentRequestModel; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestAttachmentReference> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestRunAttachment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestRunAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestRunAttachment');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling createTestRunAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestRunAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a specific attachment.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param timelineId The ID of the timeline.
         * @param recordId The ID of the timeline record.
         * @param type The type of the attachment.
         * @param name The name of the attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getAttachment (params: {  organization: string; project: string; buildId: number; timelineId: string; recordId: string; type: string; name: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/{timelineId}/{recordId}/attachments/{type}/{name}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'timelineId' + '}', String(params.timelineId))
                .replace('{' + 'recordId' + '}', String(params.recordId))
                .replace('{' + 'type' + '}', String(params.type))
                .replace('{' + 'name' + '}', String(params.name));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAttachment');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getAttachment');
            }
            // verify required parameter 'timelineId' is set
            if (params.timelineId == null) {
                throw new Error('Missing required parameter timelineId when calling getAttachment');
            }
            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling getAttachment');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getAttachment');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling getAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Downloads an attachment.
         * @param organization The name of the Azure DevOps organization.
         * @param id Attachment ID
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fileName Name of the file
         * @param download If set to &lt;c&gt;true&lt;/c&gt; always download attachment
         */
        public getAttachment_2 (params: {  organization: string; id: string; project: string; apiVersion: string; fileName?: string; download?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/attachments/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAttachment_2');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getAttachment_2');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAttachment_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAttachment_2');
            }
            if (params.fileName !== undefined) {
                queryParameters['fileName'] = params.fileName;
            }

            if (params.download !== undefined) {
                queryParameters['download'] = params.download;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the list of attachments of a specific type that are associated with a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param type The type of attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getAttachments (params: {  organization: string; project: string; buildId: number; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Attachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/attachments/{type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAttachments');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getAttachments');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a release task attachment.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of the release environment.
         * @param attemptId Attempt number of deployment.
         * @param planId Plan Id of the deploy phase.
         * @param timelineId Timeline Id of the task.
         * @param recordId Record Id of attachment.
         * @param type Type of the attachment.
         * @param name Name of the attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getReleaseTaskAttachmentContent (params: {  organization: string; project: string; releaseId: number; environmentId: number; attemptId: number; planId: string; timelineId: string; recordId: string; type: string; name: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId))
                .replace('{' + 'attemptId' + '}', String(params.attemptId))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'timelineId' + '}', String(params.timelineId))
                .replace('{' + 'recordId' + '}', String(params.recordId))
                .replace('{' + 'type' + '}', String(params.type))
                .replace('{' + 'name' + '}', String(params.name));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'attemptId' is set
            if (params.attemptId == null) {
                throw new Error('Missing required parameter attemptId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'timelineId' is set
            if (params.timelineId == null) {
                throw new Error('Missing required parameter timelineId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling getReleaseTaskAttachmentContent');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseTaskAttachmentContent');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the release task attachments.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of the release environment.
         * @param attemptId Attempt number of deployment.
         * @param planId Plan Id of the deploy phase.
         * @param type Type of the attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getReleaseTaskAttachments (params: {  organization: string; project: string; releaseId: number; environmentId: number; attemptId: number; planId: string; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ReleaseTaskAttachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/plan/{planId}/attachments/{type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId))
                .replace('{' + 'attemptId' + '}', String(params.attemptId))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'attemptId' is set
            if (params.attemptId == null) {
                throw new Error('Missing required parameter attemptId when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getReleaseTaskAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseTaskAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * GetTaskAttachmentContent API is deprecated. Use GetReleaseTaskAttachmentContent API instead.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of the release environment.
         * @param attemptId Attempt number of deployment.
         * @param timelineId Timeline Id of the task.
         * @param recordId Record Id of attachment.
         * @param type Type of the attachment.
         * @param name Name of the attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTaskAttachmentContent (params: {  organization: string; project: string; releaseId: number; environmentId: number; attemptId: number; timelineId: string; recordId: string; type: string; name: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/records/{recordId}/attachments/{type}/{name}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId))
                .replace('{' + 'attemptId' + '}', String(params.attemptId))
                .replace('{' + 'timelineId' + '}', String(params.timelineId))
                .replace('{' + 'recordId' + '}', String(params.recordId))
                .replace('{' + 'type' + '}', String(params.type))
                .replace('{' + 'name' + '}', String(params.name));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTaskAttachmentContent');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTaskAttachmentContent');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getTaskAttachmentContent');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling getTaskAttachmentContent');
            }
            // verify required parameter 'attemptId' is set
            if (params.attemptId == null) {
                throw new Error('Missing required parameter attemptId when calling getTaskAttachmentContent');
            }
            // verify required parameter 'timelineId' is set
            if (params.timelineId == null) {
                throw new Error('Missing required parameter timelineId when calling getTaskAttachmentContent');
            }
            // verify required parameter 'recordId' is set
            if (params.recordId == null) {
                throw new Error('Missing required parameter recordId when calling getTaskAttachmentContent');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getTaskAttachmentContent');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling getTaskAttachmentContent');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTaskAttachmentContent');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * GetTaskAttachments API is deprecated. Use GetReleaseTaskAttachments API instead.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of the release environment.
         * @param attemptId Attempt number of deployment.
         * @param timelineId Timeline Id of the task.
         * @param type Type of the attachment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTaskAttachments (params: {  organization: string; project: string; releaseId: number; environmentId: number; attemptId: number; timelineId: string; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ReleaseTaskAttachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/attempts/{attemptId}/timelines/{timelineId}/attachments/{type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId))
                .replace('{' + 'attemptId' + '}', String(params.attemptId))
                .replace('{' + 'timelineId' + '}', String(params.timelineId))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTaskAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTaskAttachments');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getTaskAttachments');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling getTaskAttachments');
            }
            // verify required parameter 'attemptId' is set
            if (params.attemptId == null) {
                throw new Error('Missing required parameter attemptId when calling getTaskAttachments');
            }
            // verify required parameter 'timelineId' is set
            if (params.timelineId == null) {
                throw new Error('Missing required parameter timelineId when calling getTaskAttachments');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getTaskAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTaskAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Download a test result attachment by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the testCaseResultId.
         * @param testCaseResultId ID of the test result whose attachment has to be downloaded.
         * @param attachmentId ID of the test result attachment to be downloaded.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestResultAttachment (params: {  organization: string; project: string; runId: number; testCaseResultId: number; attachmentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/attachments/{attachmentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId))
                .replace('{' + 'attachmentId' + '}', String(params.attachmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestResultAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestResultAttachment');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestResultAttachment');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getTestResultAttachment');
            }
            // verify required parameter 'attachmentId' is set
            if (params.attachmentId == null) {
                throw new Error('Missing required parameter attachmentId when calling getTestResultAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestResultAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get list of test result attachments reference.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestResultAttachments (params: {  organization: string; project: string; runId: number; testCaseResultId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestAttachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestResultAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestResultAttachments');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestResultAttachments');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getTestResultAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestResultAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Download a test run attachment by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run whose attachment has to be downloaded.
         * @param attachmentId ID of the test run attachment to be downloaded.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestRunAttachment (params: {  organization: string; project: string; runId: number; attachmentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/attachments/{attachmentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'attachmentId' + '}', String(params.attachmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRunAttachment');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestRunAttachment');
            }
            // verify required parameter 'attachmentId' is set
            if (params.attachmentId == null) {
                throw new Error('Missing required parameter attachmentId when calling getTestRunAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get list of test run attachments reference.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestRunAttachments (params: {  organization: string; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestAttachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRunAttachments');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestRunAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Uploads an attachment chunk.  Before performing [**Upload a Chunk**](#upload_a_chunk), make sure to have an attachment id returned in **Start a Chunked Upload** example on **Create** section. Specify the byte range of the chunk using Content-Length. For example: &quot;Content - Length&quot;: &quot;bytes 0 - 39999 / 50000&quot; for the first 40000 bytes of a 50000 byte file.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param id The id of the attachment
         * @param contentRangeHeader starting and ending byte positions for chunked file upload, format is &quot;Content-Range&quot;: &quot;bytes 0-10000/50000&quot;
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fileName 
         */
        public uploadAttachment (params: {  organization: string; body: string; id: string; contentRangeHeader: string; project: string; apiVersion: string; fileName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<AttachmentReference> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/attachments/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling uploadAttachment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling uploadAttachment');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling uploadAttachment');
            }
            // verify required parameter 'contentRangeHeader' is set
            if (params.contentRangeHeader == null) {
                throw new Error('Missing required parameter contentRangeHeader when calling uploadAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling uploadAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling uploadAttachment');
            }
            if (params.fileName !== undefined) {
                queryParameters['fileName'] = params.fileName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['contentRangeHeader'] = params.contentRangeHeader;

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AuthorizedresourcesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public authorizeProjectResources (params: {  organization: string; body: Array<DefinitionResourceReference>; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DefinitionResourceReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/authorizedresources'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling authorizeProjectResources');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling authorizeProjectResources');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling authorizeProjectResources');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling authorizeProjectResources');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param type 
         * @param id 
         */
        public getProjectResources (params: {  organization: string; project: string; apiVersion: string; type?: string; id?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DefinitionResourceReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/authorizedresources'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProjectResources');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getProjectResources');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProjectResources');
            }
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.id !== undefined) {
                queryParameters['id'] = params.id;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AvailabilityApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Check the availability of symbol service. This includes checking for feature flag, and possibly license in future. Note this is NOT an anonymous endpoint, and the caller will be redirected to authentication before hitting it.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public checkAvailabilityAsync (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/availability'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling checkAvailabilityAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling checkAvailabilityAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class AvatarApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Removes the avatar for the project
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The id or name of the project
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeProjectAvatar (params: {  organization: string; projectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/avatar'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeProjectAvatar');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling removeProjectAvatar');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeProjectAvatar');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Upload avatar for the project
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param projectId The id or name of the project
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setProjectAvatar (params: {  organization: string; body: ProjectAvatar; projectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/avatar'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setProjectAvatar');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setProjectAvatar');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling setProjectAvatar');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setProjectAvatar');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BacklogconfigurationApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets backlog configuration for a team
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBacklogConfigurations (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BacklogConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/backlogconfiguration'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBacklogConfigurations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBacklogConfigurations');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBacklogConfigurations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBacklogConfigurations');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BacklogsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a backlog level
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param id The id of the backlog level
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBacklog (params: {  organization: string; project: string; team: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BacklogLevelConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/backlogs/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBacklog');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBacklog');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBacklog');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getBacklog');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBacklog');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of work items within a backlog level
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param backlogId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBacklogLevelWorkItems (params: {  organization: string; project: string; team: string; backlogId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BacklogLevelWorkItems> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/backlogs/{backlogId}/workItems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team))
                .replace('{' + 'backlogId' + '}', String(params.backlogId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBacklogLevelWorkItems');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBacklogLevelWorkItems');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBacklogLevelWorkItems');
            }
            // verify required parameter 'backlogId' is set
            if (params.backlogId == null) {
                throw new Error('Missing required parameter backlogId when calling getBacklogLevelWorkItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBacklogLevelWorkItems');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * List all backlog levels
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBacklogs (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BacklogLevelConfiguration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/backlogs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBacklogs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBacklogs');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBacklogs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBacklogs');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BadgeApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Use StatusBadgeController.GetStatusBadge
         * @param organization The name of the Azure DevOps organization.
         * @param project The project ID or name.
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param branchName The name of the branch.
         */
        public getBadge (params: {  organization: string; project: string; definitionId: number; apiVersion: string; branchName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/public/build/definitions/{project}/{definitionId}/badge'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBadge');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBadge');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getBadge');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBadge');
            }
            if (params.branchName !== undefined) {
                queryParameters['branchName'] = params.branchName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a badge that indicates the status of the most recent build for the specified branch.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repoType The repository type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param repoId The repository ID.
         * @param branchName The branch name.
         */
        public getBuildBadge (params: {  organization: string; project: string; repoType: string; apiVersion: string; repoId?: string; branchName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/repos/{repoType}/badge'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repoType' + '}', String(params.repoType));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildBadge');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildBadge');
            }
            // verify required parameter 'repoType' is set
            if (params.repoType == null) {
                throw new Error('Missing required parameter repoType when calling getBuildBadge');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildBadge');
            }
            if (params.repoId !== undefined) {
                queryParameters['repoId'] = params.repoId;
            }

            if (params.branchName !== undefined) {
                queryParameters['branchName'] = params.branchName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BehaviorsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a single behavior in the given process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createBehavior (params: {  organization: string; body: BehaviorCreateModel; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BehaviorModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createBehavior');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a single behavior in the given process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createProcessBehavior (params: {  organization: string; body: ProcessBehaviorCreateRequest; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createProcessBehavior');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createProcessBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createProcessBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createProcessBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a behavior in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param behaviorId The ID of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteBehavior (params: {  organization: string; processId: string; behaviorId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/behaviors/{behaviorId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorId' + '}', String(params.behaviorId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteBehavior');
            }
            // verify required parameter 'behaviorId' is set
            if (params.behaviorId == null) {
                throw new Error('Missing required parameter behaviorId when calling deleteBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a behavior in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteProcessBehavior (params: {  organization: string; processId: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteProcessBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteProcessBehavior');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling deleteProcessBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteProcessBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single behavior in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param behaviorId The ID of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehavior (params: {  organization: string; processId: string; behaviorId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BehaviorModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/behaviors/{behaviorId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorId' + '}', String(params.behaviorId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehavior');
            }
            // verify required parameter 'behaviorId' is set
            if (params.behaviorId == null) {
                throw new Error('Missing required parameter behaviorId when calling getBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of behaviors for the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviors (params: {  organization: string; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AdminBehavior>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processadmin/{processId}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviors');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviors');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviors');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all behaviors in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviors_1 (params: {  organization: string; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BehaviorModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviors_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviors_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviors_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a behavior of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand 
         */
        public getProcessBehavior (params: {  organization: string; processId: string; behaviorRefName: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessBehavior');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling getProcessBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessBehavior');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all behaviors in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand 
         */
        public getProcessBehaviors (params: {  organization: string; processId: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProcessBehavior>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessBehaviors');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessBehaviors');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessBehaviors');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replaces a behavior in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param behaviorId The ID of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public replaceBehavior (params: {  organization: string; body: BehaviorReplaceModel; processId: string; behaviorId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BehaviorModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/behaviors/{behaviorId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorId' + '}', String(params.behaviorId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceBehavior');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling replaceBehavior');
            }
            // verify required parameter 'behaviorId' is set
            if (params.behaviorId == null) {
                throw new Error('Missing required parameter behaviorId when calling replaceBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replaces a behavior in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateProcessBehavior (params: {  organization: string; body: ProcessBehaviorUpdateRequest; processId: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateProcessBehavior');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateProcessBehavior');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateProcessBehavior');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling updateProcessBehavior');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateProcessBehavior');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BlobsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a single blob.  Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don&#39;t need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID).
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param sha1 SHA1 hash of the file. You can get the SHA1 of a file using the &quot;Git/Items/Get Item&quot; endpoint.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param download If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
         * @param fileName Provide a fileName to use for a download.
         * @param $Format Options: json, zip, text, octetstream. If not set, defaults to the MIME type set in the Accept header.
         * @param resolveLfs If true, try to resolve a blob to its LFS contents, if it&#39;s an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
         */
        public getBlob (params: {  organization: string; repositoryId: string; sha1: string; project: string; apiVersion: string; download?: boolean; fileName?: string; $Format?: string; resolveLfs?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitBlobRef> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/blobs/{sha1}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'sha1' + '}', String(params.sha1))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBlob');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getBlob');
            }
            // verify required parameter 'sha1' is set
            if (params.sha1 == null) {
                throw new Error('Missing required parameter sha1 when calling getBlob');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBlob');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBlob');
            }
            if (params.download !== undefined) {
                queryParameters['download'] = params.download;
            }

            if (params.fileName !== undefined) {
                queryParameters['fileName'] = params.fileName;
            }

            if (params.$Format !== undefined) {
                queryParameters['$format'] = params.$Format;
            }

            if (params.resolveLfs !== undefined) {
                queryParameters['resolveLfs'] = params.resolveLfs;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets one or more blobs in a zip file download.
         * @param organization The name of the Azure DevOps organization.
         * @param body Blob IDs (SHA1 hashes) to be returned in the zip file.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param filename 
         */
        public getBlobs (params: {  organization: string; body: Array<string>; repositoryId: string; project: string; apiVersion: string; filename?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/blobs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBlobs');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getBlobs');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getBlobs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBlobs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBlobs');
            }
            if (params.filename !== undefined) {
                queryParameters['filename'] = params.filename;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardcolumnsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get available board columns in a project
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getColumnSuggestedValues (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardSuggestedValue>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/boardcolumns'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getColumnSuggestedValues');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getColumnSuggestedValues');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getColumnSuggestedValues');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardparentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Returns the list of parent field filter model for the given list of workitem ids
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param childBacklogContextCategoryRefName 
         * @param workitemIds 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardMappingParentItems (params: {  organization: string; project: string; childBacklogContextCategoryRefName: string; workitemIds: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ParentChildWIMap>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/boardparents'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardMappingParentItems');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardMappingParentItems');
            }
            // verify required parameter 'childBacklogContextCategoryRefName' is set
            if (params.childBacklogContextCategoryRefName == null) {
                throw new Error('Missing required parameter childBacklogContextCategoryRefName when calling getBoardMappingParentItems');
            }
            // verify required parameter 'workitemIds' is set
            if (params.workitemIds == null) {
                throw new Error('Missing required parameter workitemIds when calling getBoardMappingParentItems');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardMappingParentItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardMappingParentItems');
            }
            if (params.childBacklogContextCategoryRefName !== undefined) {
                queryParameters['childBacklogContextCategoryRefName'] = params.childBacklogContextCategoryRefName;
            }

            if (params.workitemIds !== undefined) {
                queryParameters['workitemIds'] = params.workitemIds;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardrowsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get available board rows in a project
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRowSuggestedValues (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardSuggestedValue>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/boardrows'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRowSuggestedValues');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRowSuggestedValues');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRowSuggestedValues');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get board
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id identifier for board, either board&#39;s backlog level name (Eg:&quot;Stories&quot;) or Id
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoard (params: {  organization: string; project: string; id: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Board> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoard');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoard');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getBoard');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoard');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoard');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get boards
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoards (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoards');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoards');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoards');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoards');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update board options
         * @param organization The name of the Azure DevOps organization.
         * @param body options to updated
         * @param project Project ID or project name
         * @param id identifier for board, either category plural name (Eg:&quot;Stories&quot;) or guid
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setBoardOptions (params: {  organization: string; body: any; project: string; id: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{ [key: string]: string; }> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setBoardOptions');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setBoardOptions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling setBoardOptions');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling setBoardOptions');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling setBoardOptions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setBoardOptions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BoardusersettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get board user settings for a board id
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board Board ID or Name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardUserSettings (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardUserSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/boardusersettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardUserSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardUserSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardUserSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardUserSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardUserSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update board user settings for the board id  We don&#39;t want stakeholders to update board settings (currently just autorefresh). The BacklogManagement feature check validates this.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param board 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardUserSettings (params: {  organization: string; body: any; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardUserSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/boardusersettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardUserSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardUserSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardUserSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardUserSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardUserSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardUserSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BranchesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get branch hierarchies below the specified scopePath
         * @param organization The name of the Azure DevOps organization.
         * @param scopePath Full path to the branch.  Default: $/ Examples: $/, $/MyProject, $/MyProject/SomeFolder.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeDeleted Return deleted branches. Default: False
         * @param includeLinks Return links. Default: False
         */
        public getBranchRefs (params: {  organization: string; scopePath: string; project: string; apiVersion: string; includeDeleted?: boolean; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcBranchRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/branches'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBranchRefs');
            }
            // verify required parameter 'scopePath' is set
            if (params.scopePath == null) {
                throw new Error('Missing required parameter scopePath when calling getBranchRefs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBranchRefs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBranchRefs');
            }
            if (params.scopePath !== undefined) {
                queryParameters['scopePath'] = params.scopePath;
            }

            if (params.includeDeleted !== undefined) {
                queryParameters['includeDeleted'] = params.includeDeleted;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class BuildsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Deletes a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         */
        public deleteBuild (params: {  organization: string; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteBuild');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteBuild');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling deleteBuild');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteBuild');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a build
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         * @param propertyFilters 
         */
        public getBuild (params: {  organization: string; project: string; buildId: number; apiVersion: string; propertyFilters?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Build> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuild');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuild');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuild');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuild');
            }
            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the changes associated with a build
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param continuationToken 
         * @param $Top The maximum number of changes to return
         * @param includeSourceChange 
         */
        public getBuildChanges (params: {  organization: string; project: string; buildId: number; apiVersion: string; continuationToken?: string; $Top?: number; includeSourceChange?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Change>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/changes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildChanges');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildChanges');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildChanges');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.includeSourceChange !== undefined) {
                queryParameters['includeSourceChange'] = params.includeSourceChange;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets an individual log file for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param logId The ID of the log file.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param startLine The start line.
         * @param endLine The end line.
         */
        public getBuildLog (params: {  organization: string; project: string; buildId: number; logId: number; apiVersion: string; startLine?: number; endLine?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'logId' + '}', String(params.logId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildLog');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildLog');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildLog');
            }
            // verify required parameter 'logId' is set
            if (params.logId == null) {
                throw new Error('Missing required parameter logId when calling getBuildLog');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildLog');
            }
            if (params.startLine !== undefined) {
                queryParameters['startLine'] = params.startLine;
            }

            if (params.endLine !== undefined) {
                queryParameters['endLine'] = params.endLine;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the logs for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getBuildLogs (params: {  organization: string; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildLog>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/logs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildLogs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildLogs');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildLogs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildLogs');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the work items associated with a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Top The maximum number of work items to return.
         */
        public getBuildWorkItemsRefs (params: {  organization: string; project: string; buildId: number; apiVersion: string; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ResourceRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildWorkItemsRefs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildWorkItemsRefs');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildWorkItemsRefs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildWorkItemsRefs');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the work items associated with a build, filtered to specific commits.
         * @param organization The name of the Azure DevOps organization.
         * @param body A comma-delimited list of commit IDs.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Top The maximum number of work items to return, or the number of commits to consider if no commit IDs are specified.
         */
        public getBuildWorkItemsRefsFromCommits (params: {  organization: string; body: Array<string>; project: string; buildId: number; apiVersion: string; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ResourceRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildWorkItemsRefsFromCommits');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getBuildWorkItemsRefsFromCommits');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildWorkItemsRefsFromCommits');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildWorkItemsRefsFromCommits');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildWorkItemsRefsFromCommits');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of builds.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         * @param definitions A comma-delimited list of definition IDs. If specified, filters to builds for these definitions.
         * @param queues A comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.
         * @param buildNumber If specified, filters to builds that match this build number. Append * to do a prefix search.
         * @param minTime If specified, filters to builds that finished/started/queued after this date based on the queryOrder specified.
         * @param maxTime If specified, filters to builds that finished/started/queued before this date based on the queryOrder specified.
         * @param requestedFor If specified, filters to builds requested for the specified user.
         * @param reasonFilter If specified, filters to builds that match this reason.
         * @param statusFilter If specified, filters to builds that match this status.
         * @param resultFilter If specified, filters to builds that match this result.
         * @param tagFilters A comma-delimited list of tags. If specified, filters to builds that have the specified tags.
         * @param properties A comma-delimited list of properties to retrieve.
         * @param $Top The maximum number of builds to return.
         * @param continuationToken A continuation token, returned by a previous call to this method, that can be used to return the next set of builds.
         * @param maxBuildsPerDefinition The maximum number of builds to return per definition.
         * @param deletedFilter Indicates whether to exclude, include, or only return deleted builds.
         * @param queryOrder The order in which builds should be returned.
         * @param branchName If specified, filters to builds that built branches that built this branch.
         * @param buildIds A comma-delimited list that specifies the IDs of builds to retrieve.
         * @param repositoryId If specified, filters to builds that built from this repository.
         * @param repositoryType If specified, filters to builds that built from repositories of this type.
         */
        public getBuilds (params: {  organization: string; project: string; apiVersion: string; definitions?: string; queues?: string; buildNumber?: string; minTime?: Date; maxTime?: Date; requestedFor?: string; reasonFilter?: string; statusFilter?: string; resultFilter?: string; tagFilters?: string; properties?: string; $Top?: number; continuationToken?: string; maxBuildsPerDefinition?: number; deletedFilter?: string; queryOrder?: string; branchName?: string; buildIds?: string; repositoryId?: string; repositoryType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Build>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuilds');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuilds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuilds');
            }
            if (params.definitions !== undefined) {
                queryParameters['definitions'] = params.definitions;
            }

            if (params.queues !== undefined) {
                queryParameters['queues'] = params.queues;
            }

            if (params.buildNumber !== undefined) {
                queryParameters['buildNumber'] = params.buildNumber;
            }

            if (params.minTime !== undefined) {
                queryParameters['minTime'] = params.minTime;
            }

            if (params.maxTime !== undefined) {
                queryParameters['maxTime'] = params.maxTime;
            }

            if (params.requestedFor !== undefined) {
                queryParameters['requestedFor'] = params.requestedFor;
            }

            if (params.reasonFilter !== undefined) {
                queryParameters['reasonFilter'] = params.reasonFilter;
            }

            if (params.statusFilter !== undefined) {
                queryParameters['statusFilter'] = params.statusFilter;
            }

            if (params.resultFilter !== undefined) {
                queryParameters['resultFilter'] = params.resultFilter;
            }

            if (params.tagFilters !== undefined) {
                queryParameters['tagFilters'] = params.tagFilters;
            }

            if (params.properties !== undefined) {
                queryParameters['properties'] = params.properties;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.maxBuildsPerDefinition !== undefined) {
                queryParameters['maxBuildsPerDefinition'] = params.maxBuildsPerDefinition;
            }

            if (params.deletedFilter !== undefined) {
                queryParameters['deletedFilter'] = params.deletedFilter;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.branchName !== undefined) {
                queryParameters['branchName'] = params.branchName;
            }

            if (params.buildIds !== undefined) {
                queryParameters['buildIds'] = params.buildIds;
            }

            if (params.repositoryId !== undefined) {
                queryParameters['repositoryId'] = params.repositoryId;
            }

            if (params.repositoryType !== undefined) {
                queryParameters['repositoryType'] = params.repositoryType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the changes made to the repository between two given builds.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param fromBuildId The ID of the first build.
         * @param toBuildId The ID of the last build.
         * @param $Top The maximum number of changes to return.
         */
        public getChangesBetweenBuilds (params: {  organization: string; project: string; apiVersion: string; fromBuildId?: number; toBuildId?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Change>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/changes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChangesBetweenBuilds');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getChangesBetweenBuilds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChangesBetweenBuilds');
            }
            if (params.fromBuildId !== undefined) {
                queryParameters['fromBuildId'] = params.fromBuildId;
            }

            if (params.toBuildId !== undefined) {
                queryParameters['toBuildId'] = params.toBuildId;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets all the work items between two builds.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param fromBuildId The ID of the first build.
         * @param toBuildId The ID of the last build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Top The maximum number of work items to return.
         */
        public getWorkItemsBetweenBuilds (params: {  organization: string; project: string; fromBuildId: number; toBuildId: number; apiVersion: string; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ResourceRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemsBetweenBuilds');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemsBetweenBuilds');
            }
            // verify required parameter 'fromBuildId' is set
            if (params.fromBuildId == null) {
                throw new Error('Missing required parameter fromBuildId when calling getWorkItemsBetweenBuilds');
            }
            // verify required parameter 'toBuildId' is set
            if (params.toBuildId == null) {
                throw new Error('Missing required parameter toBuildId when calling getWorkItemsBetweenBuilds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemsBetweenBuilds');
            }
            if (params.fromBuildId !== undefined) {
                queryParameters['fromBuildId'] = params.fromBuildId;
            }

            if (params.toBuildId !== undefined) {
                queryParameters['toBuildId'] = params.toBuildId;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Queues a build
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         * @param ignoreWarnings 
         * @param checkInTicket 
         * @param sourceBuildId 
         */
        public queueBuild (params: {  organization: string; body: Build; project: string; apiVersion: string; ignoreWarnings?: boolean; checkInTicket?: string; sourceBuildId?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Build> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queueBuild');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queueBuild');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queueBuild');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queueBuild');
            }
            if (params.ignoreWarnings !== undefined) {
                queryParameters['ignoreWarnings'] = params.ignoreWarnings;
            }

            if (params.checkInTicket !== undefined) {
                queryParameters['checkInTicket'] = params.checkInTicket;
            }

            if (params.sourceBuildId !== undefined) {
                queryParameters['sourceBuildId'] = params.sourceBuildId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a build.
         * @param organization The name of the Azure DevOps organization.
         * @param body The build.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         * @param retry 
         */
        public updateBuild (params: {  organization: string; body: Build; project: string; buildId: number; apiVersion: string; retry?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Build> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBuild');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBuild');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBuild');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling updateBuild');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBuild');
            }
            if (params.retry !== undefined) {
                queryParameters['retry'] = params.retry;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates multiple builds.
         * @param organization The name of the Azure DevOps organization.
         * @param body The builds to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.5&#39; to use this version of the api.
         */
        public updateBuilds (params: {  organization: string; body: Array<Build>; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Build>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBuilds');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBuilds');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBuilds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBuilds');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CapacitiesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a team&#39;s capacity
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCapacities (params: {  organization: string; project: string; iterationId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TeamMemberCapacity>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/capacities'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCapacities');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCapacities');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getCapacities');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getCapacities');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCapacities');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a team member&#39;s capacity
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param teamMemberId ID of the team member
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCapacity (params: {  organization: string; project: string; iterationId: string; teamMemberId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamMemberCapacity> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/capacities/{teamMemberId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCapacity');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCapacity');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getCapacity');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling getCapacity');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getCapacity');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCapacity');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replace a team&#39;s capacity
         * @param organization The name of the Azure DevOps organization.
         * @param body Team capacity to replace
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public replaceCapacities (params: {  organization: string; body: Array<TeamMemberCapacity>; project: string; iterationId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TeamMemberCapacity>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/capacities'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceCapacities');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceCapacities');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceCapacities');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling replaceCapacities');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceCapacities');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceCapacities');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a team member&#39;s capacity
         * @param organization The name of the Azure DevOps organization.
         * @param body Updated capacity
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param teamMemberId ID of the team member
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateCapacity (params: {  organization: string; body: CapacityPatch; project: string; iterationId: string; teamMemberId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamMemberCapacity> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/capacities/{teamMemberId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'teamMemberId' + '}', String(params.teamMemberId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateCapacity');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateCapacity');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateCapacity');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling updateCapacity');
            }
            // verify required parameter 'teamMemberId' is set
            if (params.teamMemberId == null) {
                throw new Error('Missing required parameter teamMemberId when calling updateCapacity');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateCapacity');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateCapacity');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CardrulesettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get board card Rule settings for the board id or board by name
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardCardRuleSettings (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardCardRuleSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/cardrulesettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardCardRuleSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardCardRuleSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardCardRuleSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardCardRuleSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardCardRuleSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update board card Rule settings for the board id or board by name
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param board 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardCardRuleSettings (params: {  organization: string; body: BoardCardRuleSettings; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardCardRuleSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/cardrulesettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardCardRuleSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardCardRuleSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardCardRuleSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardCardRuleSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardCardRuleSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardCardRuleSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CardsettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get board card settings for the board id or board by name
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardCardSettings (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardCardSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/cardsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardCardSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardCardSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardCardSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardCardSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardCardSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update board card settings for the board id or board by name
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param board 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardCardSettings (params: {  organization: string; body: BoardCardSettings; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardCardSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/cardsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardCardSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardCardSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardCardSettings');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardCardSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardCardSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardCardSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ChangeTrackingApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Query a feed to determine its current state.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFeedChange (params: {  organization: string; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedChange> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feedchanges/{feedId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedChange');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeedChange');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedChange');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query to determine which feeds have changed since the last call, tracked through the provided continuationToken. Only changes to a feed itself are returned and impact the continuationToken, not additions or alterations to packages within the feeds.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeDeleted If true, get changes for all feeds including deleted feeds. The default value is false.
         * @param continuationToken A continuation token which acts as a bookmark to a previously retrieved change. This token allows the user to continue retrieving changes in batches, picking up where the previous batch left off. If specified, all the changes that occur strictly after the token will be returned. If not specified or 0, iteration will start with the first change.
         * @param batchSize Number of package changes to fetch. The default value is 1000. The maximum value is 2000.
         */
        public getFeedChanges (params: {  organization: string; apiVersion: string; includeDeleted?: boolean; continuationToken?: number; batchSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedChangesResponse> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feedchanges'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedChanges');
            }
            if (params.includeDeleted !== undefined) {
                queryParameters['includeDeleted'] = params.includeDeleted;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.batchSize !== undefined) {
                queryParameters['batchSize'] = params.batchSize;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a batch of package changes made to a feed.  The changes returned are &#39;most recent change&#39; so if an Add is followed by an Update before you begin enumerating, you&#39;ll only see one change in the batch.  While consuming batches using the continuation token, you may see changes to the same package version multiple times if they are happening as you enumerate.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param continuationToken A continuation token which acts as a bookmark to a previously retrieved change. This token allows the user to continue retrieving changes in batches, picking up where the previous batch left off. If specified, all the changes that occur strictly after the token will be returned. If not specified or 0, iteration will start with the first change.
         * @param batchSize Number of package changes to fetch. The default value is 1000. The maximum value is 2000.
         */
        public getPackageChanges (params: {  organization: string; feedId: string; apiVersion: string; continuationToken?: number; batchSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PackageChangesResponse> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/packagechanges'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageChanges');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageChanges');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.batchSize !== undefined) {
                queryParameters['batchSize'] = params.batchSize;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ChangesetsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a new changeset.  Accepts TfvcChangesetToCreate as JSON body
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public createChangeset (params: {  organization: string; body: TfvcChangeset; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TfvcChangesetRef> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/changesets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createChangeset');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createChangeset');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createChangeset');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createChangeset');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns changesets for a given list of changeset Ids.
         * @param organization The name of the Azure DevOps organization.
         * @param body List of changeset IDs.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBatchedChangesets (params: {  organization: string; body: TfvcChangesetsRequestData; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcChangesetRef>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/changesetsbatch'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBatchedChangesets');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getBatchedChangesets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBatchedChangesets');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a Tfvc Changeset
         * @param organization The name of the Azure DevOps organization.
         * @param id Changeset Id to retrieve.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param maxChangeCount Number of changes to return (maximum 100 changes) Default: 0
         * @param includeDetails Include policy details and check-in notes in the response. Default: false
         * @param includeWorkItems Include workitems. Default: false
         * @param maxCommentLength Include details about associated work items in the response. Default: null
         * @param includeSourceRename Include renames.  Default: false
         * @param $Skip Number of results to skip. Default: null
         * @param $Top The maximum number of results to return. Default: null
         * @param $Orderby Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
         * @param searchCriteriaMappings Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
         * @param searchCriteriaIncludeLinks Whether to include the _links field on the shallow references
         * @param searchCriteriaFollowRenames Whether or not to follow renames for the given item being queried
         * @param searchCriteriaToId If provided, a version descriptor for the latest change list to include
         * @param searchCriteriaFromId If provided, only include changesets after this changesetID
         * @param searchCriteriaToDate If provided, only include changesets created before this date (string) Think of a better name for this.
         * @param searchCriteriaFromDate If provided, only include changesets created after this date (string) Think of a better name for this.
         * @param searchCriteriaAuthor Alias or display name of user who made the changes
         * @param searchCriteriaItemPath Path of item to search under
         */
        public getChangeset (params: {  organization: string; id: number; project: string; apiVersion: string; maxChangeCount?: number; includeDetails?: boolean; includeWorkItems?: boolean; maxCommentLength?: number; includeSourceRename?: boolean; $Skip?: number; $Top?: number; $Orderby?: string; searchCriteriaMappings?: string; searchCriteriaIncludeLinks?: boolean; searchCriteriaFollowRenames?: boolean; searchCriteriaToId?: number; searchCriteriaFromId?: number; searchCriteriaToDate?: string; searchCriteriaFromDate?: string; searchCriteriaAuthor?: string; searchCriteriaItemPath?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TfvcChangeset> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/changesets/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChangeset');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getChangeset');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getChangeset');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChangeset');
            }
            if (params.maxChangeCount !== undefined) {
                queryParameters['maxChangeCount'] = params.maxChangeCount;
            }

            if (params.includeDetails !== undefined) {
                queryParameters['includeDetails'] = params.includeDetails;
            }

            if (params.includeWorkItems !== undefined) {
                queryParameters['includeWorkItems'] = params.includeWorkItems;
            }

            if (params.maxCommentLength !== undefined) {
                queryParameters['maxCommentLength'] = params.maxCommentLength;
            }

            if (params.includeSourceRename !== undefined) {
                queryParameters['includeSourceRename'] = params.includeSourceRename;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Orderby !== undefined) {
                queryParameters['$orderby'] = params.$Orderby;
            }

            if (params.searchCriteriaMappings !== undefined) {
                queryParameters['searchCriteria.mappings'] = params.searchCriteriaMappings;
            }

            if (params.searchCriteriaIncludeLinks !== undefined) {
                queryParameters['searchCriteria.includeLinks'] = params.searchCriteriaIncludeLinks;
            }

            if (params.searchCriteriaFollowRenames !== undefined) {
                queryParameters['searchCriteria.followRenames'] = params.searchCriteriaFollowRenames;
            }

            if (params.searchCriteriaToId !== undefined) {
                queryParameters['searchCriteria.toId'] = params.searchCriteriaToId;
            }

            if (params.searchCriteriaFromId !== undefined) {
                queryParameters['searchCriteria.fromId'] = params.searchCriteriaFromId;
            }

            if (params.searchCriteriaToDate !== undefined) {
                queryParameters['searchCriteria.toDate'] = params.searchCriteriaToDate;
            }

            if (params.searchCriteriaFromDate !== undefined) {
                queryParameters['searchCriteria.fromDate'] = params.searchCriteriaFromDate;
            }

            if (params.searchCriteriaAuthor !== undefined) {
                queryParameters['searchCriteria.author'] = params.searchCriteriaAuthor;
            }

            if (params.searchCriteriaItemPath !== undefined) {
                queryParameters['searchCriteria.itemPath'] = params.searchCriteriaItemPath;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve Tfvc changes for a given changeset.
         * @param organization The name of the Azure DevOps organization.
         * @param id ID of the changeset. Default: null
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Skip Number of results to skip. Default: null
         * @param $Top The maximum number of results to return. Default: null
         */
        public getChangesetChanges (params: {  organization: string; id: number; apiVersion: string; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcChange>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/changesets/{id}/changes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChangesetChanges');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getChangesetChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChangesetChanges');
            }
            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves the work items associated with a particular changeset.
         * @param organization The name of the Azure DevOps organization.
         * @param id ID of the changeset. Default: null
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getChangesetWorkItems (params: {  organization: string; id: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AssociatedWorkItem>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/changesets/{id}/workItems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChangesetWorkItems');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getChangesetWorkItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChangesetWorkItems');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve Tfvc Changesets  Note: This is a new version of the GetChangesets API that doesn&#39;t expose the unneeded queryParams present in the 1.0 version of the API.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param maxCommentLength Include details about associated work items in the response. Default: null
         * @param $Skip Number of results to skip. Default: null
         * @param $Top The maximum number of results to return. Default: null
         * @param $Orderby Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
         * @param searchCriteriaMappings Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
         * @param searchCriteriaIncludeLinks Whether to include the _links field on the shallow references
         * @param searchCriteriaFollowRenames Whether or not to follow renames for the given item being queried
         * @param searchCriteriaToId If provided, a version descriptor for the latest change list to include
         * @param searchCriteriaFromId If provided, only include changesets after this changesetID
         * @param searchCriteriaToDate If provided, only include changesets created before this date (string) Think of a better name for this.
         * @param searchCriteriaFromDate If provided, only include changesets created after this date (string) Think of a better name for this.
         * @param searchCriteriaAuthor Alias or display name of user who made the changes
         * @param searchCriteriaItemPath Path of item to search under
         */
        public getChangesets (params: {  organization: string; project: string; apiVersion: string; maxCommentLength?: number; $Skip?: number; $Top?: number; $Orderby?: string; searchCriteriaMappings?: string; searchCriteriaIncludeLinks?: boolean; searchCriteriaFollowRenames?: boolean; searchCriteriaToId?: number; searchCriteriaFromId?: number; searchCriteriaToDate?: string; searchCriteriaFromDate?: string; searchCriteriaAuthor?: string; searchCriteriaItemPath?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcChangesetRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/changesets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChangesets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getChangesets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChangesets');
            }
            if (params.maxCommentLength !== undefined) {
                queryParameters['maxCommentLength'] = params.maxCommentLength;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Orderby !== undefined) {
                queryParameters['$orderby'] = params.$Orderby;
            }

            if (params.searchCriteriaMappings !== undefined) {
                queryParameters['searchCriteria.mappings'] = params.searchCriteriaMappings;
            }

            if (params.searchCriteriaIncludeLinks !== undefined) {
                queryParameters['searchCriteria.includeLinks'] = params.searchCriteriaIncludeLinks;
            }

            if (params.searchCriteriaFollowRenames !== undefined) {
                queryParameters['searchCriteria.followRenames'] = params.searchCriteriaFollowRenames;
            }

            if (params.searchCriteriaToId !== undefined) {
                queryParameters['searchCriteria.toId'] = params.searchCriteriaToId;
            }

            if (params.searchCriteriaFromId !== undefined) {
                queryParameters['searchCriteria.fromId'] = params.searchCriteriaFromId;
            }

            if (params.searchCriteriaToDate !== undefined) {
                queryParameters['searchCriteria.toDate'] = params.searchCriteriaToDate;
            }

            if (params.searchCriteriaFromDate !== undefined) {
                queryParameters['searchCriteria.fromDate'] = params.searchCriteriaFromDate;
            }

            if (params.searchCriteriaAuthor !== undefined) {
                queryParameters['searchCriteria.author'] = params.searchCriteriaAuthor;
            }

            if (params.searchCriteriaItemPath !== undefined) {
                queryParameters['searchCriteria.itemPath'] = params.searchCriteriaItemPath;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ChartsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a board chart
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board Identifier for board, either board&#39;s backlog level name (Eg:&quot;Stories&quot;) or Id
         * @param name The chart name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardChart (params: {  organization: string; project: string; board: string; name: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardChart> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/charts/{name}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'name' + '}', String(params.name))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardChart');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardChart');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardChart');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling getBoardChart');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardChart');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardChart');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get board charts
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board Identifier for board, either board&#39;s backlog level name (Eg:&quot;Stories&quot;) or Id
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardCharts (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardChartReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/charts'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardCharts');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardCharts');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardCharts');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardCharts');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardCharts');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a board chart
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param board Identifier for board, either board&#39;s backlog level name (Eg:&quot;Stories&quot;) or Id
         * @param name The chart name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardChart (params: {  organization: string; body: BoardChart; project: string; board: string; name: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BoardChart> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/charts/{name}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'name' + '}', String(params.name))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardChart');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardChart');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardChart');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardChart');
            }
            // verify required parameter 'name' is set
            if (params.name == null) {
                throw new Error('Missing required parameter name when calling updateBoardChart');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardChart');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardChart');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CherryPicksApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Cherry pick a specific commit or commits that are associated to a pull request into a new branch.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param repositoryId ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createCherryPick (params: {  organization: string; body: GitAsyncRefOperationParameters; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCherryPick> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createCherryPick');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createCherryPick');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createCherryPick');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createCherryPick');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createCherryPick');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve information about a cherry pick by cherry pick Id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param cherryPickId ID of the cherry pick.
         * @param repositoryId ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCherryPick (params: {  organization: string; project: string; cherryPickId: number; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCherryPick> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks/{cherryPickId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'cherryPickId' + '}', String(params.cherryPickId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCherryPick');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCherryPick');
            }
            // verify required parameter 'cherryPickId' is set
            if (params.cherryPickId == null) {
                throw new Error('Missing required parameter cherryPickId when calling getCherryPick');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getCherryPick');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCherryPick');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve information about a cherry pick for a specific branch.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId ID of the repository.
         * @param refName The GitAsyncRefOperationParameters generatedRefName used for the cherry pick operation.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCherryPickForRefName (params: {  organization: string; project: string; repositoryId: string; refName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCherryPick> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/cherryPicks'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCherryPickForRefName');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCherryPickForRefName');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getCherryPickForRefName');
            }
            // verify required parameter 'refName' is set
            if (params.refName == null) {
                throw new Error('Missing required parameter refName when calling getCherryPickForRefName');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCherryPickForRefName');
            }
            if (params.refName !== undefined) {
                queryParameters['refName'] = params.refName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ClassificationNodesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create new or update an existing classification node.
         * @param organization The name of the Azure DevOps organization.
         * @param body Node to create or update.
         * @param project Project ID or project name
         * @param structureGroup Structure group of the classification node, area or iteration.
         * @param path Path of the classification node.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createOrUpdateClassificationNode (params: {  organization: string; body: WorkItemClassificationNode; project: string; structureGroup: string; path: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemClassificationNode> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/classificationnodes/{structureGroup}/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'structureGroup' + '}', String(params.structureGroup))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createOrUpdateClassificationNode');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createOrUpdateClassificationNode');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createOrUpdateClassificationNode');
            }
            // verify required parameter 'structureGroup' is set
            if (params.structureGroup == null) {
                throw new Error('Missing required parameter structureGroup when calling createOrUpdateClassificationNode');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling createOrUpdateClassificationNode');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createOrUpdateClassificationNode');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete an existing classification node.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param structureGroup Structure group of the classification node, area or iteration.
         * @param path Path of the classification node.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $ReclassifyId Id of the target classification node for reclassification.
         */
        public deleteClassificationNode (params: {  organization: string; project: string; structureGroup: string; path: string; apiVersion: string; $ReclassifyId?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/classificationnodes/{structureGroup}/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'structureGroup' + '}', String(params.structureGroup))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteClassificationNode');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteClassificationNode');
            }
            // verify required parameter 'structureGroup' is set
            if (params.structureGroup == null) {
                throw new Error('Missing required parameter structureGroup when calling deleteClassificationNode');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling deleteClassificationNode');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteClassificationNode');
            }
            if (params.$ReclassifyId !== undefined) {
                queryParameters['$reclassifyId'] = params.$ReclassifyId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the classification node for a given node path.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param structureGroup Structure group of the classification node, area or iteration.
         * @param path Path of the classification node.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Depth Depth of children to fetch.
         */
        public getClassificationNode (params: {  organization: string; project: string; structureGroup: string; path: string; apiVersion: string; $Depth?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemClassificationNode> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/classificationnodes/{structureGroup}/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'structureGroup' + '}', String(params.structureGroup))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getClassificationNode');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getClassificationNode');
            }
            // verify required parameter 'structureGroup' is set
            if (params.structureGroup == null) {
                throw new Error('Missing required parameter structureGroup when calling getClassificationNode');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling getClassificationNode');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getClassificationNode');
            }
            if (params.$Depth !== undefined) {
                queryParameters['$depth'] = params.$Depth;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets root classification nodes under the project.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Depth Depth of children to fetch.
         */
        public getRootNodes (params: {  organization: string; project: string; apiVersion: string; $Depth?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemClassificationNode>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/classificationnodes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRootNodes');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRootNodes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRootNodes');
            }
            if (params.$Depth !== undefined) {
                queryParameters['$depth'] = params.$Depth;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update an existing classification node.
         * @param organization The name of the Azure DevOps organization.
         * @param body Node to create or update.
         * @param project Project ID or project name
         * @param structureGroup Structure group of the classification node, area or iteration.
         * @param path Path of the classification node.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateClassificationNode (params: {  organization: string; body: WorkItemClassificationNode; project: string; structureGroup: string; path: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemClassificationNode> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/classificationnodes/{structureGroup}/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'structureGroup' + '}', String(params.structureGroup))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateClassificationNode');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateClassificationNode');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateClassificationNode');
            }
            // verify required parameter 'structureGroup' is set
            if (params.structureGroup == null) {
                throw new Error('Missing required parameter structureGroup when calling updateClassificationNode');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling updateClassificationNode');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateClassificationNode');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ClientApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get the client package.
         * @param organization The name of the Azure DevOps organization.
         * @param clientType Either &quot;EXE&quot; for a zip file containing a Windows symbol client (a.k.a. symbol.exe) along with dependencies, or &quot;TASK&quot; for a VSTS task that can be run on a VSTS build agent. All the other values are invalid. The parameter is case-insensitive.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getClient (params: {  organization: string; clientType: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/client/{clientType}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'clientType' + '}', String(params.clientType));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getClient');
            }
            // verify required parameter 'clientType' is set
            if (params.clientType == null) {
                throw new Error('Missing required parameter clientType when calling getClient');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getClient');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get client version information.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public headClient (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/client'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling headClient');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling headClient');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'HEAD',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CodeCoverageApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get code coverage data for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId ID of the build for which code coverage data needs to be fetched.
         * @param flags Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBuildCodeCoverage (params: {  organization: string; project: string; buildId: number; flags: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildCoverage>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/codecoverage'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildCodeCoverage');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildCodeCoverage');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildCodeCoverage');
            }
            // verify required parameter 'flags' is set
            if (params.flags == null) {
                throw new Error('Missing required parameter flags when calling getBuildCodeCoverage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildCodeCoverage');
            }
            if (params.buildId !== undefined) {
                queryParameters['buildId'] = params.buildId;
            }

            if (params.flags !== undefined) {
                queryParameters['flags'] = params.flags;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get code coverage data for a test run
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run for which code coverage data needs to be fetched.
         * @param flags Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestRunCodeCoverage (params: {  organization: string; project: string; runId: number; flags: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestRunCoverage>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/codecoverage'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunCodeCoverage');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRunCodeCoverage');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestRunCodeCoverage');
            }
            // verify required parameter 'flags' is set
            if (params.flags == null) {
                throw new Error('Missing required parameter flags when calling getTestRunCodeCoverage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunCodeCoverage');
            }
            if (params.flags !== undefined) {
                queryParameters['flags'] = params.flags;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CodeSearchResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Provides a set of results for the search text.
         * @param organization The name of the Azure DevOps organization.
         * @param body The Code Search Request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public fetchCodeSearchResults (params: {  organization: string; body: CodeSearchRequest; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CodeSearchResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/search/codesearchresults'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling fetchCodeSearchResults');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling fetchCodeSearchResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling fetchCodeSearchResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling fetchCodeSearchResults');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ColumnsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get columns on a board
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board Name or ID of the specific board
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardColumns (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardColumn>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/columns'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardColumns');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardColumns');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardColumns');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardColumns');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardColumns');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update columns on a board
         * @param organization The name of the Azure DevOps organization.
         * @param body List of board columns to update
         * @param project Project ID or project name
         * @param board Name or ID of the specific board
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardColumns (params: {  organization: string; body: Array<BoardColumn>; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardColumn>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/columns'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardColumns');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardColumns');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardColumns');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardColumns');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardColumns');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardColumns');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CommentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a comment on a work item.
         * @param organization The name of the Azure DevOps organization.
         * @param body Comment create request.
         * @param project Project ID or project name
         * @param workItemId Id of a work item.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addComment (params: {  organization: string; body: WorkItemCommentCreateRequest; project: string; workItemId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addComment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addComment');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling addComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a comment on a work item.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param workItemId Id of a work item.
         * @param commentId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteComment (params: {  organization: string; project: string; workItemId: number; commentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId))
                .replace('{' + 'commentId' + '}', String(params.commentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteComment');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling deleteComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling deleteComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a work item comment.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param workItemId Id of a work item to get the comment.
         * @param commentId Id of the comment to return.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Expand Specifies the additional data retrieval options for work item comments.
         */
        public getComment (params: {  organization: string; project: string; workItemId: number; commentId: number; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId))
                .replace('{' + 'commentId' + '}', String(params.commentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getComment');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling getComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling getComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getComment');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of work item comments by ids.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param workItemId Id of a work item to get comments for.
         * @param ids Comma-separated list of comment ids to return.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Expand Specifies the additional data retrieval options for work item comments.
         */
        public getCommentsBatch (params: {  organization: string; project: string; workItemId: number; ids: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentsResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommentsBatch');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommentsBatch');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling getCommentsBatch');
            }
            // verify required parameter 'ids' is set
            if (params.ids == null) {
                throw new Error('Missing required parameter ids when calling getCommentsBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommentsBatch');
            }
            if (params.ids !== undefined) {
                queryParameters['ids'] = params.ids;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a comment on a work item.
         * @param organization The name of the Azure DevOps organization.
         * @param body Comment update request.
         * @param project Project ID or project name
         * @param workItemId Id of a work item.
         * @param commentId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateComment (params: {  organization: string; body: WorkItemCommentUpdateRequest; project: string; workItemId: number; commentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId))
                .replace('{' + 'commentId' + '}', String(params.commentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateComment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateComment');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling updateComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling updateComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CommentsReportingApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param continuationToken 
         * @param top 
         * @param $Expand 
         */
        public readReportingComments (params: {  organization: string; project: string; apiVersion: string; continuationToken?: string; top?: number; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentsReportingResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/reporting/workitemcomments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling readReportingComments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling readReportingComments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling readReportingComments');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CommentsVersionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param workItemId 
         * @param commentId 
         * @param version 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCommentVersion (params: {  organization: string; project: string; workItemId: number; commentId: number; version: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemCommentVersionResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments/{commentId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommentVersion');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommentVersion');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling getCommentVersion');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling getCommentVersion');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling getCommentVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommentVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param workItemId 
         * @param commentId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCommentVersions (params: {  organization: string; project: string; workItemId: number; commentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemCommentVersionResponse>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{workItemId}/comments/{commentId}/versions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'workItemId' + '}', String(params.workItemId))
                .replace('{' + 'commentId' + '}', String(params.commentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommentVersions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommentVersions');
            }
            // verify required parameter 'workItemId' is set
            if (params.workItemId == null) {
                throw new Error('Missing required parameter workItemId when calling getCommentVersions');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling getCommentVersions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommentVersions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CommitsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve changes for a particular commit.
         * @param organization The name of the Azure DevOps organization.
         * @param commitId The id of the commit.
         * @param repositoryId The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param top The maximum number of changes to return.
         * @param skip The number of changes to skip.
         */
        public getChanges (params: {  organization: string; commitId: string; repositoryId: string; project: string; apiVersion: string; top?: number; skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCommitChanges> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/changes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'commitId' + '}', String(params.commitId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getChanges');
            }
            // verify required parameter 'commitId' is set
            if (params.commitId == null) {
                throw new Error('Missing required parameter commitId when calling getChanges');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getChanges');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getChanges');
            }
            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.skip !== undefined) {
                queryParameters['skip'] = params.skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a particular commit.
         * @param organization The name of the Azure DevOps organization.
         * @param commitId The id of the commit.
         * @param repositoryId The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param changeCount The number of changes to include in the result.
         */
        public getCommit (params: {  organization: string; commitId: string; repositoryId: string; project: string; apiVersion: string; changeCount?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCommit> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'commitId' + '}', String(params.commitId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommit');
            }
            // verify required parameter 'commitId' is set
            if (params.commitId == null) {
                throw new Error('Missing required parameter commitId when calling getCommit');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getCommit');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommit');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommit');
            }
            if (params.changeCount !== undefined) {
                queryParameters['changeCount'] = params.changeCount;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve git commits for a project matching the search criteria
         * @param organization The name of the Azure DevOps organization.
         * @param body Search options
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Skip Number of commits to skip.
         * @param $Top Maximum number of commits to return.
         * @param includeStatuses True to include additional commit status information.
         */
        public getCommitsBatch (params: {  organization: string; body: GitQueryCommitsCriteria; repositoryId: string; project: string; apiVersion: string; $Skip?: number; $Top?: number; includeStatuses?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitCommitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commitsbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommitsBatch');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getCommitsBatch');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getCommitsBatch');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommitsBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommitsBatch');
            }
            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.includeStatuses !== undefined) {
                queryParameters['includeStatuses'] = params.includeStatuses;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a list of commits associated with a particular push.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
         * @param pushId The id of the push.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param top The maximum number of commits to return (&quot;get the top x commits&quot;).
         * @param skip The number of commits to skip.
         * @param includeLinks Set to false to avoid including REST Url links for resources. Defaults to true.
         */
        public getPushCommits (params: {  organization: string; repositoryId: string; pushId: number; project: string; apiVersion: string; top?: number; skip?: number; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitCommitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commits'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPushCommits');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPushCommits');
            }
            // verify required parameter 'pushId' is set
            if (params.pushId == null) {
                throw new Error('Missing required parameter pushId when calling getPushCommits');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPushCommits');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPushCommits');
            }
            if (params.pushId !== undefined) {
                queryParameters['pushId'] = params.pushId;
            }

            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.skip !== undefined) {
                queryParameters['skip'] = params.skip;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConfigurationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a policy configuration of a given policy type.
         * @param organization The name of the Azure DevOps organization.
         * @param body The policy configuration to create.
         * @param project Project ID or project name
         * @param configurationId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPolicyConfiguration (params: {  organization: string; body: PolicyConfiguration; project: string; configurationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPolicyConfiguration');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPolicyConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPolicyConfiguration');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling createPolicyConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPolicyConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a test configuration.
         * @param organization The name of the Azure DevOps organization.
         * @param body TestConfigurationCreateUpdateParameters
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestConfiguration (params: {  organization: string; body: TestConfigurationCreateUpdateParameters; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestConfiguration');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a policy configuration by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param configurationId ID of the policy configuration to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePolicyConfiguration (params: {  organization: string; project: string; configurationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePolicyConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePolicyConfiguration');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling deletePolicyConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePolicyConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a test configuration by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testConfiguartionId ID of the test configuration to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestConfguration (params: {  organization: string; project: string; testConfiguartionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestConfguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestConfguration');
            }
            // verify required parameter 'testConfiguartionId' is set
            if (params.testConfiguartionId == null) {
                throw new Error('Missing required parameter testConfiguartionId when calling deleteTestConfguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestConfguration');
            }
            if (params.testConfiguartionId !== undefined) {
                queryParameters['testConfiguartionId'] = params.testConfiguartionId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a policy configuration by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param configurationId ID of the policy configuration
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPolicyConfiguration (params: {  organization: string; project: string; configurationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyConfiguration');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling getPolicyConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of policy configurations in a project.  The &#39;scope&#39; parameter for this API should not be used, except for legacy compatability reasons. It returns specifically scoped policies and does not support heirarchical nesting. Instead, use the /_apis/git/policy/configurations API, which provides first class scope filtering support.  The optional &#x60;policyType&#x60; parameter can be used to filter the set of policies returned from this method.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param scope [Provided for legacy reasons] The scope on which a subset of policies is defined.
         * @param policyType Filter returned policies to only this type
         */
        public getPolicyConfigurations (params: {  organization: string; project: string; apiVersion: string; scope?: string; policyType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PolicyConfiguration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyConfigurations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyConfigurations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyConfigurations');
            }
            if (params.scope !== undefined) {
                queryParameters['scope'] = params.scope;
            }

            if (params.policyType !== undefined) {
                queryParameters['policyType'] = params.policyType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a test configuration
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testConfigurationId ID of the test configuration to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestConfigurationById (params: {  organization: string; project: string; testConfigurationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/configurations/{testConfigurationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testConfigurationId' + '}', String(params.testConfigurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestConfigurationById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestConfigurationById');
            }
            // verify required parameter 'testConfigurationId' is set
            if (params.testConfigurationId == null) {
                throw new Error('Missing required parameter testConfigurationId when calling getTestConfigurationById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestConfigurationById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test configurations.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param continuationToken If the list of configurations returned is not complete, a continuation token to query next batch of configurations is included in the response header as &quot;x-ms-continuationtoken&quot;. Omit this parameter to get the first batch of test configurations.
         */
        public getTestConfigurations (params: {  organization: string; project: string; apiVersion: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestConfiguration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestConfigurations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestConfigurations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestConfigurations');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a policy configuration by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param body The policy configuration to update.
         * @param project Project ID or project name
         * @param configurationId ID of the existing policy configuration to be updated.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePolicyConfiguration (params: {  organization: string; body: PolicyConfiguration; project: string; configurationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePolicyConfiguration');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePolicyConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePolicyConfiguration');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling updatePolicyConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePolicyConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a test configuration by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param body TestConfigurationCreateUpdateParameters
         * @param project Project ID or project name
         * @param testConfiguartionId ID of the test configuration to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestConfiguration (params: {  organization: string; body: TestConfigurationCreateUpdateParameters; project: string; testConfiguartionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestConfiguration');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestConfiguration');
            }
            // verify required parameter 'testConfiguartionId' is set
            if (params.testConfiguartionId == null) {
                throw new Error('Missing required parameter testConfiguartionId when calling updateTestConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestConfiguration');
            }
            if (params.testConfiguartionId !== undefined) {
                queryParameters['testConfiguartionId'] = params.testConfiguartionId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ConsumersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a specific consumer service. Optionally filter out consumer actions that do not support any event types for the specified publisher.
         * @param organization The name of the Azure DevOps organization.
         * @param consumerId ID for a consumer.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId 
         */
        public getConsumer (params: {  organization: string; consumerId: string; apiVersion: string; publisherId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Consumer> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/consumers/{consumerId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'consumerId' + '}', String(params.consumerId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getConsumer');
            }
            // verify required parameter 'consumerId' is set
            if (params.consumerId == null) {
                throw new Error('Missing required parameter consumerId when calling getConsumer');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getConsumer');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get details about a specific consumer action.
         * @param organization The name of the Azure DevOps organization.
         * @param consumerId ID for a consumer.
         * @param consumerActionId ID for a consumerActionId.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId 
         */
        public getConsumerAction (params: {  organization: string; consumerId: string; consumerActionId: string; apiVersion: string; publisherId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ConsumerAction> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/consumers/{consumerId}/actions/{consumerActionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'consumerId' + '}', String(params.consumerId))
                .replace('{' + 'consumerActionId' + '}', String(params.consumerActionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getConsumerAction');
            }
            // verify required parameter 'consumerId' is set
            if (params.consumerId == null) {
                throw new Error('Missing required parameter consumerId when calling getConsumerAction');
            }
            // verify required parameter 'consumerActionId' is set
            if (params.consumerActionId == null) {
                throw new Error('Missing required parameter consumerActionId when calling getConsumerAction');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getConsumerAction');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of consumer actions for a specific consumer.
         * @param organization The name of the Azure DevOps organization.
         * @param consumerId ID for a consumer.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId 
         */
        public listConsumerActions (params: {  organization: string; consumerId: string; apiVersion: string; publisherId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ConsumerAction>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/consumers/{consumerId}/actions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'consumerId' + '}', String(params.consumerId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listConsumerActions');
            }
            // verify required parameter 'consumerId' is set
            if (params.consumerId == null) {
                throw new Error('Missing required parameter consumerId when calling listConsumerActions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listConsumerActions');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of available service hook consumer services. Optionally filter by consumers that support at least one event type from the specific publisher.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId 
         */
        public listConsumers (params: {  organization: string; apiVersion: string; publisherId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Consumer>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/consumers'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listConsumers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listConsumers');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ControllersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets a controller
         * @param organization The name of the Azure DevOps organization.
         * @param controllerId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getBuildController (params: {  organization: string; controllerId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildController> {
            const localVarPath = this.basePath + '/{organization}/_apis/build/controllers/{controllerId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'controllerId' + '}', String(params.controllerId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildController');
            }
            // verify required parameter 'controllerId' is set
            if (params.controllerId == null) {
                throw new Error('Missing required parameter controllerId when calling getBuildController');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildController');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets controller, optionally filtered by name
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param name 
         */
        public getBuildControllers (params: {  organization: string; apiVersion: string; name?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildController>> {
            const localVarPath = this.basePath + '/{organization}/_apis/build/controllers'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildControllers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildControllers');
            }
            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ControlsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a control in a group
         * @param organization The name of the Azure DevOps organization.
         * @param body The control
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param groupId The ID of the group to add the control to
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addControlToGroup (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addControlToGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addControlToGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addControlToGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addControlToGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling addControlToGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addControlToGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a control in a group.
         * @param organization The name of the Azure DevOps organization.
         * @param body The control.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param groupId The ID of the group to add the control to.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createControlInGroup (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createControlInGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createControlInGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createControlInGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling createControlInGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling createControlInGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createControlInGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a control on the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated control
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param groupId The ID of the group
         * @param controlId The ID of the control
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public editControl (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling editControl');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling editControl');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling editControl');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling editControl');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling editControl');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling editControl');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling editControl');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Moves a control to a specified group.
         * @param organization The name of the Azure DevOps organization.
         * @param body The control.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param groupId The ID of the group to move the control to.
         * @param controlId The ID of the control.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param removeFromGroupId The group ID to remove the control from.
         */
        public moveControlToGroup (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; removeFromGroupId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling moveControlToGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling moveControlToGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling moveControlToGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling moveControlToGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling moveControlToGroup');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling moveControlToGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling moveControlToGroup');
            }
            if (params.removeFromGroupId !== undefined) {
                queryParameters['removeFromGroupId'] = params.removeFromGroupId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a control from the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param groupId The ID of the group
         * @param controlId The ID of the control to remove
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeControlFromGroup (params: {  organization: string; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeControlFromGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeControlFromGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removeControlFromGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling removeControlFromGroup');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling removeControlFromGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeControlFromGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a control from the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param groupId The ID of the group.
         * @param controlId The ID of the control to remove.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeControlFromGroup_1 (params: {  organization: string; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeControlFromGroup_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeControlFromGroup_1');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removeControlFromGroup_1');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling removeControlFromGroup_1');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling removeControlFromGroup_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeControlFromGroup_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Moves a control to a new group
         * @param organization The name of the Azure DevOps organization.
         * @param body The control
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param groupId The ID of the group to move the control to
         * @param controlId The id of the control
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param removeFromGroupId The group to remove the control from
         */
        public setControlInGroup (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; removeFromGroupId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setControlInGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setControlInGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling setControlInGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling setControlInGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling setControlInGroup');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling setControlInGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setControlInGroup');
            }
            if (params.removeFromGroupId !== undefined) {
                queryParameters['removeFromGroupId'] = params.removeFromGroupId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a control on the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated control.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param groupId The ID of the group.
         * @param controlId The ID of the control.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateControl (params: {  organization: string; body: Control; processId: string; witRefName: string; groupId: string; controlId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Control> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/groups/{groupId}/controls/{controlId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'controlId' + '}', String(params.controlId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateControl');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateControl');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateControl');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateControl');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling updateControl');
            }
            // verify required parameter 'controlId' is set
            if (params.controlId == null) {
                throw new Error('Missing required parameter controlId when calling updateControl');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateControl');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CounterInstancesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testRunId The test run identifier
         * @param groupNames Comma separated names of counter groups, such as &#39;Application&#39;, &#39;Performance&#39; and &#39;Throughput&#39;
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeSummary 
         */
        public getCounters (params: {  organization: string; testRunId: string; groupNames: string; apiVersion: string; includeSummary?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestRunCounterInstance>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testRuns/{testRunId}/counterinstances'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCounters');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getCounters');
            }
            // verify required parameter 'groupNames' is set
            if (params.groupNames == null) {
                throw new Error('Missing required parameter groupNames when calling getCounters');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCounters');
            }
            if (params.groupNames !== undefined) {
                queryParameters['groupNames'] = params.groupNames;
            }

            if (params.includeSummary !== undefined) {
                queryParameters['includeSummary'] = params.includeSummary;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CounterSamplesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param testRunId The test run identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getCounterSamples (params: {  organization: string; body: VssJsonCollectionWrapper; testRunId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CounterSamplesResult> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testRuns/{testRunId}/countersamples'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCounterSamples');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getCounterSamples');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getCounterSamples');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCounterSamples');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class CountersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param applicationId Filter by APM application identifier.
         * @param plugintype Currently ApplicationInsights is the only available plugin type.
         */
        public getApplicationCounters (params: {  organization: string; apiVersion: string; applicationId?: string; plugintype?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ApplicationCounters>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/apm/counters'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getApplicationCounters');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getApplicationCounters');
            }
            if (params.applicationId !== undefined) {
                queryParameters['applicationId'] = params.applicationId;
            }

            if (params.plugintype !== undefined) {
                queryParameters['plugintype'] = params.plugintype;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DashboardsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create the supplied dashboard.
         * @param organization The name of the Azure DevOps organization.
         * @param body The initial state of the dashboard
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createDashboard (params: {  organization: string; body: Dashboard; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Dashboard> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createDashboard');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createDashboard');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createDashboard');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling createDashboard');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createDashboard');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a dashboard given its ID. This also deletes the widgets associated with this dashboard.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard to delete.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteDashboard (params: {  organization: string; project: string; dashboardId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteDashboard');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteDashboard');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling deleteDashboard');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling deleteDashboard');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteDashboard');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a dashboard by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param dashboardId 
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getDashboard (params: {  organization: string; project: string; dashboardId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Dashboard> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDashboard');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDashboard');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling getDashboard');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getDashboard');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDashboard');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of dashboards.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getDashboards (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DashboardGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDashboards');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDashboards');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getDashboards');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDashboards');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replace configuration for the specified dashboard. Replaces Widget list on Dashboard, only if property is supplied.
         * @param organization The name of the Azure DevOps organization.
         * @param body The Configuration of the dashboard to replace.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard to replace.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public replaceDashboard (params: {  organization: string; body: Dashboard; project: string; dashboardId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Dashboard> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceDashboard');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceDashboard');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceDashboard');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling replaceDashboard');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceDashboard');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceDashboard');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the name and position of dashboards in the supplied group, and remove omitted dashboards. Does not modify dashboard content.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public replaceDashboards (params: {  organization: string; body: DashboardGroup; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DashboardGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceDashboards');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceDashboards');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceDashboards');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceDashboards');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceDashboards');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DefinitionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a new definition.
         * @param organization The name of the Azure DevOps organization.
         * @param body The definition.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         * @param definitionToCloneId 
         * @param definitionToCloneRevision 
         */
        public createDefinition (params: {  organization: string; body: BuildDefinition; project: string; apiVersion: string; definitionToCloneId?: number; definitionToCloneRevision?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createDefinition');
            }
            if (params.definitionToCloneId !== undefined) {
                queryParameters['definitionToCloneId'] = params.definitionToCloneId;
            }

            if (params.definitionToCloneRevision !== undefined) {
                queryParameters['definitionToCloneRevision'] = params.definitionToCloneRevision;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a release definition
         * @param organization The name of the Azure DevOps organization.
         * @param body release definition object to create.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public createReleaseDefinition (params: {  organization: string; body: ReleaseDefinition; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/definitions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createReleaseDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createReleaseDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createReleaseDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createReleaseDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a definition and all associated builds.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         */
        public deleteDefinition (params: {  organization: string; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling deleteDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a release definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId Id of the release definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param comment Comment for deleting a release definition.
         * @param forceDelete &#39;true&#39; to automatically cancel any in-progress release deployments and proceed with release definition deletion . Default is &#39;false&#39;.
         */
        public deleteReleaseDefinition (params: {  organization: string; project: string; definitionId: number; apiVersion: string; comment?: string; forceDelete?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteReleaseDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteReleaseDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling deleteReleaseDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteReleaseDefinition');
            }
            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.forceDelete !== undefined) {
                queryParameters['forceDelete'] = params.forceDelete;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a definition, optionally at a specific revision.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         * @param revision The revision number to retrieve. If this is not specified, the latest version will be returned.
         * @param minMetricsTime If specified, indicates the date from which metrics should be included.
         * @param propertyFilters A comma-delimited list of properties to include in the results.
         * @param includeLatestBuilds 
         */
        public getDefinition (params: {  organization: string; project: string; definitionId: number; apiVersion: string; revision?: number; minMetricsTime?: Date; propertyFilters?: string; includeLatestBuilds?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinition');
            }
            if (params.revision !== undefined) {
                queryParameters['revision'] = params.revision;
            }

            if (params.minMetricsTime !== undefined) {
                queryParameters['minMetricsTime'] = params.minMetricsTime;
            }

            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.includeLatestBuilds !== undefined) {
                queryParameters['includeLatestBuilds'] = params.includeLatestBuilds;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get release definition for a given definitionId and revision
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId Id of the definition.
         * @param revision Id of the revision.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getDefinitionRevision (params: {  organization: string; project: string; definitionId: number; revision: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/definitions/{definitionId}/revisions/{revision}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId))
                .replace('{' + 'revision' + '}', String(params.revision));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionRevision');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionRevision');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionRevision');
            }
            // verify required parameter 'revision' is set
            if (params.revision == null) {
                throw new Error('Missing required parameter revision when calling getDefinitionRevision');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionRevision');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets all revisions of a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getDefinitionRevisions (params: {  organization: string; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildDefinitionRevision>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/revisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionRevisions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionRevisions');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionRevisions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionRevisions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of definitions.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         * @param name If specified, filters to definitions whose names match this pattern.
         * @param repositoryId A repository ID. If specified, filters to definitions that use this repository.
         * @param repositoryType If specified, filters to definitions that have a repository of this type.
         * @param queryOrder Indicates the order in which definitions should be returned.
         * @param $Top The maximum number of definitions to return.
         * @param continuationToken A continuation token, returned by a previous call to this method, that can be used to return the next set of definitions.
         * @param minMetricsTime If specified, indicates the date from which metrics should be included.
         * @param definitionIds A comma-delimited list that specifies the IDs of definitions to retrieve.
         * @param path If specified, filters to definitions under this folder.
         * @param builtAfter If specified, filters to definitions that have builds after this date.
         * @param notBuiltAfter If specified, filters to definitions that do not have builds after this date.
         * @param includeAllProperties Indicates whether the full definitions should be returned. By default, shallow representations of the definitions are returned.
         * @param includeLatestBuilds Indicates whether to return the latest and latest completed builds for this definition.
         * @param taskIdFilter If specified, filters to definitions that use the specified task.
         * @param processType If specified, filters to definitions with the given process type.
         * @param yamlFilename If specified, filters to YAML definitions that match the given filename.
         */
        public getDefinitions (params: {  organization: string; project: string; apiVersion: string; name?: string; repositoryId?: string; repositoryType?: string; queryOrder?: string; $Top?: number; continuationToken?: string; minMetricsTime?: Date; definitionIds?: string; path?: string; builtAfter?: Date; notBuiltAfter?: Date; includeAllProperties?: boolean; includeLatestBuilds?: boolean; taskIdFilter?: string; processType?: number; yamlFilename?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildDefinitionReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitions');
            }
            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.repositoryId !== undefined) {
                queryParameters['repositoryId'] = params.repositoryId;
            }

            if (params.repositoryType !== undefined) {
                queryParameters['repositoryType'] = params.repositoryType;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.minMetricsTime !== undefined) {
                queryParameters['minMetricsTime'] = params.minMetricsTime;
            }

            if (params.definitionIds !== undefined) {
                queryParameters['definitionIds'] = params.definitionIds;
            }

            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.builtAfter !== undefined) {
                queryParameters['builtAfter'] = params.builtAfter;
            }

            if (params.notBuiltAfter !== undefined) {
                queryParameters['notBuiltAfter'] = params.notBuiltAfter;
            }

            if (params.includeAllProperties !== undefined) {
                queryParameters['includeAllProperties'] = params.includeAllProperties;
            }

            if (params.includeLatestBuilds !== undefined) {
                queryParameters['includeLatestBuilds'] = params.includeLatestBuilds;
            }

            if (params.taskIdFilter !== undefined) {
                queryParameters['taskIdFilter'] = params.taskIdFilter;
            }

            if (params.processType !== undefined) {
                queryParameters['processType'] = params.processType;
            }

            if (params.yamlFilename !== undefined) {
                queryParameters['yamlFilename'] = params.yamlFilename;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a release definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId Id of the release definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definition will contain values for the specified property Ids (if they exist). If not set, properties will not be included.
         */
        public getReleaseDefinition (params: {  organization: string; project: string; definitionId: number; apiVersion: string; propertyFilters?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getReleaseDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseDefinition');
            }
            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get revision history for a release definition
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId Id of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getReleaseDefinitionHistory (params: {  organization: string; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ReleaseDefinitionRevision>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/definitions/{definitionId}/revisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseDefinitionHistory');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseDefinitionHistory');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getReleaseDefinitionHistory');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseDefinitionHistory');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of release definitions.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param searchText Get release definitions with names containing searchText.
         * @param $Expand The properties that should be expanded in the list of Release definitions.
         * @param artifactType Release definitions with given artifactType will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
         * @param artifactSourceId Release definitions with given artifactSourceId will be returned. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json at https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
         * @param $Top Number of release definitions to get.
         * @param continuationToken Gets the release definitions after the continuation token provided.
         * @param queryOrder Gets the results in the defined order. Default is &#39;IdAscending&#39;.
         * @param path Gets the release definitions under the specified path.
         * @param isExactNameMatch &#39;true&#39;to gets the release definitions with exact match as specified in searchText. Default is &#39;false&#39;.
         * @param tagFilter A comma-delimited list of tags. Only release definitions with these tags will be returned.
         * @param propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definitions will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release Definition from results irrespective of whether it has property set or not.
         * @param definitionIdFilter A comma-delimited list of release definitions to retrieve.
         * @param isDeleted &#39;true&#39; to get release definitions that has been deleted. Default is &#39;false&#39;
         * @param searchTextContainsFolderName &#39;true&#39; to get the release definitions under the folder with name as specified in searchText. Default is &#39;false&#39;.
         */
        public getReleaseDefinitions (params: {  organization: string; project: string; apiVersion: string; searchText?: string; $Expand?: string; artifactType?: string; artifactSourceId?: string; $Top?: number; continuationToken?: string; queryOrder?: string; path?: string; isExactNameMatch?: boolean; tagFilter?: string; propertyFilters?: string; definitionIdFilter?: string; isDeleted?: boolean; searchTextContainsFolderName?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ReleaseDefinition>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/definitions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseDefinitions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseDefinitions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseDefinitions');
            }
            if (params.searchText !== undefined) {
                queryParameters['searchText'] = params.searchText;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.artifactType !== undefined) {
                queryParameters['artifactType'] = params.artifactType;
            }

            if (params.artifactSourceId !== undefined) {
                queryParameters['artifactSourceId'] = params.artifactSourceId;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.isExactNameMatch !== undefined) {
                queryParameters['isExactNameMatch'] = params.isExactNameMatch;
            }

            if (params.tagFilter !== undefined) {
                queryParameters['tagFilter'] = params.tagFilter;
            }

            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.definitionIdFilter !== undefined) {
                queryParameters['definitionIdFilter'] = params.definitionIdFilter;
            }

            if (params.isDeleted !== undefined) {
                queryParameters['isDeleted'] = params.isDeleted;
            }

            if (params.searchTextContainsFolderName !== undefined) {
                queryParameters['searchTextContainsFolderName'] = params.searchTextContainsFolderName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restores a deleted definition
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The identifier of the definition to restore.
         * @param deleted When false, restores a deleted definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         */
        public restoreDefinition (params: {  organization: string; project: string; definitionId: number; deleted: boolean; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restoreDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling restoreDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling restoreDefinition');
            }
            // verify required parameter 'deleted' is set
            if (params.deleted == null) {
                throw new Error('Missing required parameter deleted when calling restoreDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restoreDefinition');
            }
            if (params.deleted !== undefined) {
                queryParameters['deleted'] = params.deleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates an existing definition.
         * @param organization The name of the Azure DevOps organization.
         * @param body The new version of the defintion.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.7&#39; to use this version of the api.
         * @param secretsSourceDefinitionId 
         * @param secretsSourceDefinitionRevision 
         */
        public updateDefinition (params: {  organization: string; body: BuildDefinition; project: string; definitionId: number; apiVersion: string; secretsSourceDefinitionId?: number; secretsSourceDefinitionRevision?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateDefinition');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling updateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateDefinition');
            }
            if (params.secretsSourceDefinitionId !== undefined) {
                queryParameters['secretsSourceDefinitionId'] = params.secretsSourceDefinitionId;
            }

            if (params.secretsSourceDefinitionRevision !== undefined) {
                queryParameters['secretsSourceDefinitionRevision'] = params.secretsSourceDefinitionRevision;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a release definition.
         * @param organization The name of the Azure DevOps organization.
         * @param body Release definition object to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public updateReleaseDefinition (params: {  organization: string; body: ReleaseDefinition; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/definitions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateReleaseDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateReleaseDefinition');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateReleaseDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateReleaseDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DeliverytimelineApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get Delivery View Data
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id Identifier for delivery view
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param revision Revision of the plan for which you want data. If the current plan is a different revision you will get an ViewRevisionMismatchException exception. If you do not supply a revision you will get data for the latest revision.
         * @param startDate The start date of timeline
         * @param endDate The end date of timeline
         */
        public getDeliveryTimelineData (params: {  organization: string; project: string; id: string; apiVersion: string; revision?: number; startDate?: Date; endDate?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DeliveryViewData> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans/{id}/deliverytimeline'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeliveryTimelineData');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeliveryTimelineData');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getDeliveryTimelineData');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeliveryTimelineData');
            }
            if (params.revision !== undefined) {
                queryParameters['revision'] = params.revision;
            }

            if (params.startDate !== undefined) {
                queryParameters['startDate'] = params.startDate;
            }

            if (params.endDate !== undefined) {
                queryParameters['endDate'] = params.endDate;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DeploymentgroupsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a deployment group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Deployment group to create.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addDeploymentGroup (params: {  organization: string; body: DeploymentGroupCreateParameter; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DeploymentGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addDeploymentGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addDeploymentGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addDeploymentGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addDeploymentGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a deployment group.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group to be deleted.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteDeploymentGroup (params: {  organization: string; project: string; deploymentGroupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteDeploymentGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteDeploymentGroup');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling deleteDeploymentGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteDeploymentGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a deployment group by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param actionFilter Get the deployment group only if this action can be performed on it.
         * @param $Expand Include these additional details in the returned object.
         */
        public getDeploymentGroup (params: {  organization: string; project: string; deploymentGroupId: number; apiVersion: string; actionFilter?: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DeploymentGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeploymentGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeploymentGroup');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling getDeploymentGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeploymentGroup');
            }
            if (params.actionFilter !== undefined) {
                queryParameters['actionFilter'] = params.actionFilter;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of deployment groups by name or IDs.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param name Name of the deployment group.
         * @param actionFilter Get only deployment groups on which this action can be performed.
         * @param $Expand Include these additional details in the returned objects.
         * @param continuationToken Get deployment groups with names greater than this continuationToken lexicographically.
         * @param $Top Maximum number of deployment groups to return. Default is **1000**.
         * @param ids Comma separated list of IDs of the deployment groups.
         */
        public getDeploymentGroups (params: {  organization: string; project: string; apiVersion: string; name?: string; actionFilter?: string; $Expand?: string; continuationToken?: string; $Top?: number; ids?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DeploymentGroup>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeploymentGroups');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeploymentGroups');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeploymentGroups');
            }
            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.actionFilter !== undefined) {
                queryParameters['actionFilter'] = params.actionFilter;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.ids !== undefined) {
                queryParameters['ids'] = params.ids;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a deployment group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Deployment group to update.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateDeploymentGroup (params: {  organization: string; body: DeploymentGroupUpdateParameter; project: string; deploymentGroupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DeploymentGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateDeploymentGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateDeploymentGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateDeploymentGroup');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling updateDeploymentGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateDeploymentGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DeploymentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param definitionId 
         * @param definitionEnvironmentId 
         * @param createdBy 
         * @param minModifiedTime 
         * @param maxModifiedTime 
         * @param deploymentStatus 
         * @param operationStatus 
         * @param latestAttemptsOnly 
         * @param queryOrder 
         * @param $Top 
         * @param continuationToken 
         * @param createdFor 
         * @param minStartedTime 
         * @param maxStartedTime 
         * @param sourceBranch 
         */
        public getDeployments (params: {  organization: string; project: string; apiVersion: string; definitionId?: number; definitionEnvironmentId?: number; createdBy?: string; minModifiedTime?: Date; maxModifiedTime?: Date; deploymentStatus?: string; operationStatus?: string; latestAttemptsOnly?: boolean; queryOrder?: string; $Top?: number; continuationToken?: number; createdFor?: string; minStartedTime?: Date; maxStartedTime?: Date; sourceBranch?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Deployment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/deployments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeployments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeployments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeployments');
            }
            if (params.definitionId !== undefined) {
                queryParameters['definitionId'] = params.definitionId;
            }

            if (params.definitionEnvironmentId !== undefined) {
                queryParameters['definitionEnvironmentId'] = params.definitionEnvironmentId;
            }

            if (params.createdBy !== undefined) {
                queryParameters['createdBy'] = params.createdBy;
            }

            if (params.minModifiedTime !== undefined) {
                queryParameters['minModifiedTime'] = params.minModifiedTime;
            }

            if (params.maxModifiedTime !== undefined) {
                queryParameters['maxModifiedTime'] = params.maxModifiedTime;
            }

            if (params.deploymentStatus !== undefined) {
                queryParameters['deploymentStatus'] = params.deploymentStatus;
            }

            if (params.operationStatus !== undefined) {
                queryParameters['operationStatus'] = params.operationStatus;
            }

            if (params.latestAttemptsOnly !== undefined) {
                queryParameters['latestAttemptsOnly'] = params.latestAttemptsOnly;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.createdFor !== undefined) {
                queryParameters['createdFor'] = params.createdFor;
            }

            if (params.minStartedTime !== undefined) {
                queryParameters['minStartedTime'] = params.minStartedTime;
            }

            if (params.maxStartedTime !== undefined) {
                queryParameters['maxStartedTime'] = params.maxStartedTime;
            }

            if (params.sourceBranch !== undefined) {
                queryParameters['sourceBranch'] = params.sourceBranch;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DescriptorsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Resolve a storage key to a descriptor
         * @param storageKey Storage key of the subject (user, group, scope, etc.) to resolve
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getDescriptor (params: {  storageKey: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphDescriptorResult> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/descriptors/{storageKey}'
                .replace('{' + 'storageKey' + '}', String(params.storageKey))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'storageKey' is set
            if (params.storageKey == null) {
                throw new Error('Missing required parameter storageKey when calling getDescriptor');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDescriptor');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDescriptor');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DiagnosticLogsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * List diagnostic logs this service.
         * @param source 
         * @param organization The name of the Azure DevOps organization.
         * @param entryId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param startTime 
         * @param endTime 
         */
        public listLogs (params: {  source: string; organization: string; entryId: string; apiVersion: string; startTime?: Date; endTime?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<INotificationDiagnosticLog>> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/diagnosticlogs/{source}/entries/{entryId}'
                .replace('{' + 'source' + '}', String(params.source))
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'entryId' + '}', String(params.entryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'source' is set
            if (params.source == null) {
                throw new Error('Missing required parameter source when calling listLogs');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listLogs');
            }
            // verify required parameter 'entryId' is set
            if (params.entryId == null) {
                throw new Error('Missing required parameter entryId when calling listLogs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listLogs');
            }
            if (params.startTime !== undefined) {
                queryParameters['startTime'] = params.startTime;
            }

            if (params.endTime !== undefined) {
                queryParameters['endTime'] = params.endTime;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DiagnosticsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param subscriptionId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSubscriptionDiagnostics (params: {  organization: string; subscriptionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionDiagnostics> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}/diagnostics'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscriptionDiagnostics');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getSubscriptionDiagnostics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscriptionDiagnostics');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param subscriptionId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSubscriptionDiagnostics_1 (params: {  subscriptionId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionDiagnostics> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getSubscriptionDiagnostics_1');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscriptionDiagnostics_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscriptionDiagnostics_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param subscriptionId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSubscriptionDiagnostics (params: {  organization: string; body: UpdateSubscripitonDiagnosticsParameters; subscriptionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionDiagnostics> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}/diagnostics'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSubscriptionDiagnostics');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSubscriptionDiagnostics');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling updateSubscriptionDiagnostics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSubscriptionDiagnostics');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param body 
         * @param subscriptionId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSubscriptionDiagnostics_2 (params: {  body: UpdateSubscripitonDiagnosticsParameters; subscriptionId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionDiagnostics> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions/{subscriptionId}/diagnostics'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSubscriptionDiagnostics_2');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling updateSubscriptionDiagnostics_2');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSubscriptionDiagnostics_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSubscriptionDiagnostics_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class DiffsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Find the closest common commit (the merge base) between base and target commits, and get the diff between either the base and target commits or common and target commits.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param diffCommonCommit If true, diff between common and target commits. If false, diff between base and target commits.
         * @param $Top Maximum number of changes to return. Defaults to 100.
         * @param $Skip Number of changes to skip
         * @param baseVersionOptions Version options - Specify additional modifiers to version (e.g Previous)
         * @param baseVersion Version string identifier (name of tag/branch, SHA1 of commit)
         * @param baseVersionType Version type (branch, tag, or commit). Determines how Id is interpreted
         * @param targetVersionOptions Version options - Specify additional modifiers to version (e.g Previous)
         * @param targetVersion Version string identifier (name of tag/branch, SHA1 of commit)
         * @param targetVersionType Version type (branch, tag, or commit). Determines how Id is interpreted
         */
        public getCommitDiffs (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; diffCommonCommit?: boolean; $Top?: number; $Skip?: number; baseVersionOptions?: string; baseVersion?: string; baseVersionType?: string; targetVersionOptions?: string; targetVersion?: string; targetVersionType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitCommitDiffs> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/diffs/commits'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCommitDiffs');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getCommitDiffs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCommitDiffs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCommitDiffs');
            }
            if (params.diffCommonCommit !== undefined) {
                queryParameters['diffCommonCommit'] = params.diffCommonCommit;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.baseVersionOptions !== undefined) {
                queryParameters['baseVersionOptions'] = params.baseVersionOptions;
            }

            if (params.baseVersion !== undefined) {
                queryParameters['baseVersion'] = params.baseVersion;
            }

            if (params.baseVersionType !== undefined) {
                queryParameters['baseVersionType'] = params.baseVersionType;
            }

            if (params.targetVersionOptions !== undefined) {
                queryParameters['targetVersionOptions'] = params.targetVersionOptions;
            }

            if (params.targetVersion !== undefined) {
                queryParameters['targetVersion'] = params.targetVersion;
            }

            if (params.targetVersionType !== undefined) {
                queryParameters['targetVersionType'] = params.targetVersionType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EndpointproxyApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Use ExecuteServiceEndpointRequest API Instead
         * @param organization The name of the Azure DevOps organization.
         * @param body Describes the data source to fetch.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryServiceEndpoint (params: {  organization: string; body: DataSourceBinding; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpointproxy'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryServiceEndpoint');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryServiceEndpoint');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryServiceEndpoint');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryServiceEndpoint');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EndpointsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a service endpoint.
         * @param organization The name of the Azure DevOps organization.
         * @param body Service endpoint to create.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createServiceEndpoint (params: {  organization: string; body: ServiceEndpoint; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ServiceEndpoint> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createServiceEndpoint');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createServiceEndpoint');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createServiceEndpoint');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createServiceEndpoint');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a service endpoint.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param endpointId Id of the service endpoint to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param deep Specific to AzureRM endpoint created in Automatic flow. When set to true, this will also delete corresponding AAD application in Azure. Default value is true.
         */
        public deleteServiceEndpoint (params: {  organization: string; project: string; endpointId: string; apiVersion: string; deep?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints/{endpointId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'endpointId' + '}', String(params.endpointId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteServiceEndpoint');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteServiceEndpoint');
            }
            // verify required parameter 'endpointId' is set
            if (params.endpointId == null) {
                throw new Error('Missing required parameter endpointId when calling deleteServiceEndpoint');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteServiceEndpoint');
            }
            if (params.deep !== undefined) {
                queryParameters['deep'] = params.deep;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the service endpoint details.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param endpointId Id of the service endpoint.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getServiceEndpointDetails (params: {  organization: string; project: string; endpointId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ServiceEndpoint> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints/{endpointId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'endpointId' + '}', String(params.endpointId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getServiceEndpointDetails');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getServiceEndpointDetails');
            }
            // verify required parameter 'endpointId' is set
            if (params.endpointId == null) {
                throw new Error('Missing required parameter endpointId when calling getServiceEndpointDetails');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getServiceEndpointDetails');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the service endpoints by name.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param endpointNames Names of the service endpoints.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param type Type of the service endpoints.
         * @param authSchemes Authorization schemes used for service endpoints.
         * @param owner Owner for service endpoints.
         * @param includeFailed Failed flag for service endpoints.
         * @param includeDetails Flag to include more details for service endpoints. This is for internal use only and the flag will be treated as false for all other requests
         */
        public getServiceEndpointsByNames (params: {  organization: string; project: string; endpointNames: string; apiVersion: string; type?: string; authSchemes?: string; owner?: string; includeFailed?: boolean; includeDetails?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ServiceEndpoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getServiceEndpointsByNames');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getServiceEndpointsByNames');
            }
            // verify required parameter 'endpointNames' is set
            if (params.endpointNames == null) {
                throw new Error('Missing required parameter endpointNames when calling getServiceEndpointsByNames');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getServiceEndpointsByNames');
            }
            if (params.endpointNames !== undefined) {
                queryParameters['endpointNames'] = params.endpointNames;
            }

            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.authSchemes !== undefined) {
                queryParameters['authSchemes'] = params.authSchemes;
            }

            if (params.owner !== undefined) {
                queryParameters['owner'] = params.owner;
            }

            if (params.includeFailed !== undefined) {
                queryParameters['includeFailed'] = params.includeFailed;
            }

            if (params.includeDetails !== undefined) {
                queryParameters['includeDetails'] = params.includeDetails;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a service endpoint.
         * @param organization The name of the Azure DevOps organization.
         * @param body Service endpoint to update.
         * @param project Project ID or project name
         * @param endpointId Id of the service endpoint to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param operation Operation for the service endpoint.
         */
        public updateServiceEndpoint (params: {  organization: string; body: ServiceEndpoint; project: string; endpointId: string; apiVersion: string; operation?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ServiceEndpoint> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints/{endpointId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'endpointId' + '}', String(params.endpointId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateServiceEndpoint');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateServiceEndpoint');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateServiceEndpoint');
            }
            // verify required parameter 'endpointId' is set
            if (params.endpointId == null) {
                throw new Error('Missing required parameter endpointId when calling updateServiceEndpoint');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateServiceEndpoint');
            }
            if (params.operation !== undefined) {
                queryParameters['operation'] = params.operation;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the service endpoints.
         * @param organization The name of the Azure DevOps organization.
         * @param body Names of the service endpoints to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateServiceEndpoints (params: {  organization: string; body: Array<ServiceEndpoint>; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ServiceEndpoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/endpoints'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateServiceEndpoints');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateServiceEndpoints');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateServiceEndpoints');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateServiceEndpoints');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ErrorsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testRunId The test run identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param type Filter for the particular type of errors.
         * @param subType Filter for a particular subtype of errors. You should not provide error subtype without error type.
         * @param detailed To include the details of test errors such as messagetext, request, stacktrace, testcasename, scenarioname, and lasterrordate.
         */
        public getLoadTestRunErrors (params: {  organization: string; testRunId: string; apiVersion: string; type?: string; subType?: string; detailed?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<LoadTestErrors> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testRuns/{testRunId}/errors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLoadTestRunErrors');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getLoadTestRunErrors');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLoadTestRunErrors');
            }
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.subType !== undefined) {
                queryParameters['subType'] = params.subType;
            }

            if (params.detailed !== undefined) {
                queryParameters['detailed'] = params.detailed;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EvaluationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the present evaluation state of a policy.  Each policy which applies to a pull request will have an evaluation state which is specific to that policy running in the context of that pull request. Each evaluation is uniquely identified via a Guid. You can find all the policy evaluations for a specific pull request using the List operation of this controller.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param evaluationId ID of the policy evaluation to be retrieved.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPolicyEvaluation (params: {  organization: string; project: string; evaluationId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyEvaluationRecord> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/evaluations/{evaluationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'evaluationId' + '}', String(params.evaluationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyEvaluation');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyEvaluation');
            }
            // verify required parameter 'evaluationId' is set
            if (params.evaluationId == null) {
                throw new Error('Missing required parameter evaluationId when calling getPolicyEvaluation');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyEvaluation');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves a list of all the policy evaluation statuses for a specific pull request.  Evaluations are retrieved using an artifact ID which uniquely identifies the pull request. To generate an artifact ID for a pull request, use this template: &#x60;&#x60;&#x60; vstfs:///CodeReview/CodeReviewId/{projectId}/{pullRequestId} &#x60;&#x60;&#x60;
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param artifactId A string which uniquely identifies the target of a policy evaluation.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeNotApplicable Some policies might determine that they do not apply to a specific pull request. Setting this parameter to true will return evaluation records even for policies which don&#39;t apply to this pull request.
         * @param $Top The number of policy evaluation records to retrieve.
         * @param $Skip The number of policy evaluation records to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
         */
        public getPolicyEvaluations (params: {  organization: string; project: string; artifactId: string; apiVersion: string; includeNotApplicable?: boolean; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PolicyEvaluationRecord>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/evaluations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyEvaluations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyEvaluations');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling getPolicyEvaluations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyEvaluations');
            }
            if (params.artifactId !== undefined) {
                queryParameters['artifactId'] = params.artifactId;
            }

            if (params.includeNotApplicable !== undefined) {
                queryParameters['includeNotApplicable'] = params.includeNotApplicable;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Requeue the policy evaluation.  Some policies define a &quot;requeue&quot; action which performs some policy-specific operation. You can trigger this operation by updating an existing policy evaluation and setting the PolicyEvaluationRecord.Status field to Queued. Although any policy evaluation can be requeued, at present only build policies perform any action in response. Requeueing a build policy will queue a new build to run (cancelling any existing build which is running).
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param evaluationId ID of the policy evaluation to be retrieved.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public requeuePolicyEvaluation (params: {  organization: string; project: string; evaluationId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyEvaluationRecord> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/evaluations/{evaluationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'evaluationId' + '}', String(params.evaluationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling requeuePolicyEvaluation');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling requeuePolicyEvaluation');
            }
            // verify required parameter 'evaluationId' is set
            if (params.evaluationId == null) {
                throw new Error('Missing required parameter evaluationId when calling requeuePolicyEvaluation');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling requeuePolicyEvaluation');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EventTypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a specific event type.
         * @param eventType 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getEventType (params: {  eventType: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationEventType> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/eventtypes/{eventType}'
                .replace('{' + 'eventType' + '}', String(params.eventType))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'eventType' is set
            if (params.eventType == null) {
                throw new Error('Missing required parameter eventType when calling getEventType');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getEventType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getEventType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * List available event types for this service. Optionally filter by only event types for the specified publisher.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId Limit to event types for this publisher
         */
        public listEventTypes (params: {  organization: string; apiVersion: string; publisherId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<NotificationEventType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/eventtypes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listEventTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listEventTypes');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class EventsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Publish an event.
         * @param body 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public publishEvent (params: {  body: VssNotificationEvent; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<VssNotificationEvent> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/events'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling publishEvent');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling publishEvent');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling publishEvent');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ExecutionhistoryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get service endpoint execution records.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param endpointId Id of the service endpoint.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param top Number of service endpoint execution records to get.
         */
        public getServiceEndpointExecutionRecords (params: {  organization: string; project: string; endpointId: string; apiVersion: string; top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ServiceEndpointExecutionRecord>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/serviceendpoint/{endpointId}/executionhistory'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'endpointId' + '}', String(params.endpointId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getServiceEndpointExecutionRecords');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getServiceEndpointExecutionRecords');
            }
            // verify required parameter 'endpointId' is set
            if (params.endpointId == null) {
                throw new Error('Missing required parameter endpointId when calling getServiceEndpointExecutionRecords');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getServiceEndpointExecutionRecords');
            }
            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class FeedManagementApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a feed, a container for various package types.
         * @param organization The name of the Azure DevOps organization.
         * @param body A JSON object containing both required and optional attributes for the feed. Name is the only required value.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createFeed (params: {  organization: string; body: Feed; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Feed> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createFeed');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createFeed');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createFeed');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a new view on the referenced feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body View to be created.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createFeedView (params: {  organization: string; body: FeedView; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedView> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/views'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createFeedView');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createFeedView');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling createFeedView');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createFeedView');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Remove a feed and all its packages.  The action does not result in packages moving to the RecycleBin and is not reversible.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteFeed (params: {  organization: string; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteFeed');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deleteFeed');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteFeed');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a feed view.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param viewId Name or Id of the view.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteFeedView (params: {  organization: string; feedId: string; viewId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/views/{viewId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'viewId' + '}', String(params.viewId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteFeedView');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deleteFeedView');
            }
            // verify required parameter 'viewId' is set
            if (params.viewId == null) {
                throw new Error('Missing required parameter viewId when calling deleteFeedView');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteFeedView');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the settings for a specific feed.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeDeletedUpstreams Include upstreams that have been deleted in the response.
         */
        public getFeed (params: {  organization: string; feedId: string; apiVersion: string; includeDeletedUpstreams?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Feed> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeed');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeed');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeed');
            }
            if (params.includeDeletedUpstreams !== undefined) {
                queryParameters['includeDeletedUpstreams'] = params.includeDeletedUpstreams;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the permissions for a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeIds True to include user Ids in the response.  Default is false.
         * @param excludeInheritedPermissions True to only return explicitly set permissions on the feed.  Default is false.
         * @param identityDescriptor Filter permissions to the provided identity.
         */
        public getFeedPermissions (params: {  organization: string; feedId: string; apiVersion: string; includeIds?: boolean; excludeInheritedPermissions?: boolean; identityDescriptor?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<FeedPermission>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/permissions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedPermissions');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeedPermissions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedPermissions');
            }
            if (params.includeIds !== undefined) {
                queryParameters['includeIds'] = params.includeIds;
            }

            if (params.excludeInheritedPermissions !== undefined) {
                queryParameters['excludeInheritedPermissions'] = params.excludeInheritedPermissions;
            }

            if (params.identityDescriptor !== undefined) {
                queryParameters['identityDescriptor'] = params.identityDescriptor;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a view by Id.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param viewId Name or Id of the view.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFeedView (params: {  organization: string; feedId: string; viewId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedView> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/views/{viewId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'viewId' + '}', String(params.viewId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedView');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeedView');
            }
            // verify required parameter 'viewId' is set
            if (params.viewId == null) {
                throw new Error('Missing required parameter viewId when calling getFeedView');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedView');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all views for a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFeedViews (params: {  organization: string; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<FeedView>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/views'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedViews');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeedViews');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedViews');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all feeds in an account where you have the provided role access.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param feedRole Filter by this role, either Administrator(4), Contributor(3), or Reader(2) level permissions.
         * @param includeDeletedUpstreams Include upstreams that have been deleted in the response.
         */
        public getFeeds (params: {  organization: string; apiVersion: string; feedRole?: string; includeDeletedUpstreams?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Feed>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeeds');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeeds');
            }
            if (params.feedRole !== undefined) {
                queryParameters['feedRole'] = params.feedRole;
            }

            if (params.includeDeletedUpstreams !== undefined) {
                queryParameters['includeDeletedUpstreams'] = params.includeDeletedUpstreams;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the permissions on a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Permissions to set.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setFeedPermissions (params: {  organization: string; body: Array<FeedPermission>; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<FeedPermission>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/permissions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setFeedPermissions');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setFeedPermissions');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling setFeedPermissions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setFeedPermissions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Change the attributes of a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body A JSON object containing the feed settings to be updated.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateFeed (params: {  organization: string; body: FeedUpdate; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Feed> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateFeed');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateFeed');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updateFeed');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateFeed');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a view.
         * @param organization The name of the Azure DevOps organization.
         * @param body New settings to apply to the specified view.
         * @param feedId Name or Id of the feed.
         * @param viewId Name or Id of the view.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateFeedView (params: {  organization: string; body: FeedView; feedId: string; viewId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedView> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/views/{viewId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'viewId' + '}', String(params.viewId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateFeedView');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateFeedView');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updateFeedView');
            }
            // verify required parameter 'viewId' is set
            if (params.viewId == null) {
                throw new Error('Missing required parameter viewId when calling updateFeedView');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateFeedView');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class FieldsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a field to a work item type.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addFieldToWorkItemType (params: {  organization: string; body: AddProcessWorkItemTypeFieldRequest; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemTypeField> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addFieldToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addFieldToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addFieldToWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addFieldToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addFieldToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a single field in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createField (params: {  organization: string; body: FieldModel; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FieldModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createField');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a new field.
         * @param organization The name of the Azure DevOps organization.
         * @param body New field definition
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createField_1 (params: {  organization: string; body: WorkItemField; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemField> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createField_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createField_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createField_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createField_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes the field.
         * @param organization The name of the Azure DevOps organization.
         * @param fieldNameOrRefName Field simple name or reference name
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteField (params: {  organization: string; fieldNameOrRefName: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/fields/{fieldNameOrRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'fieldNameOrRefName' + '}', String(params.fieldNameOrRefName))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteField');
            }
            // verify required parameter 'fieldNameOrRefName' is set
            if (params.fieldNameOrRefName == null) {
                throw new Error('Missing required parameter fieldNameOrRefName when calling deleteField');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all fields in a work item type.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getAllWorkItemTypeFields (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProcessWorkItemTypeField>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAllWorkItemTypeFields');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getAllWorkItemTypeFields');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getAllWorkItemTypeFields');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAllWorkItemTypeFields');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets information on a specific field.
         * @param organization The name of the Azure DevOps organization.
         * @param fieldNameOrRefName Field simple name or reference name
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getField (params: {  organization: string; fieldNameOrRefName: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemField> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/fields/{fieldNameOrRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'fieldNameOrRefName' + '}', String(params.fieldNameOrRefName))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getField');
            }
            // verify required parameter 'fieldNameOrRefName' is set
            if (params.fieldNameOrRefName == null) {
                throw new Error('Missing required parameter fieldNameOrRefName when calling getField');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns information for all fields.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand Use ExtensionFields to include extension fields, otherwise exclude them. Unless the feature flag for this parameter is enabled, extension fields are always included.
         */
        public getFields (params: {  organization: string; project: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemField>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFields');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getFields');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFields');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a field in a work item type.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param fieldRefName The reference name of the field.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWorkItemTypeField (params: {  organization: string; processId: string; witRefName: string; fieldRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemTypeField> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/fields/{fieldRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'fieldRefName' + '}', String(params.fieldRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getWorkItemTypeField');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getWorkItemTypeField');
            }
            // verify required parameter 'fieldRefName' is set
            if (params.fieldRefName == null) {
                throw new Error('Missing required parameter fieldRefName when calling getWorkItemTypeField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a field from a work item type. Does not permanently delete the field.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param fieldRefName The reference name of the field.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public removeWorkItemTypeField (params: {  organization: string; processId: string; witRefName: string; fieldRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/fields/{fieldRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'fieldRefName' + '}', String(params.fieldRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeWorkItemTypeField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeWorkItemTypeField');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removeWorkItemTypeField');
            }
            // verify required parameter 'fieldRefName' is set
            if (params.fieldRefName == null) {
                throw new Error('Missing required parameter fieldRefName when calling removeWorkItemTypeField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeWorkItemTypeField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a given field in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateField (params: {  organization: string; body: FieldUpdate; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FieldModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateField');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a field in a work item type.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param fieldRefName The reference name of the field.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateWorkItemTypeField (params: {  organization: string; body: UpdateProcessWorkItemTypeFieldRequest; processId: string; witRefName: string; fieldRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemTypeField> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/fields/{fieldRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'fieldRefName' + '}', String(params.fieldRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWorkItemTypeField');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWorkItemTypeField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateWorkItemTypeField');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateWorkItemTypeField');
            }
            // verify required parameter 'fieldRefName' is set
            if (params.fieldRefName == null) {
                throw new Error('Missing required parameter fieldRefName when calling updateWorkItemTypeField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWorkItemTypeField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class FoldersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a new folder.
         * @param organization The name of the Azure DevOps organization.
         * @param body The folder.
         * @param project Project ID or project name
         * @param path The full path of the folder.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createFolder (params: {  organization: string; body: Folder; project: string; path: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Folder> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/folders/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createFolder');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createFolder');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createFolder');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling createFolder');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createFolder');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a definition folder. Definitions and their corresponding builds will also be deleted.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param path The full path to the folder.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteFolder (params: {  organization: string; project: string; path: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/folders/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteFolder');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteFolder');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling deleteFolder');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteFolder');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of build definition folders.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param path The path to start with.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param queryOrder The order in which folders should be returned.
         */
        public getFolders (params: {  organization: string; project: string; path: string; apiVersion: string; queryOrder?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Folder>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/folders/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFolders');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getFolders');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling getFolders');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFolders');
            }
            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates an existing folder at given  existing path
         * @param organization The name of the Azure DevOps organization.
         * @param body The new version of the folder.
         * @param project Project ID or project name
         * @param path The full path to the folder.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateFolder (params: {  organization: string; body: Folder; project: string; path: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Folder> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/folders/{path}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'path' + '}', String(params.path));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateFolder');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateFolder');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateFolder');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling updateFolder');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateFolder');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ForksApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Request that another repository&#39;s refs be fetched into this one. It syncs two existing forks. To create a fork, please see the &lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/rest/api/vsts/git/repositories/create?view&#x3D;azure-devops-rest-5.1&quot;&gt; repositories endpoint&lt;/a&gt;
         * @param organization The name of the Azure DevOps organization.
         * @param body Source repository and ref mapping.
         * @param repositoryNameOrId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks True to include links
         */
        public createForkSyncRequest (params: {  organization: string; body: GitForkSyncRequestParameters; repositoryNameOrId: string; project: string; apiVersion: string; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitForkSyncRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createForkSyncRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createForkSyncRequest');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling createForkSyncRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createForkSyncRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createForkSyncRequest');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific fork sync operation&#39;s details.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryNameOrId The name or ID of the repository.
         * @param forkSyncOperationId OperationId of the sync request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks True to include links.
         */
        public getForkSyncRequest (params: {  organization: string; repositoryNameOrId: string; forkSyncOperationId: number; project: string; apiVersion: string; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitForkSyncRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests/{forkSyncOperationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'forkSyncOperationId' + '}', String(params.forkSyncOperationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getForkSyncRequest');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling getForkSyncRequest');
            }
            // verify required parameter 'forkSyncOperationId' is set
            if (params.forkSyncOperationId == null) {
                throw new Error('Missing required parameter forkSyncOperationId when calling getForkSyncRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getForkSyncRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getForkSyncRequest');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all requested fork sync operations on this repository.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryNameOrId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeAbandoned True to include abandoned requests.
         * @param includeLinks True to include links.
         */
        public getForkSyncRequests (params: {  organization: string; repositoryNameOrId: string; project: string; apiVersion: string; includeAbandoned?: boolean; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitForkSyncRequest>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forkSyncRequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getForkSyncRequests');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling getForkSyncRequests');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getForkSyncRequests');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getForkSyncRequests');
            }
            if (params.includeAbandoned !== undefined) {
                queryParameters['includeAbandoned'] = params.includeAbandoned;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all forks of a repository in the collection.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryNameOrId The name or ID of the repository.
         * @param collectionId Team project collection ID.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks True to include links.
         */
        public getForks (params: {  organization: string; repositoryNameOrId: string; collectionId: string; project: string; apiVersion: string; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitRepositoryRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/forks/{collectionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'collectionId' + '}', String(params.collectionId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getForks');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling getForks');
            }
            // verify required parameter 'collectionId' is set
            if (params.collectionId == null) {
                throw new Error('Missing required parameter collectionId when calling getForks');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getForks');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getForks');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Updates the gate for a deployment.
         * @param organization The name of the Azure DevOps organization.
         * @param body Metadata to patch the Release Gates.
         * @param project Project ID or project name
         * @param gateStepId Gate step Id.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateGates (params: {  organization: string; body: GateUpdateMetadata; project: string; gateStepId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseGates> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/gates/{gateStepId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'gateStepId' + '}', String(params.gateStepId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateGates');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateGates');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateGates');
            }
            // verify required parameter 'gateStepId' is set
            if (params.gateStepId == null) {
                throw new Error('Missing required parameter gateStepId when calling updateGates');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateGates');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupEntitlementsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a group entitlement with license rule, extension rule.
         * @param organization The name of the Azure DevOps organization.
         * @param body GroupEntitlement object specifying License Rule, Extensions Rule for the group. Based on the rules the members of the group will be given licenses and extensions. The Group Entitlement can be used to add the group to another project level groups
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param ruleOption RuleOption [ApplyGroupRule/TestApplyGroupRule] - specifies if the rules defined in group entitlement should be created and applied to it’s members (default option) or just be tested
         */
        public addGroupEntitlement (params: {  organization: string; body: GroupEntitlement; apiVersion: string; ruleOption?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GroupEntitlementOperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/groupentitlements'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addGroupEntitlement');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addGroupEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addGroupEntitlement');
            }
            if (params.ruleOption !== undefined) {
                queryParameters['ruleOption'] = params.ruleOption;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a group entitlement.
         * @param organization The name of the Azure DevOps organization.
         * @param groupId ID of the group to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param ruleOption RuleOption [ApplyGroupRule/TestApplyGroupRule] - specifies if the rules defined in group entitlement should be deleted and the changes are applied to it’s members (default option) or just be tested
         * @param removeGroupMembership Optional parameter that specifies whether the group with the given ID should be removed from all other groups
         */
        public deleteGroupEntitlement (params: {  organization: string; groupId: string; apiVersion: string; ruleOption?: string; removeGroupMembership?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GroupEntitlementOperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/groupentitlements/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteGroupEntitlement');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling deleteGroupEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteGroupEntitlement');
            }
            if (params.ruleOption !== undefined) {
                queryParameters['ruleOption'] = params.ruleOption;
            }

            if (params.removeGroupMembership !== undefined) {
                queryParameters['removeGroupMembership'] = params.removeGroupMembership;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a group entitlement.  If the group entitlement does not exist, returns null.
         * @param organization The name of the Azure DevOps organization.
         * @param groupId ID of the group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getGroupEntitlement (params: {  organization: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GroupEntitlement> {
            const localVarPath = this.basePath + '/{organization}/_apis/groupentitlements/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getGroupEntitlement');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling getGroupEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getGroupEntitlement');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the group entitlements for an account.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getGroupEntitlements (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GroupEntitlement>> {
            const localVarPath = this.basePath + '/{organization}/_apis/groupentitlements'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getGroupEntitlements');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getGroupEntitlements');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update entitlements (License Rule, Extensions Rule, Project memberships etc.) for a group.
         * @param organization The name of the Azure DevOps organization.
         * @param body JsonPatchDocument containing the operations to perform on the group.
         * @param groupId ID of the group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param ruleOption RuleOption [ApplyGroupRule/TestApplyGroupRule] - specifies if the rules defined in group entitlement should be updated and the changes are applied to it’s members (default option) or just be tested
         */
        public updateGroupEntitlement (params: {  organization: string; body: JsonPatchDocument; groupId: string; apiVersion: string; ruleOption?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GroupEntitlementOperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/groupentitlements/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateGroupEntitlement');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateGroupEntitlement');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling updateGroupEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateGroupEntitlement');
            }
            if (params.ruleOption !== undefined) {
                queryParameters['ruleOption'] = params.ruleOption;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class GroupsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a group to the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The group
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page to add the group to
         * @param sectionId The ID of the section to add the group to
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addGroup (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addGroup');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling addGroup');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling addGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Adds a group to the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param body The group.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param pageId The ID of the page to add the group to.
         * @param sectionId The ID of the section to add the group to.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addGroup_1 (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addGroup_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addGroup_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addGroup_1');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addGroup_1');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling addGroup_1');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling addGroup_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addGroup_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a new VSTS group or materialize an existing AAD group.  The body of the request must be a derived type of GraphGroupCreationContext:   * GraphGroupVstsCreationContext - Create a new VSTS group that is not backed by an external provider.   * GraphGroupMailAddressCreationContext - Create a new group using the mail address as a reference to an existing group from an external AD or AAD backed provider.   * GraphGroupOriginIdCreationContext - Create a new group using the OriginID as a reference to a group from an external AD or AAD backed provider.   Optionally, you can add the newly created group as a member of an existing VSTS group and/or specify a custom storage key for the group.
         * @param organization The name of the Azure DevOps organization.
         * @param body The subset of the full graph group used to uniquely find the graph subject in an external provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param scopeDescriptor A descriptor referencing the scope (collection, project) in which the group should be created. If omitted, will be created in the scope of the enclosing account or organization. Valid only for VSTS groups.
         * @param groupDescriptors A comma separated list of descriptors referencing groups you want the graph group to join
         */
        public createGroup (params: {  organization: string; body: GraphGroupCreationContext; apiVersion: string; scopeDescriptor?: string; groupDescriptors?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphGroup> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/groups'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createGroup');
            }
            if (params.scopeDescriptor !== undefined) {
                queryParameters['scopeDescriptor'] = params.scopeDescriptor;
            }

            if (params.groupDescriptors !== undefined) {
                queryParameters['groupDescriptors'] = params.groupDescriptors;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a VSTS group from all of its parent groups.  The group will still be visible, but membership  checks for the group, and all descendants which derive membership through it, will return false.”
         * @param organization The name of the Azure DevOps organization.
         * @param groupDescriptor The descriptor of the group to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteGroup (params: {  organization: string; groupDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/groups/{groupDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupDescriptor' + '}', String(params.groupDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteGroup');
            }
            // verify required parameter 'groupDescriptor' is set
            if (params.groupDescriptor == null) {
                throw new Error('Missing required parameter groupDescriptor when calling deleteGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a group in the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated group
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page the group is in
         * @param sectionId The ID of the section the group is in
         * @param groupId The ID of the group
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public editGroup (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling editGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling editGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling editGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling editGroup');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling editGroup');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling editGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling editGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling editGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a group by its descriptor.  The group will be returned even if it has been deleted from the account or has had all its memberships deleted.
         * @param organization The name of the Azure DevOps organization.
         * @param groupDescriptor The descriptor of the desired graph group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getGroup (params: {  organization: string; groupDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphGroup> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/groups/{groupDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupDescriptor' + '}', String(params.groupDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getGroup');
            }
            // verify required parameter 'groupDescriptor' is set
            if (params.groupDescriptor == null) {
                throw new Error('Missing required parameter groupDescriptor when calling getGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of all groups in the current scope (usually organization or account).  The optional parameters are used to filter down the returned results. Returned results are in no guaranteed order.   Since the list of groups may be large, results are returned in pages of groups.  If there are more results  than can be returned in a single page, the result set will contain a continuation token for retrieval of the  next set of results.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param scopeDescriptor Specify a non-default scope (collection, project) to search for groups.
         * @param subjectTypes A comma separated list of user subject subtypes to reduce the retrieved results, e.g. Microsoft.IdentityModel.Claims.ClaimsIdentity
         * @param continuationToken An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
         */
        public listGroups (params: {  organization: string; apiVersion: string; scopeDescriptor?: string; subjectTypes?: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GraphGroup>> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/groups'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listGroups');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listGroups');
            }
            if (params.scopeDescriptor !== undefined) {
                queryParameters['scopeDescriptor'] = params.scopeDescriptor;
            }

            if (params.subjectTypes !== undefined) {
                queryParameters['subjectTypes'] = params.subjectTypes;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Moves a group to a different section.
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated group.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param pageId The ID of the page the group is in.
         * @param sectionId The ID of the section the group is in.
         * @param groupId The ID of the group.
         * @param removeFromSectionId ID of the section to remove the group from.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public moveGroupToSection (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; removeFromSectionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling moveGroupToSection');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling moveGroupToSection');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling moveGroupToSection');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling moveGroupToSection');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling moveGroupToSection');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling moveGroupToSection');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling moveGroupToSection');
            }
            // verify required parameter 'removeFromSectionId' is set
            if (params.removeFromSectionId == null) {
                throw new Error('Missing required parameter removeFromSectionId when calling moveGroupToSection');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling moveGroupToSection');
            }
            if (params.removeFromSectionId !== undefined) {
                queryParameters['removeFromSectionId'] = params.removeFromSectionId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a group from the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page the group is in
         * @param sectionId The ID of the section to the group is in
         * @param groupId The ID of the group
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeGroup (params: {  organization: string; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeGroup');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeGroup');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removeGroup');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling removeGroup');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling removeGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling removeGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a group from the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page the group is in
         * @param sectionId The ID of the section to the group is in
         * @param groupId The ID of the group
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeGroup_2 (params: {  organization: string; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeGroup_2');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeGroup_2');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removeGroup_2');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling removeGroup_2');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling removeGroup_2');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling removeGroup_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeGroup_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Moves a group to a different section
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated group
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page the group is in
         * @param sectionId The ID of the section the group is in
         * @param groupId The ID of the group
         * @param removeFromSectionId ID of the section to remove the group from
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setGroupInSection (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; removeFromSectionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setGroupInSection');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setGroupInSection');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling setGroupInSection');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling setGroupInSection');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling setGroupInSection');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling setGroupInSection');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling setGroupInSection');
            }
            // verify required parameter 'removeFromSectionId' is set
            if (params.removeFromSectionId == null) {
                throw new Error('Missing required parameter removeFromSectionId when calling setGroupInSection');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setGroupInSection');
            }
            if (params.removeFromSectionId !== undefined) {
                queryParameters['removeFromSectionId'] = params.removeFromSectionId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the properties of a VSTS group.  Currently limited to only changing the description and account name.
         * @param organization The name of the Azure DevOps organization.
         * @param groupDescriptor The descriptor of the group to modify.
         * @param body The JSON+Patch document containing the fields to alter.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateGroup (params: {  organization: string; groupDescriptor: string; body: JsonPatchDocument; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphGroup> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/groups/{groupDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupDescriptor' + '}', String(params.groupDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateGroup');
            }
            // verify required parameter 'groupDescriptor' is set
            if (params.groupDescriptor == null) {
                throw new Error('Missing required parameter groupDescriptor when calling updateGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a group in the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated group.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param pageId The ID of the page the group is in.
         * @param sectionId The ID of the section the group is in.
         * @param groupId The ID of the group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateGroup_3 (params: {  organization: string; body: Group; processId: string; witRefName: string; pageId: string; sectionId: string; groupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Group> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}/sections/{sectionId}/groups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId))
                .replace('{' + 'sectionId' + '}', String(params.sectionId))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateGroup_3');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateGroup_3');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateGroup_3');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateGroup_3');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling updateGroup_3');
            }
            // verify required parameter 'sectionId' is set
            if (params.sectionId == null) {
                throw new Error('Missing required parameter sectionId when calling updateGroup_3');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling updateGroup_3');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateGroup_3');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ImportRequestsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create an import request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The import request to create.
         * @param project Project ID or project name
         * @param repositoryId The name or ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createImportRequest (params: {  organization: string; body: GitImportRequest; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitImportRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createImportRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createImportRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createImportRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createImportRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createImportRequest');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a particular import request.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId The name or ID of the repository.
         * @param importRequestId The unique identifier for the import request.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getImportRequest (params: {  organization: string; project: string; repositoryId: string; importRequestId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitImportRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'importRequestId' + '}', String(params.importRequestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getImportRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getImportRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getImportRequest');
            }
            // verify required parameter 'importRequestId' is set
            if (params.importRequestId == null) {
                throw new Error('Missing required parameter importRequestId when calling getImportRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getImportRequest');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve import requests for a repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId The name or ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeAbandoned True to include abandoned import requests in the results.
         */
        public queryImportRequests (params: {  organization: string; project: string; repositoryId: string; apiVersion: string; includeAbandoned?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitImportRequest>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryImportRequests');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryImportRequests');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling queryImportRequests');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryImportRequests');
            }
            if (params.includeAbandoned !== undefined) {
                queryParameters['includeAbandoned'] = params.includeAbandoned;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retry or abandon a failed import request.  There can only be one active import request associated with a repository. Marking a failed import request abandoned makes it inactive.
         * @param organization The name of the Azure DevOps organization.
         * @param body The updated version of the import request. Currently, the only change allowed is setting the Status to Queued or Abandoned.
         * @param project Project ID or project name
         * @param repositoryId The name or ID of the repository.
         * @param importRequestId The unique identifier for the import request to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateImportRequest (params: {  organization: string; body: GitImportRequest; project: string; repositoryId: string; importRequestId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitImportRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/importRequests/{importRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'importRequestId' + '}', String(params.importRequestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateImportRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateImportRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateImportRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateImportRequest');
            }
            // verify required parameter 'importRequestId' is set
            if (params.importRequestId == null) {
                throw new Error('Missing required parameter importRequestId when calling updateImportRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateImportRequest');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class InstalledExtensionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get an installed extension by its publisher and extension name.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherName Name of the publisher. Example: &quot;fabrikam&quot;.
         * @param extensionName Name of the extension. Example: &quot;ops-tools&quot;.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param assetTypes 
         */
        public getInstalledExtensionByName (params: {  organization: string; publisherName: string; extensionName: string; apiVersion: string; assetTypes?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<InstalledExtension> {
            const localVarPath = this.basePath + '/{organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherName' + '}', String(params.publisherName))
                .replace('{' + 'extensionName' + '}', String(params.extensionName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getInstalledExtensionByName');
            }
            // verify required parameter 'publisherName' is set
            if (params.publisherName == null) {
                throw new Error('Missing required parameter publisherName when calling getInstalledExtensionByName');
            }
            // verify required parameter 'extensionName' is set
            if (params.extensionName == null) {
                throw new Error('Missing required parameter extensionName when calling getInstalledExtensionByName');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getInstalledExtensionByName');
            }
            if (params.assetTypes !== undefined) {
                queryParameters['assetTypes'] = params.assetTypes;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * List the installed extensions in the account / project collection.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeDisabledExtensions If true (the default), include disabled extensions in the results.
         * @param includeErrors If true, include installed extensions with errors.
         * @param assetTypes 
         * @param includeInstallationIssues 
         */
        public getInstalledExtensions (params: {  organization: string; apiVersion: string; includeDisabledExtensions?: boolean; includeErrors?: boolean; assetTypes?: string; includeInstallationIssues?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<InstalledExtension>> {
            const localVarPath = this.basePath + '/{organization}/_apis/extensionmanagement/installedextensions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getInstalledExtensions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getInstalledExtensions');
            }
            if (params.includeDisabledExtensions !== undefined) {
                queryParameters['includeDisabledExtensions'] = params.includeDisabledExtensions;
            }

            if (params.includeErrors !== undefined) {
                queryParameters['includeErrors'] = params.includeErrors;
            }

            if (params.assetTypes !== undefined) {
                queryParameters['assetTypes'] = params.assetTypes;
            }

            if (params.includeInstallationIssues !== undefined) {
                queryParameters['includeInstallationIssues'] = params.includeInstallationIssues;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Install the specified extension into the account / project collection.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherName Name of the publisher. Example: &quot;fabrikam&quot;.
         * @param extensionName Name of the extension. Example: &quot;ops-tools&quot;.
         * @param version 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public installExtensionByName (params: {  organization: string; publisherName: string; extensionName: string; version: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<InstalledExtension> {
            const localVarPath = this.basePath + '/{organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherName' + '}', String(params.publisherName))
                .replace('{' + 'extensionName' + '}', String(params.extensionName))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling installExtensionByName');
            }
            // verify required parameter 'publisherName' is set
            if (params.publisherName == null) {
                throw new Error('Missing required parameter publisherName when calling installExtensionByName');
            }
            // verify required parameter 'extensionName' is set
            if (params.extensionName == null) {
                throw new Error('Missing required parameter extensionName when calling installExtensionByName');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling installExtensionByName');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling installExtensionByName');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Uninstall the specified extension from the account / project collection.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherName Name of the publisher. Example: &quot;fabrikam&quot;.
         * @param extensionName Name of the extension. Example: &quot;ops-tools&quot;.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param reason 
         * @param reasonCode 
         */
        public uninstallExtensionByName (params: {  organization: string; publisherName: string; extensionName: string; apiVersion: string; reason?: string; reasonCode?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/extensionmanagement/installedextensionsbyname/{publisherName}/{extensionName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherName' + '}', String(params.publisherName))
                .replace('{' + 'extensionName' + '}', String(params.extensionName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling uninstallExtensionByName');
            }
            // verify required parameter 'publisherName' is set
            if (params.publisherName == null) {
                throw new Error('Missing required parameter publisherName when calling uninstallExtensionByName');
            }
            // verify required parameter 'extensionName' is set
            if (params.extensionName == null) {
                throw new Error('Missing required parameter extensionName when calling uninstallExtensionByName');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling uninstallExtensionByName');
            }
            if (params.reason !== undefined) {
                queryParameters['reason'] = params.reason;
            }

            if (params.reasonCode !== undefined) {
                queryParameters['reasonCode'] = params.reasonCode;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update an installed extension. Typically this API is used to enable or disable an extension.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateInstalledExtension (params: {  organization: string; body: InstalledExtension; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<InstalledExtension> {
            const localVarPath = this.basePath + '/{organization}/_apis/extensionmanagement/installedextensions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateInstalledExtension');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateInstalledExtension');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateInstalledExtension');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ItemsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn&#39;t apply to zipped content which is always returned as a download.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param scopePath The path scope.  The default is null.
         * @param recursionLevel The recursion level of this request. The default is &#39;none&#39;, no recursion.
         * @param includeContentMetadata Set to true to include content metadata.  Default is false.
         * @param latestProcessedChange Set to true to include the lastest changes.  Default is false.
         * @param download Set to true to download the response as a file.  Default is false.
         * @param includeLinks Set to true to include links to items.  Default is false.
         * @param $Format If specified, this overrides the HTTP Accept request header to return either &#39;json&#39; or &#39;zip&#39;. If $format is specified, then api-version should also be specified as a query parameter.
         * @param versionDescriptorVersionOptions Version options - Specify additional modifiers to version (e.g Previous)
         * @param versionDescriptorVersion Version string identifier (name of tag/branch, SHA1 of commit)
         * @param versionDescriptorVersionType Version type (branch, tag, or commit). Determines how Id is interpreted
         */
        public getItems (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; scopePath?: string; recursionLevel?: string; includeContentMetadata?: boolean; latestProcessedChange?: boolean; download?: boolean; includeLinks?: boolean; $Format?: string; versionDescriptorVersionOptions?: string; versionDescriptorVersion?: string; versionDescriptorVersionType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/items'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getItems');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getItems');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getItems');
            }
            if (params.scopePath !== undefined) {
                queryParameters['scopePath'] = params.scopePath;
            }

            if (params.recursionLevel !== undefined) {
                queryParameters['recursionLevel'] = params.recursionLevel;
            }

            if (params.includeContentMetadata !== undefined) {
                queryParameters['includeContentMetadata'] = params.includeContentMetadata;
            }

            if (params.latestProcessedChange !== undefined) {
                queryParameters['latestProcessedChange'] = params.latestProcessedChange;
            }

            if (params.download !== undefined) {
                queryParameters['download'] = params.download;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.$Format !== undefined) {
                queryParameters['$format'] = params.$Format;
            }

            if (params.versionDescriptorVersionOptions !== undefined) {
                queryParameters['versionDescriptor.versionOptions'] = params.versionDescriptorVersionOptions;
            }

            if (params.versionDescriptorVersion !== undefined) {
                queryParameters['versionDescriptor.version'] = params.versionDescriptorVersion;
            }

            if (params.versionDescriptorVersionType !== undefined) {
                queryParameters['versionDescriptor.versionType'] = params.versionDescriptorVersionType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
         * @param organization The name of the Azure DevOps organization.
         * @param body Request data attributes: ItemDescriptors, IncludeContentMetadata, LatestProcessedChange, IncludeLinks. ItemDescriptors: Collection of items to fetch, including path, version, and recursion level. IncludeContentMetadata: Whether to include metadata for all items LatestProcessedChange: Whether to include shallow ref to commit that last changed each item. IncludeLinks: Whether to include the _links field on the shallow references.
         * @param repositoryId The name or ID of the repository
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getItemsBatch (params: {  organization: string; body: GitItemRequestData; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Array<ERRORUNKNOWN>>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/itemsbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getItemsBatch');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getItemsBatch');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getItemsBatch');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getItemsBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getItemsBatch');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Post for retrieving a set of items given a list of paths or a long path. Allows for specifying the recursionLevel and version descriptors for each path.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getItemsBatch_1 (params: {  organization: string; body: TfvcItemRequestData; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Array<ERRORUNKNOWN>>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/itembatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getItemsBatch_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getItemsBatch_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getItemsBatch_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getItemsBatch_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of Tfvc items
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param scopePath Version control path of a folder to return multiple items.
         * @param recursionLevel None (just the item), or OneLevel (contents of a folder).
         * @param includeLinks True to include links.
         * @param versionDescriptorVersion 
         * @param versionDescriptorVersionType 
         * @param versionDescriptorVersionOption 
         */
        public getItems_2 (params: {  organization: string; project: string; apiVersion: string; scopePath?: string; recursionLevel?: string; includeLinks?: boolean; versionDescriptorVersion?: string; versionDescriptorVersionType?: string; versionDescriptorVersionOption?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/items'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getItems_2');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getItems_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getItems_2');
            }
            if (params.scopePath !== undefined) {
                queryParameters['scopePath'] = params.scopePath;
            }

            if (params.recursionLevel !== undefined) {
                queryParameters['recursionLevel'] = params.recursionLevel;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.versionDescriptorVersion !== undefined) {
                queryParameters['versionDescriptor.version'] = params.versionDescriptorVersion;
            }

            if (params.versionDescriptorVersionType !== undefined) {
                queryParameters['versionDescriptor.versionType'] = params.versionDescriptorVersionType;
            }

            if (params.versionDescriptorVersionOption !== undefined) {
                queryParameters['versionDescriptor.versionOption'] = params.versionDescriptorVersionOption;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class IterationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a team&#39;s iteration by iterationId
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTeamIteration (params: {  organization: string; project: string; id: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTeamIteration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTeamIteration');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling deleteTeamIteration');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling deleteTeamIteration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTeamIteration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get work items for iteration
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getIterationWorkItems (params: {  organization: string; project: string; iterationId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<IterationWorkItems> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getIterationWorkItems');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getIterationWorkItems');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getIterationWorkItems');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getIterationWorkItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getIterationWorkItems');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get team&#39;s iteration by iterationId
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTeamIteration (params: {  organization: string; project: string; id: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSettingsIteration> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamIteration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTeamIteration');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getTeamIteration');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTeamIteration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamIteration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a team&#39;s iterations using timeframe filter
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Timeframe A filter for which iterations are returned based on relative time. Only Current is supported currently.
         */
        public getTeamIterations (params: {  organization: string; project: string; team: string; apiVersion: string; $Timeframe?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TeamSettingsIteration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamIterations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTeamIterations');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTeamIterations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamIterations');
            }
            if (params.$Timeframe !== undefined) {
                queryParameters['$timeframe'] = params.$Timeframe;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get iteration for a result
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result that contains the iterations.
         * @param iterationId Id of the test results Iteration.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param includeActionResults Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
         */
        public getTestIteration (params: {  organization: string; project: string; runId: number; testCaseResultId: number; iterationId: number; apiVersion: string; includeActionResults?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestIterationDetailsModel> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/iterations/{iterationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestIteration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestIteration');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestIteration');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getTestIteration');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getTestIteration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestIteration');
            }
            if (params.includeActionResults !== undefined) {
                queryParameters['includeActionResults'] = params.includeActionResults;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get iterations for a result
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result that contains the iterations.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param includeActionResults Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
         */
        public getTestIterations (params: {  organization: string; project: string; runId: number; testCaseResultId: number; apiVersion: string; includeActionResults?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestIterationDetailsModel>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/iterations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestIterations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestIterations');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestIterations');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getTestIterations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestIterations');
            }
            if (params.includeActionResults !== undefined) {
                queryParameters['includeActionResults'] = params.includeActionResults;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Add an iteration to the team
         * @param organization The name of the Azure DevOps organization.
         * @param body Iteration to add
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public postTeamIteration (params: {  organization: string; body: TeamSettingsIteration; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSettingsIteration> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling postTeamIteration');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling postTeamIteration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling postTeamIteration');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling postTeamIteration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling postTeamIteration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LabelsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a single deep label.
         * @param organization The name of the Azure DevOps organization.
         * @param labelId Unique identifier of label
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param requestDataIncludeLinks Whether to include the _links field on the shallow references
         * @param requestDataMaxItemCount maxItemCount
         * @param requestDataItemLabelFilter maxItemCount
         * @param requestDataOwner maxItemCount
         * @param requestDataName maxItemCount
         * @param requestDataLabelScope maxItemCount
         */
        public getLabel (params: {  organization: string; labelId: string; project: string; apiVersion: string; requestDataIncludeLinks?: boolean; requestDataMaxItemCount?: number; requestDataItemLabelFilter?: string; requestDataOwner?: string; requestDataName?: string; requestDataLabelScope?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TfvcLabel> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/labels/{labelId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'labelId' + '}', String(params.labelId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLabel');
            }
            // verify required parameter 'labelId' is set
            if (params.labelId == null) {
                throw new Error('Missing required parameter labelId when calling getLabel');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getLabel');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLabel');
            }
            if (params.requestDataIncludeLinks !== undefined) {
                queryParameters['requestData.includeLinks'] = params.requestDataIncludeLinks;
            }

            if (params.requestDataMaxItemCount !== undefined) {
                queryParameters['requestData.maxItemCount'] = params.requestDataMaxItemCount;
            }

            if (params.requestDataItemLabelFilter !== undefined) {
                queryParameters['requestData.itemLabelFilter'] = params.requestDataItemLabelFilter;
            }

            if (params.requestDataOwner !== undefined) {
                queryParameters['requestData.owner'] = params.requestDataOwner;
            }

            if (params.requestDataName !== undefined) {
                queryParameters['requestData.name'] = params.requestDataName;
            }

            if (params.requestDataLabelScope !== undefined) {
                queryParameters['requestData.labelScope'] = params.requestDataLabelScope;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get items under a label.
         * @param organization The name of the Azure DevOps organization.
         * @param labelId Unique identifier of label
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Top Max number of items to return
         * @param $Skip Number of items to skip
         */
        public getLabelItems (params: {  organization: string; labelId: string; apiVersion: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcItem>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/labels/{labelId}/items'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'labelId' + '}', String(params.labelId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLabelItems');
            }
            // verify required parameter 'labelId' is set
            if (params.labelId == null) {
                throw new Error('Missing required parameter labelId when calling getLabelItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLabelItems');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a collection of shallow label references.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param requestDataIncludeLinks Whether to include the _links field on the shallow references
         * @param requestDataMaxItemCount labelScope, name, owner, and itemLabelFilter
         * @param requestDataItemLabelFilter labelScope, name, owner, and itemLabelFilter
         * @param requestDataOwner labelScope, name, owner, and itemLabelFilter
         * @param requestDataName labelScope, name, owner, and itemLabelFilter
         * @param requestDataLabelScope labelScope, name, owner, and itemLabelFilter
         * @param $Top Max number of labels to return
         * @param $Skip Number of labels to skip
         */
        public getLabels (params: {  organization: string; project: string; apiVersion: string; requestDataIncludeLinks?: boolean; requestDataMaxItemCount?: number; requestDataItemLabelFilter?: string; requestDataOwner?: string; requestDataName?: string; requestDataLabelScope?: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcLabelRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/tfvc/labels'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLabels');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getLabels');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLabels');
            }
            if (params.requestDataIncludeLinks !== undefined) {
                queryParameters['requestData.includeLinks'] = params.requestDataIncludeLinks;
            }

            if (params.requestDataMaxItemCount !== undefined) {
                queryParameters['requestData.maxItemCount'] = params.requestDataMaxItemCount;
            }

            if (params.requestDataItemLabelFilter !== undefined) {
                queryParameters['requestData.itemLabelFilter'] = params.requestDataItemLabelFilter;
            }

            if (params.requestDataOwner !== undefined) {
                queryParameters['requestData.owner'] = params.requestDataOwner;
            }

            if (params.requestDataName !== undefined) {
                queryParameters['requestData.name'] = params.requestDataName;
            }

            if (params.requestDataLabelScope !== undefined) {
                queryParameters['requestData.labelScope'] = params.requestDataLabelScope;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LatestApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the latest build for a definition, optionally scoped to a specific branch.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definition definition name with optional leading folder path, or the definition id
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param branchName optional parameter that indicates the specific branch to use
         */
        public getLatestBuild (params: {  organization: string; project: string; definition: string; apiVersion: string; branchName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Build> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/latest/{definition}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definition' + '}', String(params.definition));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLatestBuild');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getLatestBuild');
            }
            // verify required parameter 'definition' is set
            if (params.definition == null) {
                throw new Error('Missing required parameter definition when calling getLatestBuild');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLatestBuild');
            }
            if (params.branchName !== undefined) {
                queryParameters['branchName'] = params.branchName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class LayoutApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the form layout
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFormLayout (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FormLayout> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFormLayout');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getFormLayout');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getFormLayout');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFormLayout');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the form layout.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFormLayout_1 (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FormLayout> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFormLayout_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getFormLayout_1');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getFormLayout_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFormLayout_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ListsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createList (params: {  organization: string; body: PickListModel; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickListModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/lists'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createList');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createList');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param body Picklist
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createList_1 (params: {  organization: string; body: PickList; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickList> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/lists'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createList_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createList_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createList_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteList (params: {  organization: string; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteList');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling deleteList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteList');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteList_2 (params: {  organization: string; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteList_2');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling deleteList_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteList_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getList (params: {  organization: string; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickListModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getList');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling getList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getList');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getList_3 (params: {  organization: string; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickList> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getList_3');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling getList_3');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getList_3');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns meta data of the picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getListsMetadata (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PickListMetadataModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/lists'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getListsMetadata');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getListsMetadata');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns meta data of the picklist.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getListsMetadata_4 (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PickListMetadata>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/lists'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getListsMetadata_4');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getListsMetadata_4');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a list.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateList (params: {  organization: string; body: PickListModel; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickListModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateList');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateList');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling updateList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateList');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a list.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param listId The ID of the list
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateList_5 (params: {  organization: string; body: PickList; listId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PickList> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/lists/{listId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'listId' + '}', String(params.listId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateList_5');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateList_5');
            }
            // verify required parameter 'listId' is set
            if (params.listId == null) {
                throw new Error('Missing required parameter listId when calling updateList_5');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateList_5');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ManualInterventionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get manual intervention for a given release and manual intervention id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param manualInterventionId Id of the manual intervention.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getManualIntervention (params: {  organization: string; project: string; releaseId: number; manualInterventionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ManualIntervention> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'manualInterventionId' + '}', String(params.manualInterventionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getManualIntervention');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getManualIntervention');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getManualIntervention');
            }
            // verify required parameter 'manualInterventionId' is set
            if (params.manualInterventionId == null) {
                throw new Error('Missing required parameter manualInterventionId when calling getManualIntervention');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getManualIntervention');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * List all manual interventions for a given release.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getManualInterventions (params: {  organization: string; project: string; releaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ManualIntervention>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getManualInterventions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getManualInterventions');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getManualInterventions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getManualInterventions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update manual intervention.
         * @param organization The name of the Azure DevOps organization.
         * @param body Meta data to update manual intervention.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param manualInterventionId Id of the manual intervention.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateManualIntervention (params: {  organization: string; body: ManualInterventionUpdateMetadata; project: string; releaseId: number; manualInterventionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ManualIntervention> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/releases/{releaseId}/manualinterventions/{manualInterventionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'manualInterventionId' + '}', String(params.manualInterventionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateManualIntervention');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateManualIntervention');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateManualIntervention');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling updateManualIntervention');
            }
            // verify required parameter 'manualInterventionId' is set
            if (params.manualInterventionId == null) {
                throw new Error('Missing required parameter manualInterventionId when calling updateManualIntervention');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateManualIntervention');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MavenApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Permanently delete a package from a feed&#39;s recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feed Name or ID of the feed.
         * @param groupId Group ID of the package.
         * @param artifactId Artifact ID of the package.
         * @param version Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersionFromRecycleBin (params: {  organization: string; feed: string; groupId: string; artifactId: string; version: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feed}/maven/RecycleBin/groups/{groupId}/artifacts/{artifactId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feed' + '}', String(params.feed))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'artifactId' + '}', String(params.artifactId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feed' is set
            if (params.feed == null) {
                throw new Error('Missing required parameter feed when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feed Name or ID of the feed.
         * @param groupId Group ID of the package.
         * @param artifactId Artifact ID of the package.
         * @param version Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param showDeleted True to show information for deleted packages.
         */
        public getPackageVersion (params: {  organization: string; feed: string; groupId: string; artifactId: string; version: string; apiVersion: string; showDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feed}/maven/groups/{groupId}/artifacts/{artifactId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feed' + '}', String(params.feed))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'artifactId' + '}', String(params.artifactId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersion');
            }
            // verify required parameter 'feed' is set
            if (params.feed == null) {
                throw new Error('Missing required parameter feed when calling getPackageVersion');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling getPackageVersion');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling getPackageVersion');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling getPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersion');
            }
            if (params.showDeleted !== undefined) {
                queryParameters['showDeleted'] = params.showDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version in the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feed Name or ID of the feed.
         * @param groupId Group ID of the package.
         * @param artifactId Artifact ID of the package.
         * @param version Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionMetadataFromRecycleBin (params: {  organization: string; feed: string; groupId: string; artifactId: string; version: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<MavenPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feed}/maven/RecycleBin/groups/{groupId}/artifacts/{artifactId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feed' + '}', String(params.feed))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'artifactId' + '}', String(params.artifactId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feed' is set
            if (params.feed == null) {
                throw new Error('Missing required parameter feed when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a package version from the feed and move it to the feed&#39;s recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feed Name or ID of the feed.
         * @param groupId Group ID of the package.
         * @param artifactId Artifact ID of the package.
         * @param version Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public packageDelete (params: {  organization: string; feed: string; groupId: string; artifactId: string; version: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feed}/maven/groups/{groupId}/artifacts/{artifactId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feed' + '}', String(params.feed))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'artifactId' + '}', String(params.artifactId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling packageDelete');
            }
            // verify required parameter 'feed' is set
            if (params.feed == null) {
                throw new Error('Missing required parameter feed when calling packageDelete');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling packageDelete');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling packageDelete');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling packageDelete');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling packageDelete');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version from the recycle bin to its associated feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Set the &#39;Deleted&#39; property to false to restore the package.
         * @param feed Name or ID of the feed.
         * @param groupId Group ID of the package.
         * @param artifactId Artifact ID of the package.
         * @param version Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restorePackageVersionFromRecycleBin (params: {  organization: string; body: MavenRecycleBinPackageVersionDetails; feed: string; groupId: string; artifactId: string; version: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feed}/maven/RecycleBin/groups/{groupId}/artifacts/{artifactId}/versions/{version}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feed' + '}', String(params.feed))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'artifactId' + '}', String(params.artifactId))
                .replace('{' + 'version' + '}', String(params.version));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feed' is set
            if (params.feed == null) {
                throw new Error('Missing required parameter feed when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'artifactId' is set
            if (params.artifactId == null) {
                throw new Error('Missing required parameter artifactId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restorePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MembersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a member to a Group.
         * @param organization The name of the Azure DevOps organization.
         * @param groupId Id of the Group.
         * @param memberId Id of the member to add.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addMemberToGroup (params: {  organization: string; groupId: string; memberId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/GroupEntitlements/{groupId}/members/{memberId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'memberId' + '}', String(params.memberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addMemberToGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling addMemberToGroup');
            }
            // verify required parameter 'memberId' is set
            if (params.memberId == null) {
                throw new Error('Missing required parameter memberId when calling addMemberToGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addMemberToGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get direct members of a Group.
         * @param organization The name of the Azure DevOps organization.
         * @param groupId Id of the Group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param maxResults Maximum number of results to retrieve.
         * @param pagingToken Paging Token from the previous page fetched. If the &#39;pagingToken&#39; is null, the results would be fetched from the begining of the Members List.
         */
        public getGroupMembers (params: {  organization: string; groupId: string; apiVersion: string; maxResults?: number; pagingToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PagedGraphMemberList> {
            const localVarPath = this.basePath + '/{organization}/_apis/GroupEntitlements/{groupId}/members'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getGroupMembers');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling getGroupMembers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getGroupMembers');
            }
            if (params.maxResults !== undefined) {
                queryParameters['maxResults'] = params.maxResults;
            }

            if (params.pagingToken !== undefined) {
                queryParameters['pagingToken'] = params.pagingToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Remove a member from a Group.
         * @param organization The name of the Azure DevOps organization.
         * @param groupId Id of the group.
         * @param memberId Id of the member to remove.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeMemberFromGroup (params: {  organization: string; groupId: string; memberId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/GroupEntitlements/{groupId}/members/{memberId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'groupId' + '}', String(params.groupId))
                .replace('{' + 'memberId' + '}', String(params.memberId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeMemberFromGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling removeMemberFromGroup');
            }
            // verify required parameter 'memberId' is set
            if (params.memberId == null) {
                throw new Error('Missing required parameter memberId when calling removeMemberFromGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeMemberFromGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MembershipStatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Check whether a subject is active or inactive.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor Descriptor of the subject (user, group, scope, etc.) to check state of
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getMembershipState (params: {  organization: string; subjectDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphMembershipState> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/membershipstates/{subjectDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getMembershipState');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling getMembershipState');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getMembershipState');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MembershipsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a new membership between a container and subject.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor A descriptor to a group or user that can be the child subject in the relationship.
         * @param containerDescriptor A descriptor to a group that can be the container in the relationship.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addMembership (params: {  organization: string; subjectDescriptor: string; containerDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphMembership> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/memberships/{subjectDescriptor}/{containerDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor))
                .replace('{' + 'containerDescriptor' + '}', String(params.containerDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addMembership');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling addMembership');
            }
            // verify required parameter 'containerDescriptor' is set
            if (params.containerDescriptor == null) {
                throw new Error('Missing required parameter containerDescriptor when calling addMembership');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addMembership');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Check to see if a membership relationship between a container and subject exists.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor The group or user that is a child subject of the relationship.
         * @param containerDescriptor The group that is the container in the relationship.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public checkMembershipExistence (params: {  organization: string; subjectDescriptor: string; containerDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/memberships/{subjectDescriptor}/{containerDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor))
                .replace('{' + 'containerDescriptor' + '}', String(params.containerDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling checkMembershipExistence');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling checkMembershipExistence');
            }
            // verify required parameter 'containerDescriptor' is set
            if (params.containerDescriptor == null) {
                throw new Error('Missing required parameter containerDescriptor when calling checkMembershipExistence');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling checkMembershipExistence');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'HEAD',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a membership relationship between a container and subject.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor A descriptor to the child subject in the relationship.
         * @param containerDescriptor A descriptor to the container in the relationship.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getMembership (params: {  organization: string; subjectDescriptor: string; containerDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphMembership> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/memberships/{subjectDescriptor}/{containerDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor))
                .replace('{' + 'containerDescriptor' + '}', String(params.containerDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getMembership');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling getMembership');
            }
            // verify required parameter 'containerDescriptor' is set
            if (params.containerDescriptor == null) {
                throw new Error('Missing required parameter containerDescriptor when calling getMembership');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getMembership');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all the memberships where this descriptor is a member in the relationship.  The default value for direction is &#39;up&#39; meaning return all memberships where the subject is a member (e.g. all groups the subject is a member of).  Alternatively, passing the direction as &#39;down&#39; will return all memberships where the subject is a container (e.g. all members of the subject group).
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor Fetch all direct memberships of this descriptor.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param direction Defaults to Up.
         * @param depth The maximum number of edges to traverse up or down the membership tree. Currently the only supported value is &#39;1&#39;.
         */
        public listMemberships (params: {  organization: string; subjectDescriptor: string; apiVersion: string; direction?: string; depth?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GraphMembership>> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/Memberships/{subjectDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listMemberships');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling listMemberships');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listMemberships');
            }
            if (params.direction !== undefined) {
                queryParameters['direction'] = params.direction;
            }

            if (params.depth !== undefined) {
                queryParameters['depth'] = params.depth;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a membership between a container and subject.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor A descriptor to a group or user that is the child subject in the relationship.
         * @param containerDescriptor A descriptor to a group that is the container in the relationship.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeMembership (params: {  organization: string; subjectDescriptor: string; containerDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/memberships/{subjectDescriptor}/{containerDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor))
                .replace('{' + 'containerDescriptor' + '}', String(params.containerDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeMembership');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling removeMembership');
            }
            // verify required parameter 'containerDescriptor' is set
            if (params.containerDescriptor == null) {
                throw new Error('Missing required parameter containerDescriptor when calling removeMembership');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeMembership');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MergeBasesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Find the merge bases of two commits, optionally across forks. If otherRepositoryId is not specified, the merge bases will only be calculated within the context of the local repositoryNameOrId.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryNameOrId ID or name of the local repository.
         * @param commitId First commit, usually the tip of the target branch of the potential merge.
         * @param otherCommitId Other commit, usually the tip of the source branch of the potential merge.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param otherCollectionId The collection ID where otherCommitId lives.
         * @param otherRepositoryId The repository ID where otherCommitId lives.
         */
        public getMergeBases (params: {  organization: string; repositoryNameOrId: string; commitId: string; otherCommitId: string; project: string; apiVersion: string; otherCollectionId?: string; otherRepositoryId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitCommitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/commits/{commitId}/mergebases'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'commitId' + '}', String(params.commitId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getMergeBases');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling getMergeBases');
            }
            // verify required parameter 'commitId' is set
            if (params.commitId == null) {
                throw new Error('Missing required parameter commitId when calling getMergeBases');
            }
            // verify required parameter 'otherCommitId' is set
            if (params.otherCommitId == null) {
                throw new Error('Missing required parameter otherCommitId when calling getMergeBases');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getMergeBases');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getMergeBases');
            }
            if (params.otherCommitId !== undefined) {
                queryParameters['otherCommitId'] = params.otherCommitId;
            }

            if (params.otherCollectionId !== undefined) {
                queryParameters['otherCollectionId'] = params.otherCollectionId;
            }

            if (params.otherRepositoryId !== undefined) {
                queryParameters['otherRepositoryId'] = params.otherRepositoryId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MergesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Request a git merge operation. Currently we support merging only 2 commits.
         * @param organization The name of the Azure DevOps organization.
         * @param body Parents commitIds and merge commit messsage.
         * @param project Project ID or project name
         * @param repositoryNameOrId The name or ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks True to include links
         */
        public createMergeRequest (params: {  organization: string; body: GitMergeParameters; project: string; repositoryNameOrId: string; apiVersion: string; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitMerge> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createMergeRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createMergeRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createMergeRequest');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling createMergeRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createMergeRequest');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific merge operation&#39;s details.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryNameOrId The name or ID of the repository.
         * @param mergeOperationId OperationId of the merge request.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks True to include links
         */
        public getMergeRequest (params: {  organization: string; project: string; repositoryNameOrId: string; mergeOperationId: number; apiVersion: string; includeLinks?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitMerge> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryNameOrId}/merges/{mergeOperationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryNameOrId' + '}', String(params.repositoryNameOrId))
                .replace('{' + 'mergeOperationId' + '}', String(params.mergeOperationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getMergeRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getMergeRequest');
            }
            // verify required parameter 'repositoryNameOrId' is set
            if (params.repositoryNameOrId == null) {
                throw new Error('Missing required parameter repositoryNameOrId when calling getMergeRequest');
            }
            // verify required parameter 'mergeOperationId' is set
            if (params.mergeOperationId == null) {
                throw new Error('Missing required parameter mergeOperationId when calling getMergeRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getMergeRequest');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MessagesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testRunId Id of the test run
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestRunMessages (params: {  organization: string; testRunId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestRunMessage>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testRuns/{testRunId}/messages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunMessages');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getTestRunMessages');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunMessages');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class MetricsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets build metrics for a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param minMetricsTime The date from which to calculate metrics.
         */
        public getDefinitionMetrics (params: {  organization: string; project: string; definitionId: number; apiVersion: string; minMetricsTime?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildMetric>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/metrics'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionMetrics');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionMetrics');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionMetrics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionMetrics');
            }
            if (params.minMetricsTime !== undefined) {
                queryParameters['minMetricsTime'] = params.minMetricsTime;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets build metrics for a project.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param metricAggregationType The aggregation type to use (hourly, daily).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param minMetricsTime The date from which to calculate metrics.
         */
        public getProjectMetrics (params: {  organization: string; project: string; metricAggregationType: string; apiVersion: string; minMetricsTime?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildMetric>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/metrics/{metricAggregationType}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'metricAggregationType' + '}', String(params.metricAggregationType));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProjectMetrics');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getProjectMetrics');
            }
            // verify required parameter 'metricAggregationType' is set
            if (params.metricAggregationType == null) {
                throw new Error('Missing required parameter metricAggregationType when calling getProjectMetrics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProjectMetrics');
            }
            if (params.minMetricsTime !== undefined) {
                queryParameters['minMetricsTime'] = params.minMetricsTime;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class NotificationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Sends a test notification. This is useful for verifying the configuration of an updated or new service hooks subscription.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param useRealData Only allow testing with real data in existing subscriptions.
         */
        public createTestNotification (params: {  organization: string; body: Notification; apiVersion: string; useRealData?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Notification> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/testnotifications'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestNotification');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestNotification');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestNotification');
            }
            if (params.useRealData !== undefined) {
                queryParameters['useRealData'] = params.useRealData;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific notification for a subscription.
         * @param organization The name of the Azure DevOps organization.
         * @param subscriptionId ID for a subscription.
         * @param notificationId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getNotification (params: {  organization: string; subscriptionId: string; notificationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Notification> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}/notifications/{notificationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'notificationId' + '}', String(params.notificationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getNotification');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getNotification');
            }
            // verify required parameter 'notificationId' is set
            if (params.notificationId == null) {
                throw new Error('Missing required parameter notificationId when calling getNotification');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getNotification');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of notifications for a specific subscription. A notification includes details about the event, the request to and the response from the consumer service.
         * @param organization The name of the Azure DevOps organization.
         * @param subscriptionId ID for a subscription.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param maxResults Maximum number of notifications to return. Default is **100**.
         * @param status Get only notifications with this status.
         * @param result Get only notifications with this result type.
         */
        public getNotifications (params: {  organization: string; subscriptionId: string; apiVersion: string; maxResults?: number; status?: string; result?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Notification>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}/notifications'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getNotifications');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getNotifications');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getNotifications');
            }
            if (params.maxResults !== undefined) {
                queryParameters['maxResults'] = params.maxResults;
            }

            if (params.status !== undefined) {
                queryParameters['status'] = params.status;
            }

            if (params.result !== undefined) {
                queryParameters['result'] = params.result;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query for notifications. A notification includes details about the event, the request to and the response from the consumer service.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryNotifications (params: {  organization: string; body: NotificationsQuery; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationsQuery> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/notificationsquery'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryNotifications');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryNotifications');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryNotifications');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class NpmApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a package version without an npm scope from the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersionFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a package version with an npm scope from the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope/name).
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope/name).
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteScopedPackageVersionFromRecycleBin (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deleteScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling deleteScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling deleteScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deleteScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteScopedPackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param feedId 
         * @param packageScope 
         * @param unscopedPackageName 
         * @param packageVersion 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getContentScopedPackageAsync (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}/content'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getContentScopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getContentScopedPackageAsync');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling getContentScopedPackageAsync');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling getContentScopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getContentScopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getContentScopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get an unscoped npm package.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getContentUnscopedPackageAsync (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/{packageName}/versions/{packageVersion}/content'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getContentUnscopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getContentUnscopedPackageAsync');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getContentUnscopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getContentUnscopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getContentUnscopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about an unscoped package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageInfoAsync (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageInfoAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageInfoAsync');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageInfoAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageInfoAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageInfoAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about an unscoped package version in the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionMetadataFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NpmPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the Readme for a package version with an npm scope.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope\name)
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope\name)
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getReadmeScopedPackageAsync (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}/readme'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReadmeScopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getReadmeScopedPackageAsync');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling getReadmeScopedPackageAsync');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling getReadmeScopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getReadmeScopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReadmeScopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the Readme for a package version that has no npm scope.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getReadmeUnscopedPackageAsync (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/packages/{packageName}/versions/{packageVersion}/readme'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReadmeUnscopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getReadmeUnscopedPackageAsync');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getReadmeUnscopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getReadmeUnscopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReadmeUnscopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a scoped package version (such as @scope/name).
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope/name).
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope/name).
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getScopedPackageInfoAsync (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getScopedPackageInfoAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getScopedPackageInfoAsync');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling getScopedPackageInfoAsync');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling getScopedPackageInfoAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getScopedPackageInfoAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getScopedPackageInfoAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a scoped package version in the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope/name)
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope/name).
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getScopedPackageVersionMetadataFromRecycleBin (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NpmPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getScopedPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version without an npm scope from the recycle bin to its feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restorePackageVersionFromRecycleBin (params: {  organization: string; body: NpmRecycleBinPackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restorePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version with an npm scope from the recycle bin to its feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope/name).
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope/name).
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restoreScopedPackageVersionFromRecycleBin (params: {  organization: string; body: NpmRecycleBinPackageVersionDetails; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/RecycleBin/packages/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling restoreScopedPackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restoreScopedPackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Unpublish an unscoped package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public unpublishPackageAsync (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling unpublishPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling unpublishPackageAsync');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling unpublishPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling unpublishPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling unpublishPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Unpublish a scoped package version (such as @scope/name).
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageScope Scope of the package (the &#39;scope&#39; part of @scope/name).
         * @param unscopedPackageName Name of the package (the &#39;name&#39; part of @scope/name).
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public unpublishScopedPackageAsync (params: {  organization: string; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling unpublishScopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling unpublishScopedPackageAsync');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling unpublishScopedPackageAsync');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling unpublishScopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling unpublishScopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling unpublishScopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId 
         * @param packageName 
         * @param packageVersion 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackageAsync (params: {  organization: string; body: PackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackageAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackageAsync');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling updatePackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling updatePackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update several packages from a single feed in a single request. The updates to the packages do not happen atomically.
         * @param organization The name of the Azure DevOps organization.
         * @param body Information about the packages to update, the operation to perform, and its associated data.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackagesAsync (params: {  organization: string; body: NpmPackagesBatchRequest; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/packagesbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackagesAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackagesAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackagesAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackagesAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId 
         * @param packageScope 
         * @param unscopedPackageName 
         * @param packageVersion 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateScopedPackageAsync (params: {  organization: string; body: PackageVersionDetails; feedId: string; packageScope: string; unscopedPackageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/npm/@{packageScope}/{unscopedPackageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageScope' + '}', String(params.packageScope))
                .replace('{' + 'unscopedPackageName' + '}', String(params.unscopedPackageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateScopedPackageAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateScopedPackageAsync');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updateScopedPackageAsync');
            }
            // verify required parameter 'packageScope' is set
            if (params.packageScope == null) {
                throw new Error('Missing required parameter packageScope when calling updateScopedPackageAsync');
            }
            // verify required parameter 'unscopedPackageName' is set
            if (params.unscopedPackageName == null) {
                throw new Error('Missing required parameter unscopedPackageName when calling updateScopedPackageAsync');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling updateScopedPackageAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateScopedPackageAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class NuGetApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Send a package version from the feed to its paired recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package to delete.
         * @param packageVersion Version of the package to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a package version from a feed&#39;s recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersionFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Download a package version directly.  This API is intended for manual UI download options, not for programmatic access and scripting.  You may be heavily throttled if accessing this api for scripting purposes.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param sourceProtocolVersion Unused
         */
        public downloadPackage (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; sourceProtocolVersion?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/packages/{packageName}/versions/{packageVersion}/content'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling downloadPackage');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling downloadPackage');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling downloadPackage');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling downloadPackage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling downloadPackage');
            }
            if (params.sourceProtocolVersion !== undefined) {
                queryParameters['sourceProtocolVersion'] = params.sourceProtocolVersion;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param showDeleted True to include deleted packages in the response.
         */
        public getPackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; showDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersion');
            }
            if (params.showDeleted !== undefined) {
                queryParameters['showDeleted'] = params.showDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * View a package version&#39;s deletion/recycled status
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionMetadataFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NuGetPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version from a feed&#39;s recycle bin back into the active feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Set the &#39;Deleted&#39; member to &#39;false&#39; to apply the restore operation
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restorePackageVersionFromRecycleBin (params: {  organization: string; body: NuGetRecycleBinPackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restorePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Set mutable state on a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param body New state to apply to the referenced package.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package to update.
         * @param packageVersion Version of the package to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackageVersion (params: {  organization: string; body: PackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackageVersion');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling updatePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling updatePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update several packages from a single feed in a single request. The updates to the packages do not happen atomically.
         * @param organization The name of the Azure DevOps organization.
         * @param body Information about the packages to update, the operation to perform, and its associated data.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackageVersions (params: {  organization: string; body: NuGetPackagesBatchRequest; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/nuget/packagesbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackageVersions');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackageVersions');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackageVersions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackageVersions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OperationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets an operation from the the operationId using the given pluginId.  Some scenarios don’t require a pluginId. If a pluginId is not included in the call then just the operationId will be used to find an operation.
         * @param operationId The ID for the operation.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param pluginId The ID for the plugin.
         */
        public getOperation (params: {  operationId: string; organization: string; apiVersion: string; pluginId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Operation> {
            const localVarPath = this.basePath + '/{organization}/_apis/operations/{operationId}'
                .replace('{' + 'operationId' + '}', String(params.operationId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'operationId' is set
            if (params.operationId == null) {
                throw new Error('Missing required parameter operationId when calling getOperation');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getOperation');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getOperation');
            }
            if (params.pluginId !== undefined) {
                queryParameters['pluginId'] = params.pluginId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class OptionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets all build definition options supported by the system.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getBuildOptionDefinitions (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildOptionDefinition>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/options'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildOptionDefinitions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildOptionDefinitions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildOptionDefinitions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PageMovesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a page move operation that updates the path and order of the page as provided in the parameters.
         * @param organization The name of the Azure DevOps organization.
         * @param body Page more operation parameters.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comment that is to be associated with this page move.
         */
        public createPageMove (params: {  organization: string; body: WikiPageMoveParameters; project: string; wikiIdentifier: string; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPageMove> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pagemoves'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPageMove');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPageMove');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPageMove');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling createPageMove');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPageMove');
            }
            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PagesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a page to the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The page
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addPage (params: {  organization: string; body: Page; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Page> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addPage');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addPage');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addPage');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addPage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addPage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Adds a page to the work item form.
         * @param organization The name of the Azure DevOps organization.
         * @param body The page.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addPage_1 (params: {  organization: string; body: Page; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Page> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addPage_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addPage_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addPage_1');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addPage_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addPage_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates or edits a wiki page.
         * @param organization The name of the Azure DevOps organization.
         * @param body Wiki create or update operation parameters.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param path Wiki page path.
         * @param version Version of the page on which the change is to be made. Mandatory for &#x60;Edit&#x60; scenario. To be populated in the If-Match header of the request.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comment to be associated with the page operation.
         */
        public createOrUpdatePage (params: {  organization: string; body: WikiPageCreateOrUpdateParameters; project: string; wikiIdentifier: string; path: string; version: string; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createOrUpdatePage');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createOrUpdatePage');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createOrUpdatePage');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling createOrUpdatePage');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling createOrUpdatePage');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling createOrUpdatePage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createOrUpdatePage');
            }
            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['Version'] = params.version;

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a wiki page.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param path Wiki page path.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comment to be associated with this page delete.
         */
        public deletePage (params: {  organization: string; project: string; wikiIdentifier: string; path: string; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePage');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePage');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling deletePage');
            }
            // verify required parameter 'path' is set
            if (params.path == null) {
                throw new Error('Missing required parameter path when calling deletePage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePage');
            }
            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a wiki page.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param id Wiki page id.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comment to be associated with this page delete.
         */
        public deletePageById (params: {  organization: string; project: string; wikiIdentifier: string; id: number; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePageById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePageById');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling deletePageById');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling deletePageById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePageById');
            }
            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a page on the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The page
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public editPage (params: {  organization: string; body: Page; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Page> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling editPage');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling editPage');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling editPage');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling editPage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling editPage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets metadata or content of the wiki page for the provided path. Content negotiation is done based on the &#x60;Accept&#x60; header sent in the request.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param path Wiki page path.
         * @param recursionLevel Recursion level for subpages retrieval. Defaults to &#x60;None&#x60; (Optional).
         * @param versionDescriptorVersionOptions Version options - Specify additional modifiers to version (e.g Previous)
         * @param versionDescriptorVersion Version string identifier (name of tag/branch, SHA1 of commit)
         * @param versionDescriptorVersionType Version type (branch, tag, or commit). Determines how Id is interpreted
         * @param includeContent True to include the content of the page in the response for Json content type. Defaults to false (Optional)
         */
        public getPage (params: {  organization: string; project: string; wikiIdentifier: string; apiVersion: string; path?: string; recursionLevel?: string; versionDescriptorVersionOptions?: string; versionDescriptorVersion?: string; versionDescriptorVersionType?: string; includeContent?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPage');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPage');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling getPage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPage');
            }
            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.recursionLevel !== undefined) {
                queryParameters['recursionLevel'] = params.recursionLevel;
            }

            if (params.versionDescriptorVersionOptions !== undefined) {
                queryParameters['versionDescriptor.versionOptions'] = params.versionDescriptorVersionOptions;
            }

            if (params.versionDescriptorVersion !== undefined) {
                queryParameters['versionDescriptor.version'] = params.versionDescriptorVersion;
            }

            if (params.versionDescriptorVersionType !== undefined) {
                queryParameters['versionDescriptor.versionType'] = params.versionDescriptorVersionType;
            }

            if (params.includeContent !== undefined) {
                queryParameters['includeContent'] = params.includeContent;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets metadata or content of the wiki page for the provided page id. Content negotiation is done based on the &#x60;Accept&#x60; header sent in the request.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param id Wiki page id.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param recursionLevel Recursion level for subpages retrieval. Defaults to &#x60;None&#x60; (Optional).
         * @param includeContent True to include the content of the page in the response for Json content type. Defaults to false (Optional)
         */
        public getPageById (params: {  organization: string; project: string; wikiIdentifier: string; id: number; apiVersion: string; recursionLevel?: string; includeContent?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPageById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPageById');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling getPageById');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getPageById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPageById');
            }
            if (params.recursionLevel !== undefined) {
                queryParameters['recursionLevel'] = params.recursionLevel;
            }

            if (params.includeContent !== undefined) {
                queryParameters['includeContent'] = params.includeContent;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a page from the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removePage (params: {  organization: string; processId: string; witRefName: string; pageId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removePage');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removePage');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removePage');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling removePage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removePage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a page from the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param pageId The ID of the page
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removePage_2 (params: {  organization: string; processId: string; witRefName: string; pageId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages/{pageId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'pageId' + '}', String(params.pageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removePage_2');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removePage_2');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling removePage_2');
            }
            // verify required parameter 'pageId' is set
            if (params.pageId == null) {
                throw new Error('Missing required parameter pageId when calling removePage_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removePage_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a page on the work item form
         * @param organization The name of the Azure DevOps organization.
         * @param body The page
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePage (params: {  organization: string; body: Page; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Page> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/layout/pages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePage');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePage');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updatePage');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updatePage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Edits a wiki page.
         * @param organization The name of the Azure DevOps organization.
         * @param body Wiki update operation parameters.
         * @param project Project ID or project name
         * @param wikiIdentifier Wiki Id or name.
         * @param id Wiki page id.
         * @param version Version of the page on which the change is to be made. Mandatory for &#x60;Edit&#x60; scenario. To be populated in the If-Match header of the request.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comment to be associated with the page operation.
         */
        public updatePageById (params: {  organization: string; body: WikiPageCreateOrUpdateParameters; project: string; wikiIdentifier: string; id: number; version: string; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiPage> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}/pages/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePageById');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePageById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePageById');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling updatePageById');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling updatePageById');
            }
            // verify required parameter 'version' is set
            if (params.version == null) {
                throw new Error('Missing required parameter version when calling updatePageById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePageById');
            }
            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['Version'] = params.version;

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ParameterResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a list of parameterized results
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the test run that contains the result.
         * @param testCaseResultId ID of the test result that contains the iterations.
         * @param iterationId ID of the iteration that contains the parameterized results.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param paramName Name of the parameter.
         */
        public getResultParameters (params: {  organization: string; project: string; runId: number; testCaseResultId: number; iterationId: number; apiVersion: string; paramName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestResultParameterModel>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/Results/{testCaseResultId}/Iterations/{iterationId}/parameterresults'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getResultParameters');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getResultParameters');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getResultParameters');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getResultParameters');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getResultParameters');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getResultParameters');
            }
            if (params.paramName !== undefined) {
                queryParameters['paramName'] = params.paramName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PermissionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Evaluates whether the caller has the specified permissions on the specified set of security tokens.
         * @param securityNamespaceId Security namespace identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param permissions Permissions to evaluate.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param tokens One or more security tokens to evaluate.
         * @param alwaysAllowAdministrators If true and if the caller is an administrator, always return true.
         * @param delimiter Optional security token separator. Defaults to &quot;,&quot;.
         */
        public hasPermissions (params: {  securityNamespaceId: string; organization: string; permissions: number; apiVersion: string; tokens?: string; alwaysAllowAdministrators?: boolean; delimiter?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<boolean>> {
            const localVarPath = this.basePath + '/{organization}/_apis/permissions/{securityNamespaceId}/{permissions}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'permissions' + '}', String(params.permissions));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling hasPermissions');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling hasPermissions');
            }
            // verify required parameter 'permissions' is set
            if (params.permissions == null) {
                throw new Error('Missing required parameter permissions when calling hasPermissions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling hasPermissions');
            }
            if (params.tokens !== undefined) {
                queryParameters['tokens'] = params.tokens;
            }

            if (params.alwaysAllowAdministrators !== undefined) {
                queryParameters['alwaysAllowAdministrators'] = params.alwaysAllowAdministrators;
            }

            if (params.delimiter !== undefined) {
                queryParameters['delimiter'] = params.delimiter;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Evaluates multiple permissions for the calling user.  Note: This method does not aggregate the results, nor does it short-circuit if one of the permissions evaluates to false.
         * @param body The set of evaluation requests.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public hasPermissionsBatch (params: {  body: PermissionEvaluationBatch; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PermissionEvaluationBatch> {
            const localVarPath = this.basePath + '/{organization}/_apis/security/permissionevaluationbatch'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling hasPermissionsBatch');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling hasPermissionsBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling hasPermissionsBatch');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes the specified permissions on a security token for a user or group.
         * @param securityNamespaceId Security namespace identifier.
         * @param descriptor Identity descriptor of the user to remove permissions for.
         * @param organization The name of the Azure DevOps organization.
         * @param permissions Permissions to remove.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param token Security token to remove permissions for.
         */
        public removePermission (params: {  securityNamespaceId: string; descriptor: string; organization: string; permissions: number; apiVersion: string; token?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<AccessControlEntry> {
            const localVarPath = this.basePath + '/{organization}/_apis/permissions/{securityNamespaceId}/{permissions}'
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId))
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'permissions' + '}', String(params.permissions));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling removePermission');
            }
            // verify required parameter 'descriptor' is set
            if (params.descriptor == null) {
                throw new Error('Missing required parameter descriptor when calling removePermission');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removePermission');
            }
            // verify required parameter 'permissions' is set
            if (params.permissions == null) {
                throw new Error('Missing required parameter permissions when calling removePermission');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removePermission');
            }
            if (params.descriptor !== undefined) {
                queryParameters['descriptor'] = params.descriptor;
            }

            if (params.token !== undefined) {
                queryParameters['token'] = params.token;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PersonalAccessTokensApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Lists of all the session token details of the personal access tokens (PATs) for a particular user.
         * @param organization The name of the Azure DevOps organization.
         * @param subjectDescriptor The descriptor of the target user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param pageSize The maximum number of results to return on each page.
         * @param continuationToken An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
         * @param isPublic Set to false for PAT tokens and true for SSH tokens.
         */
        public listPersonalAccessTokens (params: {  organization: string; subjectDescriptor: string; apiVersion: string; pageSize?: number; continuationToken?: string; isPublic?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TokenAdminPagedSessionTokens> {
            const localVarPath = this.basePath + '/{organization}/_apis/tokenadmin/personalaccesstokens/{subjectDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listPersonalAccessTokens');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling listPersonalAccessTokens');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listPersonalAccessTokens');
            }
            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.isPublic !== undefined) {
                queryParameters['isPublic'] = params.isPublic;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PlansApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a new plan for the team
         * @param organization The name of the Azure DevOps organization.
         * @param body Plan definition
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPlan (params: {  organization: string; body: CreatePlan; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Plan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPlan');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete the specified plan
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id Identifier of the plan
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePlan (params: {  organization: string; project: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePlan');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling deletePlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the information for the specified plan
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param id Identifier of the plan
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPlan (params: {  organization: string; project: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Plan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPlan');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the information for all the plans configured for the given team
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPlans (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Plan>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPlans');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPlans');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPlans');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the information for the specified plan
         * @param organization The name of the Azure DevOps organization.
         * @param body Plan definition to be updated
         * @param project Project ID or project name
         * @param id Identifier of the plan
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePlan (params: {  organization: string; body: UpdatePlan; project: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Plan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/plans/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePlan');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePlan');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling updatePlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PluginsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param type Currently ApplicationInsights is the only available plugin type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPlugin (params: {  organization: string; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ApplicationType> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/apm/plugins/{type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPlugin');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getPlugin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPlugin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPlugins (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ApplicationType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/apm/plugins'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPlugins');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPlugins');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PointsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a test point.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan.
         * @param suiteId ID of the suite that contains the point.
         * @param pointIds ID of the test point to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param witFields Comma-separated list of work item field names.
         */
        public getPoint (params: {  organization: string; project: string; planId: number; suiteId: number; pointIds: number; apiVersion: string; witFields?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestPoint> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/Suites/{suiteId}/points/{pointIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'pointIds' + '}', String(params.pointIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPoint');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPoint');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getPoint');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getPoint');
            }
            // verify required parameter 'pointIds' is set
            if (params.pointIds == null) {
                throw new Error('Missing required parameter pointIds when calling getPoint');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPoint');
            }
            if (params.witFields !== undefined) {
                queryParameters['witFields'] = params.witFields;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test points.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan.
         * @param suiteId ID of the suite that contains the points.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param witFields Comma-separated list of work item field names.
         * @param configurationId Get test points for specific configuration.
         * @param testCaseId Get test points for a specific test case, valid when configurationId is not set.
         * @param testPointIds Get test points for comma-separated list of test point IDs, valid only when configurationId and testCaseId are not set.
         * @param includePointDetails Include all properties for the test point.
         * @param $Skip Number of test points to skip..
         * @param $Top Number of test points to return.
         */
        public getPoints (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; witFields?: string; configurationId?: string; testCaseId?: string; testPointIds?: string; includePointDetails?: boolean; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/Suites/{suiteId}/points'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPoints');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPoints');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getPoints');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getPoints');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPoints');
            }
            if (params.witFields !== undefined) {
                queryParameters['witFields'] = params.witFields;
            }

            if (params.configurationId !== undefined) {
                queryParameters['configurationId'] = params.configurationId;
            }

            if (params.testCaseId !== undefined) {
                queryParameters['testCaseId'] = params.testCaseId;
            }

            if (params.testPointIds !== undefined) {
                queryParameters['testPointIds'] = params.testPointIds;
            }

            if (params.includePointDetails !== undefined) {
                queryParameters['includePointDetails'] = params.includePointDetails;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get test points using query.
         * @param organization The name of the Azure DevOps organization.
         * @param body TestPointsQuery to get test points.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Skip Number of test points to skip..
         * @param $Top Number of test points to return.
         */
        public getPointsByQuery (params: {  organization: string; body: TestPointsQuery; project: string; apiVersion: string; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestPointsQuery> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/points'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPointsByQuery');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getPointsByQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPointsByQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPointsByQuery');
            }
            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update test points.
         * @param organization The name of the Azure DevOps organization.
         * @param body Data to update.
         * @param project Project ID or project name
         * @param planId ID of the test plan.
         * @param suiteId ID of the suite that contains the points.
         * @param pointIds ID of the test point to get. Use a comma-separated list of IDs to update multiple test points.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateTestPoints (params: {  organization: string; body: PointUpdateModel; project: string; planId: number; suiteId: number; pointIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/Suites/{suiteId}/points/{pointIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'pointIds' + '}', String(params.pointIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestPoints');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestPoints');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestPoints');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateTestPoints');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling updateTestPoints');
            }
            // verify required parameter 'pointIds' is set
            if (params.pointIds == null) {
                throw new Error('Missing required parameter pointIds when calling updateTestPoints');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestPoints');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PolicyConfigurationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve a list of policy configurations by a given set of scope/filtering criteria.  Below is a short description of how all of the query parameters interact with each other: - repositoryId set, refName set: returns all policy configurations that *apply* to a particular branch in a repository - repositoryId set, refName unset: returns all policy configurations that *apply* to a particular repository - repositoryId unset, refName unset: returns all policy configurations that are *defined* at the project level - repositoryId unset, refName set: returns all project-level branch policies, plus the project level configurations For all of the examples above, when policyType is set, it&#39;ll restrict results to the given policy type
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param repositoryId The repository id.
         * @param refName The fully-qualified Git ref name (e.g. refs/heads/master).
         * @param policyType The policy type filter.
         * @param $Top Maximum number of policies to return.
         * @param continuationToken Pass a policy configuration ID to fetch the next page of results, up to top number of results, for this endpoint.
         */
        public getPolicyConfigurations (params: {  organization: string; project: string; apiVersion: string; repositoryId?: string; refName?: string; policyType?: string; $Top?: number; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PolicyConfiguration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/policy/configurations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyConfigurations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyConfigurations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyConfigurations');
            }
            if (params.repositoryId !== undefined) {
                queryParameters['repositoryId'] = params.repositoryId;
            }

            if (params.refName !== undefined) {
                queryParameters['refName'] = params.refName;
            }

            if (params.policyType !== undefined) {
                queryParameters['policyType'] = params.policyType;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProcessconfigurationApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get process configuration
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getProcessConfiguration (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/work/processconfiguration'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessConfiguration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getProcessConfiguration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessConfiguration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProcessesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Returns requested process template.
         * @param organization The name of the Azure DevOps organization.
         * @param id The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public _export (params: {  organization: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processadmin/processes/export/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling _export');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling _export');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling _export');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Imports a process from zip file.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param ignoreWarnings Default value is false
         */
        public _import (params: {  organization: string; body: string; apiVersion: string; ignoreWarnings?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessImportResult> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processadmin/processes/import'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling _import');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling _import');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling _import');
            }
            if (params.ignoreWarnings !== undefined) {
                queryParameters['ignoreWarnings'] = params.ignoreWarnings;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Check if process template exists.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public checkTemplateExistence (params: {  organization: string; body: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CheckTemplateExistenceResult> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processadmin/processes/checktemplateexistence'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling checkTemplateExistence');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling checkTemplateExistence');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling checkTemplateExistence');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a process.
         * @param organization The name of the Azure DevOps organization.
         * @param body CreateProcessModel.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createNewProcess (params: {  organization: string; body: CreateProcessModel; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessInfo> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createNewProcess');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createNewProcess');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createNewProcess');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a process of a specific ID.
         * @param organization The name of the Azure DevOps organization.
         * @param processTypeId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteProcessById (params: {  organization: string; processTypeId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processTypeId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processTypeId' + '}', String(params.processTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteProcessById');
            }
            // verify required parameter 'processTypeId' is set
            if (params.processTypeId == null) {
                throw new Error('Missing required parameter processTypeId when calling deleteProcessById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteProcessById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Edit a process of a specific ID.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processTypeId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public editProcess (params: {  organization: string; body: UpdateProcessModel; processTypeId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessInfo> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processTypeId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processTypeId' + '}', String(params.processTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling editProcess');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling editProcess');
            }
            // verify required parameter 'processTypeId' is set
            if (params.processTypeId == null) {
                throw new Error('Missing required parameter processTypeId when calling editProcess');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling editProcess');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get list of all processes including system and inherited.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand 
         */
        public getListOfProcesses (params: {  organization: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProcessInfo>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getListOfProcesses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getListOfProcesses');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a process by ID.
         * @param organization The name of the Azure DevOps organization.
         * @param processId ID for a process.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getProcessById (params: {  organization: string; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Process> {
            const localVarPath = this.basePath + '/{organization}/_apis/process/processes/{processId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessById');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a single process of a specified ID.
         * @param organization The name of the Azure DevOps organization.
         * @param processTypeId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand 
         */
        public getProcessByItsId (params: {  organization: string; processTypeId: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessInfo> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processTypeId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processTypeId' + '}', String(params.processTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessByItsId');
            }
            // verify required parameter 'processTypeId' is set
            if (params.processTypeId == null) {
                throw new Error('Missing required parameter processTypeId when calling getProcessByItsId');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessByItsId');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of processes.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getProcesses (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Process>> {
            const localVarPath = this.basePath + '/{organization}/_apis/process/processes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcesses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcesses');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Tells whether promote has completed for the specified promote job ID.
         * @param organization The name of the Azure DevOps organization.
         * @param id The ID of the promote job operation
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public status (params: {  organization: string; id: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessPromoteStatus> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processadmin/processes/status/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling status');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling status');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling status');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProfilesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets a user profile.
         * @param id The ID of the target user profile within the same organization, or &#39;me&#39; to get the profile of the current authenticated user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param details Return public profile information such as display name, email address, country, etc. If false, the withAttributes parameter is ignored.
         * @param withAttributes If true, gets the attributes (named key-value pairs of arbitrary data) associated with the profile. The partition parameter must also have a value.
         * @param partition The partition (named group) of attributes to return.
         * @param coreAttributes A comma-delimited list of core profile attributes to return. Valid values are Email, Avatar, DisplayName, and ContactWithOffers.
         * @param forceRefresh Not used in this version of the API.
         */
        public getProfile (params: {  id: string; apiVersion: string; details?: boolean; withAttributes?: boolean; partition?: string; coreAttributes?: string; forceRefresh?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Profile> {
            const localVarPath = this.basePath + '/_apis/profile/profiles/{id}'
                .replace('{' + 'id' + '}', String(params.id));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getProfile');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProfile');
            }
            if (params.details !== undefined) {
                queryParameters['details'] = params.details;
            }

            if (params.withAttributes !== undefined) {
                queryParameters['withAttributes'] = params.withAttributes;
            }

            if (params.partition !== undefined) {
                queryParameters['partition'] = params.partition;
            }

            if (params.coreAttributes !== undefined) {
                queryParameters['coreAttributes'] = params.coreAttributes;
            }

            if (params.forceRefresh !== undefined) {
                queryParameters['forceRefresh'] = params.forceRefresh;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProjectsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get project with the specified id or name, optionally including capabilities.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.4&#39; to use this version of the api.
         * @param includeCapabilities Include capabilities (such as source control) in the team project result (default: false).
         * @param includeHistory Search within renamed projects (that had such name in the past).
         */
        public getProject (params: {  organization: string; projectId: string; apiVersion: string; includeCapabilities?: boolean; includeHistory?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamProject> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProject');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling getProject');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProject');
            }
            if (params.includeCapabilities !== undefined) {
                queryParameters['includeCapabilities'] = params.includeCapabilities;
            }

            if (params.includeHistory !== undefined) {
                queryParameters['includeHistory'] = params.includeHistory;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a collection of team project properties.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The team project ID.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param keys A comma-delimited string of team project property names. Wildcard characters (&quot;?&quot; and &quot;*&quot;) are supported. If no key is specified, all properties will be returned.
         */
        public getProjectProperties (params: {  organization: string; projectId: string; apiVersion: string; keys?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProjectProperty>> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProjectProperties');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling getProjectProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProjectProperties');
            }
            if (params.keys !== undefined) {
                queryParameters['keys'] = params.keys;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all projects in the organization that the authenticated user has access to.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.4&#39; to use this version of the api.
         * @param stateFilter Filter on team projects in a specific team project state (default: WellFormed).
         * @param $Top 
         * @param $Skip 
         * @param continuationToken 
         * @param getDefaultTeamImageUrl 
         */
        public getProjects (params: {  organization: string; apiVersion: string; stateFilter?: string; $Top?: number; $Skip?: number; continuationToken?: string; getDefaultTeamImageUrl?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TeamProjectReference>> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProjects');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProjects');
            }
            if (params.stateFilter !== undefined) {
                queryParameters['stateFilter'] = params.stateFilter;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.getDefaultTeamImageUrl !== undefined) {
                queryParameters['getDefaultTeamImageUrl'] = params.getDefaultTeamImageUrl;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Queues a project to be created. Use the [GetOperation](../../operations/operations/get) to periodically check for create project status.
         * @param organization The name of the Azure DevOps organization.
         * @param body The project to create.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.4&#39; to use this version of the api.
         */
        public queueCreateProject (params: {  organization: string; body: TeamProject; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<OperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queueCreateProject');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queueCreateProject');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queueCreateProject');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Queues a project to be deleted. Use the [GetOperation](../../operations/operations/get) to periodically check for delete project status.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The project id of the project to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.4&#39; to use this version of the api.
         */
        public queueDeleteProject (params: {  organization: string; projectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<OperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queueDeleteProject');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling queueDeleteProject');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queueDeleteProject');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create, update, and delete team project properties.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The team project ID.
         * @param body A JSON Patch document that represents an array of property operations. See RFC 6902 for more details on JSON Patch. The accepted operation verbs are Add and Remove, where Add is used for both creating and updating properties. The path consists of a forward slash and a property name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setProjectProperties (params: {  organization: string; projectId: string; body: JsonPatchDocument; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setProjectProperties');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling setProjectProperties');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setProjectProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setProjectProperties');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update an existing project&#39;s name, abbreviation, description, or restore a project.
         * @param organization The name of the Azure DevOps organization.
         * @param body The updates for the project. The state must be set to wellFormed to restore the project.
         * @param projectId The project id of the project to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.4&#39; to use this version of the api.
         */
        public updateProject (params: {  organization: string; body: TeamProject; projectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<OperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateProject');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateProject');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling updateProject');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateProject');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PropertiesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets properties for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param filter A comma-delimited list of properties. If specified, filters to these specific properties.
         */
        public getBuildProperties (params: {  organization: string; project: string; buildId: number; apiVersion: string; filter?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildProperties');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildProperties');
            }
            if (params.filter !== undefined) {
                queryParameters['filter'] = params.filter;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets properties for a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param filter A comma-delimited list of properties. If specified, filters to these specific properties.
         */
        public getDefinitionProperties (params: {  organization: string; project: string; definitionId: number; apiVersion: string; filter?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionProperties');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionProperties');
            }
            if (params.filter !== undefined) {
                queryParameters['filter'] = params.filter;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates properties for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param body A json-patch document describing the properties to update.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBuildProperties (params: {  organization: string; body: JsonPatchDocument; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBuildProperties');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBuildProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBuildProperties');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling updateBuildProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBuildProperties');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates properties for a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param body A json-patch document describing the properties to update.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateDefinitionProperties (params: {  organization: string; body: JsonPatchDocument; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateDefinitionProperties');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateDefinitionProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateDefinitionProperties');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling updateDefinitionProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateDefinitionProperties');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProvenanceApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a session, a wrapper around a feed that can store additional metadata on the packages published to it.
         * @param organization The name of the Azure DevOps organization.
         * @param body The feed and metadata for the session
         * @param protocol The protocol that the session will target
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createSession (params: {  organization: string; body: SessionRequest; protocol: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SessionResponse> {
            const localVarPath = this.basePath + '/{organization}/_apis/provenance/session/{protocol}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'protocol' + '}', String(params.protocol));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createSession');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createSession');
            }
            // verify required parameter 'protocol' is set
            if (params.protocol == null) {
                throw new Error('Missing required parameter protocol when calling createSession');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createSession');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ProviderInfoApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param userDescriptor 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getProviderInfo (params: {  userDescriptor: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphProviderInfo> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/Users/{userDescriptor}/providerinfo'
                .replace('{' + 'userDescriptor' + '}', String(params.userDescriptor))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'userDescriptor' is set
            if (params.userDescriptor == null) {
                throw new Error('Missing required parameter userDescriptor when calling getProviderInfo');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProviderInfo');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProviderInfo');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PublishersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a specific event type.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherId ID for a publisher.
         * @param eventTypeId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getEventType (params: {  organization: string; publisherId: string; eventTypeId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<EventTypeDescriptor> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishers/{publisherId}/eventtypes/{eventTypeId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherId' + '}', String(params.publisherId))
                .replace('{' + 'eventTypeId' + '}', String(params.eventTypeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getEventType');
            }
            // verify required parameter 'publisherId' is set
            if (params.publisherId == null) {
                throw new Error('Missing required parameter publisherId when calling getEventType');
            }
            // verify required parameter 'eventTypeId' is set
            if (params.eventTypeId == null) {
                throw new Error('Missing required parameter eventTypeId when calling getEventType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getEventType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific service hooks publisher.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherId ID for a publisher.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPublisher (params: {  organization: string; publisherId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Publisher> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishers/{publisherId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherId' + '}', String(params.publisherId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPublisher');
            }
            // verify required parameter 'publisherId' is set
            if (params.publisherId == null) {
                throw new Error('Missing required parameter publisherId when calling getPublisher');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPublisher');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the event types for a specific publisher.
         * @param organization The name of the Azure DevOps organization.
         * @param publisherId ID for a publisher.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public listEventTypes (params: {  organization: string; publisherId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<EventTypeDescriptor>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishers/{publisherId}/eventtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherId' + '}', String(params.publisherId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listEventTypes');
            }
            // verify required parameter 'publisherId' is set
            if (params.publisherId == null) {
                throw new Error('Missing required parameter publisherId when calling listEventTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listEventTypes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of publishers.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public listPublishers (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Publisher>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishers'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listPublishers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listPublishers');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param publisherId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryInputValues (params: {  organization: string; body: InputValuesQuery; publisherId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<InputValuesQuery> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishers/{publisherId}/inputValuesQuery'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'publisherId' + '}', String(params.publisherId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryInputValues');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryInputValues');
            }
            // verify required parameter 'publisherId' is set
            if (params.publisherId == null) {
                throw new Error('Missing required parameter publisherId when calling queryInputValues');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryInputValues');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query for service hook publishers.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public queryPublishers (params: {  organization: string; body: PublishersQuery; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PublishersQuery> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/publishersquery'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryPublishers');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryPublishers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryPublishers');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestAttachmentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Attach a new file to a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body Stream to upload
         * @param fileName The name of the file.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createAttachment (params: {  organization: string; body: string; fileName: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Attachment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'fileName' + '}', String(params.fileName))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createAttachment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createAttachment');
            }
            // verify required parameter 'fileName' is set
            if (params.fileName == null) {
                throw new Error('Missing required parameter fileName when calling createAttachment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createAttachment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a pull request attachment.
         * @param organization The name of the Azure DevOps organization.
         * @param fileName The name of the attachment to delete.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteAttachment (params: {  organization: string; fileName: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'fileName' + '}', String(params.fileName))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteAttachment');
            }
            // verify required parameter 'fileName' is set
            if (params.fileName == null) {
                throw new Error('Missing required parameter fileName when calling deleteAttachment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deleteAttachment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deleteAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the file content of a pull request attachment.
         * @param organization The name of the Azure DevOps organization.
         * @param fileName The name of the attachment.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAttachment (params: {  organization: string; fileName: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments/{fileName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'fileName' + '}', String(params.fileName))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAttachment');
            }
            // verify required parameter 'fileName' is set
            if (params.fileName == null) {
                throw new Error('Missing required parameter fileName when calling getAttachment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getAttachment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getAttachment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAttachment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAttachment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of files attached to a given pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAttachments (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Attachment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/attachments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAttachments');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getAttachments');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getAttachments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAttachments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAttachments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestCommentLikesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a like on a comment.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId The ID of the thread that contains the comment.
         * @param commentId The ID of the comment.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createLike (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createLike');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createLike');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createLike');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling createLike');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling createLike');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createLike');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createLike');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a like on a comment.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId The ID of the thread that contains the comment.
         * @param commentId The ID of the comment.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteLike (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteLike');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deleteLike');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deleteLike');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling deleteLike');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling deleteLike');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteLike');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteLike');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get likes for a comment.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId The ID of the thread that contains the comment.
         * @param commentId The ID of the comment.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getLikes (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<IdentityRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}/likes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLikes');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getLikes');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getLikes');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling getLikes');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling getLikes');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getLikes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLikes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestCommitsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get the commits for the specified pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID or name of the repository.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestCommits (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitCommitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/commits'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestCommits');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestCommits');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestCommits');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestCommits');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestCommits');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the commits for the specified iteration of a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID or name of the repository.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the iteration from which to get the commits.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param top Maximum number of commits to return. The maximum number of commits that can be returned per batch is 500.
         * @param skip Number of commits to skip.
         */
        public getPullRequestIterationCommits (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; top?: number; skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitCommitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/commits'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIterationCommits');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIterationCommits');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIterationCommits');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getPullRequestIterationCommits');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIterationCommits');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIterationCommits');
            }
            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.skip !== undefined) {
                queryParameters['skip'] = params.skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestIterationChangesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve the changes made in a pull request between two iterations.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration. &lt;br /&gt; Iteration IDs are zero-based with zero indicating the common commit between the source and target branches. Iteration one is the head of the source branch at the time the pull request is created and subsequent iterations are created when there are pushes to the source branch.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Top Optional. The number of changes to retrieve.  The default value is 100 and the maximum value is 2000.
         * @param $Skip Optional. The number of changes to ignore.  For example, to retrieve changes 101-150, set top 50 and skip to 100.
         * @param $CompareTo ID of the pull request iteration to compare against.  The default value is zero which indicates the comparison is made against the common commit between the source and target branches
         */
        public getPullRequestIterationChanges (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; $Top?: number; $Skip?: number; $CompareTo?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestIterationChanges> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/changes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIterationChanges');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIterationChanges');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIterationChanges');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getPullRequestIterationChanges');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIterationChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIterationChanges');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$CompareTo !== undefined) {
                queryParameters['$compareTo'] = params.$CompareTo;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestIterationStatusesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a pull request status on the iteration. This operation will have the same result as Create status on pull request with specified iteration ID in the request body.  The only required field for the status is &#x60;Context.Name&#x60; that uniquely identifies the status. Note that &#x60;iterationId&#x60; in the request body is optional since &#x60;iterationId&#x60; can be specified in the URL. A conflict between &#x60;iterationId&#x60; in the URL and &#x60;iterationId&#x60; in the request body will result in status code 400.
         * @param organization The name of the Azure DevOps organization.
         * @param body Pull request status to create.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPullRequestIterationStatus (params: {  organization: string; body: GitPullRequestStatus; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestStatus> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequestIterationStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequestIterationStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete pull request iteration status.  You can remove multiple statuses in one call by using Update operation.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration.
         * @param statusId ID of the pull request status.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePullRequestIterationStatus (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; statusId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePullRequestIterationStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePullRequestIterationStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the specific pull request iteration status by ID. The status ID is unique within the pull request across all iterations.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration.
         * @param statusId ID of the pull request status.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestIterationStatus (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; statusId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestStatus> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses/{statusId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIterationStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIterationStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all the statuses associated with a pull request iteration.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestIterationStatuses (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequestStatus>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIterationStatuses');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIterationStatuses');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIterationStatuses');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getPullRequestIterationStatuses');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIterationStatuses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIterationStatuses');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update pull request iteration statuses collection. The only supported operation type is &#x60;remove&#x60;.  This operation allows to delete multiple statuses in one call. The path of the &#x60;remove&#x60; operation should refer to the ID of the pull request status. For example &#x60;path&#x3D;&quot;/1&quot;&#x60; refers to the pull request status with ID 1.
         * @param organization The name of the Azure DevOps organization.
         * @param body Operations to apply to the pull request statuses in JSON Patch format.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePullRequestIterationStatuses (params: {  organization: string; body: JsonPatchDocument; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePullRequestIterationStatuses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePullRequestIterationStatuses');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestIterationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get the specified iteration for a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID or name of the repository.
         * @param pullRequestId ID of the pull request.
         * @param iterationId ID of the pull request iteration to return.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestIteration (params: {  organization: string; repositoryId: string; pullRequestId: number; iterationId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestIteration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations/{iterationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIteration');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIteration');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIteration');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getPullRequestIteration');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIteration');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIteration');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the list of iterations for the specified pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID or name of the repository.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeCommits If true, include the commits associated with each iteration in the response.
         */
        public getPullRequestIterations (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; includeCommits?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequestIteration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/iterations'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestIterations');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestIterations');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestIterations');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestIterations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestIterations');
            }
            if (params.includeCommits !== undefined) {
                queryParameters['includeCommits'] = params.includeCommits;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestLabelsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a label for a specified pull request. The only required field is the name of the new label.
         * @param organization The name of the Azure DevOps organization.
         * @param body Label to assign to the pull request.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId Project ID or project name.
         */
        public createPullRequestLabel (params: {  organization: string; body: WebApiCreateTagRequestData; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WebApiTagDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequestLabel');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequestLabel');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequestLabel');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createPullRequestLabel');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequestLabel');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequestLabel');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a label from the set of those assigned to the pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param labelIdOrName The name or ID of the label requested.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId Project ID or project name.
         */
        public deletePullRequestLabels (params: {  organization: string; repositoryId: string; pullRequestId: number; labelIdOrName: string; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'labelIdOrName' + '}', String(params.labelIdOrName))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePullRequestLabels');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deletePullRequestLabels');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deletePullRequestLabels');
            }
            // verify required parameter 'labelIdOrName' is set
            if (params.labelIdOrName == null) {
                throw new Error('Missing required parameter labelIdOrName when calling deletePullRequestLabels');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePullRequestLabels');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePullRequestLabels');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves a single label that has been assigned to a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param labelIdOrName The name or ID of the label requested.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId Project ID or project name.
         */
        public getPullRequestLabel (params: {  organization: string; repositoryId: string; pullRequestId: number; labelIdOrName: string; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WebApiTagDefinition> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels/{labelIdOrName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'labelIdOrName' + '}', String(params.labelIdOrName))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestLabel');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestLabel');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestLabel');
            }
            // verify required parameter 'labelIdOrName' is set
            if (params.labelIdOrName == null) {
                throw new Error('Missing required parameter labelIdOrName when calling getPullRequestLabel');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestLabel');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestLabel');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all the labels assigned to a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId Project ID or project name.
         */
        public getPullRequestLabels (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WebApiTagDefinition>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/labels'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestLabels');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestLabels');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestLabels');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestLabels');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestLabels');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestPropertiesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get external properties of the pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestProperties (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestProperties');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestProperties');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestProperties');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create or update pull request external properties. The patch operation can be &#x60;add&#x60;, &#x60;replace&#x60; or &#x60;remove&#x60;. For &#x60;add&#x60; operation, the path can be empty. If the path is empty, the value must be a list of key value pairs. For &#x60;replace&#x60; operation, the path cannot be empty. If the path does not exist, the property will be added to the collection. For &#x60;remove&#x60; operation, the path cannot be empty. If the path does not exist, no action will be performed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Properties to add, replace or remove in JSON Patch format.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePullRequestProperties (params: {  organization: string; body: JsonPatchDocument; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PropertiesCollection> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/properties'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePullRequestProperties');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePullRequestProperties');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updatePullRequestProperties');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updatePullRequestProperties');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePullRequestProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePullRequestProperties');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestQueryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * This API is used to find what pull requests are related to a given commit.  It can be used to either find the pull request that created a particular merge commit or it can be used to find all pull requests that have ever merged a particular commit.  The input is a list of queries which each contain a list of commits. For each commit that you search against, you will get back a dictionary of commit -&gt; pull requests.
         * @param organization The name of the Azure DevOps organization.
         * @param body The list of queries to perform.
         * @param repositoryId ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestQuery (params: {  organization: string; body: GitPullRequestQuery; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestQuery> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequestquery'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestQuery');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getPullRequestQuery');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestQuery');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestReviewersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a reviewer to a pull request or cast a vote.
         * @param organization The name of the Azure DevOps organization.
         * @param body Reviewer&#39;s vote.&lt;br /&gt;If the reviewer&#39;s ID is included here, it must match the reviewerID parameter.&lt;br /&gt;Reviewers can set their own vote with this method.  When adding other reviewers, vote must be set to zero.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param reviewerId ID of the reviewer.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPullRequestReviewer (params: {  organization: string; body: IdentityRefWithVote; repositoryId: string; pullRequestId: number; reviewerId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<IdentityRefWithVote> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'reviewerId' + '}', String(params.reviewerId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequestReviewer');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequestReviewer');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequestReviewer');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createPullRequestReviewer');
            }
            // verify required parameter 'reviewerId' is set
            if (params.reviewerId == null) {
                throw new Error('Missing required parameter reviewerId when calling createPullRequestReviewer');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequestReviewer');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequestReviewer');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Add reviewers to a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body Reviewers to add to the pull request.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPullRequestReviewers (params: {  organization: string; body: Array<IdentityRef>; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<IdentityRefWithVote>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequestReviewers');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequestReviewers');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequestReviewers');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createPullRequestReviewers');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequestReviewers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequestReviewers');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Remove a reviewer from a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param reviewerId ID of the reviewer to remove.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePullRequestReviewer (params: {  organization: string; repositoryId: string; pullRequestId: number; reviewerId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'reviewerId' + '}', String(params.reviewerId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePullRequestReviewer');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deletePullRequestReviewer');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deletePullRequestReviewer');
            }
            // verify required parameter 'reviewerId' is set
            if (params.reviewerId == null) {
                throw new Error('Missing required parameter reviewerId when calling deletePullRequestReviewer');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePullRequestReviewer');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePullRequestReviewer');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve information about a particular reviewer on a pull request
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param reviewerId ID of the reviewer.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestReviewer (params: {  organization: string; repositoryId: string; pullRequestId: number; reviewerId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<IdentityRefWithVote> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers/{reviewerId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'reviewerId' + '}', String(params.reviewerId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestReviewer');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestReviewer');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestReviewer');
            }
            // verify required parameter 'reviewerId' is set
            if (params.reviewerId == null) {
                throw new Error('Missing required parameter reviewerId when calling getPullRequestReviewer');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestReviewer');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestReviewer');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve the reviewers for a pull request
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestReviewers (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<IdentityRefWithVote>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestReviewers');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestReviewers');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestReviewers');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestReviewers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestReviewers');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Reset the votes of multiple reviewers on a pull request.  NOTE: This endpoint only supports updating votes, but does not support updating required reviewers (use policy) or display names.
         * @param organization The name of the Azure DevOps organization.
         * @param body IDs of the reviewers whose votes will be reset to zero
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePullRequestReviewers (params: {  organization: string; body: Array<IdentityRefWithVote>; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/reviewers'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePullRequestReviewers');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePullRequestReviewers');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updatePullRequestReviewers');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updatePullRequestReviewers');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePullRequestReviewers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePullRequestReviewers');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestShareApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Sends an e-mail notification about a specific pull request to a set of recipients
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param repositoryId ID of the git repository.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public sharePullRequest (params: {  organization: string; body: ShareNotificationContext; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/share'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling sharePullRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling sharePullRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling sharePullRequest');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling sharePullRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling sharePullRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling sharePullRequest');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestStatusesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a pull request status.  The only required field for the status is &#x60;Context.Name&#x60; that uniquely identifies the status. Note that you can specify iterationId in the request body to post the status on the iteration.
         * @param organization The name of the Azure DevOps organization.
         * @param body Pull request status to create.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createPullRequestStatus (params: {  organization: string; body: GitPullRequestStatus; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestStatus> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequestStatus');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequestStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequestStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createPullRequestStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequestStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequestStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete pull request status.  You can remove multiple statuses in one call by using Update operation.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param statusId ID of the pull request status.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePullRequestStatus (params: {  organization: string; repositoryId: string; pullRequestId: number; statusId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePullRequestStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deletePullRequestStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deletePullRequestStatus');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling deletePullRequestStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deletePullRequestStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePullRequestStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the specific pull request status by ID. The status ID is unique within the pull request across all iterations.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param statusId ID of the pull request status.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestStatus (params: {  organization: string; repositoryId: string; pullRequestId: number; statusId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestStatus> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses/{statusId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'statusId' + '}', String(params.statusId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestStatus');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestStatus');
            }
            // verify required parameter 'statusId' is set
            if (params.statusId == null) {
                throw new Error('Missing required parameter statusId when calling getPullRequestStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all the statuses associated with a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestStatuses (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequestStatus>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestStatuses');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestStatuses');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestStatuses');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestStatuses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestStatuses');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update pull request statuses collection. The only supported operation type is &#x60;remove&#x60;.  This operation allows to delete multiple statuses in one call. The path of the &#x60;remove&#x60; operation should refer to the ID of the pull request status. For example &#x60;path&#x3D;&quot;/1&quot;&#x60; refers to the pull request status with ID 1.
         * @param organization The name of the Azure DevOps organization.
         * @param body Operations to apply to the pull request statuses in JSON Patch format.
         * @param repositoryId The repository ID of the pull request’s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePullRequestStatuses (params: {  organization: string; body: JsonPatchDocument; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePullRequestStatuses');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePullRequestStatuses');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updatePullRequestStatuses');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updatePullRequestStatuses');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePullRequestStatuses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePullRequestStatuses');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestThreadCommentsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a comment on a specific thread in a pull request (up to 500 comments can be created per thread).
         * @param organization The name of the Azure DevOps organization.
         * @param body The comment to create. Comments can be up to 150,000 characters.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread that the desired comment is in.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createComment (params: {  organization: string; body: Comment; repositoryId: string; pullRequestId: number; threadId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Comment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createComment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createComment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createComment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createComment');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling createComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a comment associated with a specific thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread that the desired comment is in.
         * @param commentId ID of the comment.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteComment (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteComment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deleteComment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling deleteComment');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling deleteComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling deleteComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a comment associated with a specific thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread that the desired comment is in.
         * @param commentId ID of the comment.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getComment (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Comment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getComment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getComment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getComment');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling getComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling getComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all comments associated with a specific thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getComments (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Comment>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getComments');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getComments');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getComments');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling getComments');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getComments');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getComments');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a comment associated with a specific thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The comment content that should be updated. Comments can be up to 150,000 characters.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread that the desired comment is in.
         * @param commentId ID of the comment to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateComment (params: {  organization: string; body: Comment; repositoryId: string; pullRequestId: number; threadId: number; commentId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Comment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}/comments/{commentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'commentId' + '}', String(params.commentId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateComment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateComment');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateComment');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updateComment');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling updateComment');
            }
            // verify required parameter 'commentId' is set
            if (params.commentId == null) {
                throw new Error('Missing required parameter commentId when calling updateComment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateComment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateComment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestThreadsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The thread to create. Thread must contain at least one comment.
         * @param repositoryId Repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createThread (params: {  organization: string; body: GitPullRequestCommentThread; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestCommentThread> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createThread');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createThread');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createThread');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling createThread');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createThread');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createThread');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Iteration If specified, thread position will be tracked using this iteration as the right side of the diff.
         * @param $BaseIteration If specified, thread position will be tracked using this iteration as the left side of the diff.
         */
        public getPullRequestThread (params: {  organization: string; repositoryId: string; pullRequestId: number; threadId: number; project: string; apiVersion: string; $Iteration?: number; $BaseIteration?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestCommentThread> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestThread');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestThread');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestThread');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling getPullRequestThread');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestThread');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestThread');
            }
            if (params.$Iteration !== undefined) {
                queryParameters['$iteration'] = params.$Iteration;
            }

            if (params.$BaseIteration !== undefined) {
                queryParameters['$baseIteration'] = params.$BaseIteration;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all threads in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Iteration If specified, thread positions will be tracked using this iteration as the right side of the diff.
         * @param $BaseIteration If specified, thread positions will be tracked using this iteration as the left side of the diff.
         */
        public getThreads (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; $Iteration?: number; $BaseIteration?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequestCommentThread>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getThreads');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getThreads');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getThreads');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getThreads');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getThreads');
            }
            if (params.$Iteration !== undefined) {
                queryParameters['$iteration'] = params.$Iteration;
            }

            if (params.$BaseIteration !== undefined) {
                queryParameters['$baseIteration'] = params.$BaseIteration;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a thread in a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The thread content that should be updated.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request.
         * @param threadId ID of the thread to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateThread (params: {  organization: string; body: GitPullRequestCommentThread; repositoryId: string; pullRequestId: number; threadId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequestCommentThread> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/threads/{threadId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'threadId' + '}', String(params.threadId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateThread');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateThread');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateThread');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updateThread');
            }
            // verify required parameter 'threadId' is set
            if (params.threadId == null) {
                throw new Error('Missing required parameter threadId when calling updateThread');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateThread');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateThread');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestWorkItemsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve a list of work items associated with a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID or name of the repository.
         * @param pullRequestId ID of the pull request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestWorkItemRefs (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ResourceRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullRequests/{pullRequestId}/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestWorkItemRefs');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequestWorkItemRefs');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestWorkItemRefs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestWorkItemRefs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestWorkItemRefs');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PullRequestsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The pull request to create.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param supportsIterations If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed.
         */
        public createPullRequest (params: {  organization: string; body: GitPullRequest; repositoryId: string; project: string; apiVersion: string; supportsIterations?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPullRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPullRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPullRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPullRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPullRequest');
            }
            if (params.supportsIterations !== undefined) {
                queryParameters['supportsIterations'] = params.supportsIterations;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId The ID of the pull request to retrieve.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param maxCommentLength Not used.
         * @param $Skip Not used.
         * @param $Top Not used.
         * @param includeCommits If true, the pull request will be returned with the associated commits.
         * @param includeWorkItemRefs If true, the pull request will be returned with the associated work item references.
         */
        public getPullRequest (params: {  organization: string; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; maxCommentLength?: number; $Skip?: number; $Top?: number; includeCommits?: boolean; includeWorkItemRefs?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequest');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequest');
            }
            if (params.maxCommentLength !== undefined) {
                queryParameters['maxCommentLength'] = params.maxCommentLength;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.includeCommits !== undefined) {
                queryParameters['includeCommits'] = params.includeCommits;
            }

            if (params.includeWorkItemRefs !== undefined) {
                queryParameters['includeWorkItemRefs'] = params.includeWorkItemRefs;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param pullRequestId The ID of the pull request to retrieve.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPullRequestById (params: {  organization: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/pullrequests/{pullRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestById');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequestById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all pull requests matching a specified criteria.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param searchCriteriaIncludeLinks Whether to include the _links field on the shallow references
         * @param searchCriteriaSourceRefName If set, search for pull requests from this branch.
         * @param searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository.
         * @param searchCriteriaTargetRefName If set, search for pull requests into this branch.
         * @param searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset.
         * @param searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer.
         * @param searchCriteriaCreatorId If set, search for pull requests that were created by this identity.
         * @param searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository.
         * @param maxCommentLength Not used.
         * @param $Skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
         * @param $Top The number of pull requests to retrieve.
         */
        public getPullRequests (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; searchCriteriaIncludeLinks?: boolean; searchCriteriaSourceRefName?: string; searchCriteriaSourceRepositoryId?: string; searchCriteriaTargetRefName?: string; searchCriteriaStatus?: string; searchCriteriaReviewerId?: string; searchCriteriaCreatorId?: string; searchCriteriaRepositoryId?: string; maxCommentLength?: number; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequest>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequests');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPullRequests');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequests');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequests');
            }
            if (params.searchCriteriaIncludeLinks !== undefined) {
                queryParameters['searchCriteria.includeLinks'] = params.searchCriteriaIncludeLinks;
            }

            if (params.searchCriteriaSourceRefName !== undefined) {
                queryParameters['searchCriteria.sourceRefName'] = params.searchCriteriaSourceRefName;
            }

            if (params.searchCriteriaSourceRepositoryId !== undefined) {
                queryParameters['searchCriteria.sourceRepositoryId'] = params.searchCriteriaSourceRepositoryId;
            }

            if (params.searchCriteriaTargetRefName !== undefined) {
                queryParameters['searchCriteria.targetRefName'] = params.searchCriteriaTargetRefName;
            }

            if (params.searchCriteriaStatus !== undefined) {
                queryParameters['searchCriteria.status'] = params.searchCriteriaStatus;
            }

            if (params.searchCriteriaReviewerId !== undefined) {
                queryParameters['searchCriteria.reviewerId'] = params.searchCriteriaReviewerId;
            }

            if (params.searchCriteriaCreatorId !== undefined) {
                queryParameters['searchCriteria.creatorId'] = params.searchCriteriaCreatorId;
            }

            if (params.searchCriteriaRepositoryId !== undefined) {
                queryParameters['searchCriteria.repositoryId'] = params.searchCriteriaRepositoryId;
            }

            if (params.maxCommentLength !== undefined) {
                queryParameters['maxCommentLength'] = params.maxCommentLength;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all pull requests matching a specified criteria.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param searchCriteriaIncludeLinks Whether to include the _links field on the shallow references
         * @param searchCriteriaSourceRefName If set, search for pull requests from this branch.
         * @param searchCriteriaSourceRepositoryId If set, search for pull requests whose source branch is in this repository.
         * @param searchCriteriaTargetRefName If set, search for pull requests into this branch.
         * @param searchCriteriaStatus If set, search for pull requests that are in this state. Defaults to Active if unset.
         * @param searchCriteriaReviewerId If set, search for pull requests that have this identity as a reviewer.
         * @param searchCriteriaCreatorId If set, search for pull requests that were created by this identity.
         * @param searchCriteriaRepositoryId If set, search for pull requests whose target branch is in this repository.
         * @param maxCommentLength Not used.
         * @param $Skip The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
         * @param $Top The number of pull requests to retrieve.
         */
        public getPullRequestsByProject (params: {  organization: string; project: string; apiVersion: string; searchCriteriaIncludeLinks?: boolean; searchCriteriaSourceRefName?: string; searchCriteriaSourceRepositoryId?: string; searchCriteriaTargetRefName?: string; searchCriteriaStatus?: string; searchCriteriaReviewerId?: string; searchCriteriaCreatorId?: string; searchCriteriaRepositoryId?: string; maxCommentLength?: number; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPullRequest>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/pullrequests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequestsByProject');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequestsByProject');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequestsByProject');
            }
            if (params.searchCriteriaIncludeLinks !== undefined) {
                queryParameters['searchCriteria.includeLinks'] = params.searchCriteriaIncludeLinks;
            }

            if (params.searchCriteriaSourceRefName !== undefined) {
                queryParameters['searchCriteria.sourceRefName'] = params.searchCriteriaSourceRefName;
            }

            if (params.searchCriteriaSourceRepositoryId !== undefined) {
                queryParameters['searchCriteria.sourceRepositoryId'] = params.searchCriteriaSourceRepositoryId;
            }

            if (params.searchCriteriaTargetRefName !== undefined) {
                queryParameters['searchCriteria.targetRefName'] = params.searchCriteriaTargetRefName;
            }

            if (params.searchCriteriaStatus !== undefined) {
                queryParameters['searchCriteria.status'] = params.searchCriteriaStatus;
            }

            if (params.searchCriteriaReviewerId !== undefined) {
                queryParameters['searchCriteria.reviewerId'] = params.searchCriteriaReviewerId;
            }

            if (params.searchCriteriaCreatorId !== undefined) {
                queryParameters['searchCriteria.creatorId'] = params.searchCriteriaCreatorId;
            }

            if (params.searchCriteriaRepositoryId !== undefined) {
                queryParameters['searchCriteria.repositoryId'] = params.searchCriteriaRepositoryId;
            }

            if (params.maxCommentLength !== undefined) {
                queryParameters['maxCommentLength'] = params.maxCommentLength;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a pull request  These are the properties that can be updated with the API:  - Status  - Title  - Description (up to 4000 characters)  - CompletionOptions  - MergeOptions  - AutoCompleteSetBy.Id  - TargetRefName (when the PR retargeting feature is enabled)  Attempting to update other properties outside of this list will either cause the server to throw an &#x60;InvalidArgumentValueException&#x60;,  or to silently ignore the update.
         * @param organization The name of the Azure DevOps organization.
         * @param body The pull request content that should be updated.
         * @param repositoryId The repository ID of the pull request&#39;s target branch.
         * @param pullRequestId ID of the pull request to update.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePullRequest (params: {  organization: string; body: GitPullRequest; repositoryId: string; pullRequestId: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPullRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pullrequests/{pullRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePullRequest');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePullRequest');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updatePullRequest');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling updatePullRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updatePullRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePullRequest');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PushesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Push changes to the repository.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createPush (params: {  organization: string; body: GitPush; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPush> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pushes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createPush');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createPush');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createPush');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createPush');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createPush');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves a particular push.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param pushId ID of the push.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param includeCommits The number of commits to include in the result.
         * @param includeRefUpdates If true, include the list of refs that were updated by the push.
         */
        public getPush (params: {  organization: string; repositoryId: string; pushId: number; project: string; apiVersion: string; includeCommits?: number; includeRefUpdates?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitPush> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pushes/{pushId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'pushId' + '}', String(params.pushId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPush');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPush');
            }
            // verify required parameter 'pushId' is set
            if (params.pushId == null) {
                throw new Error('Missing required parameter pushId when calling getPush');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPush');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPush');
            }
            if (params.includeCommits !== undefined) {
                queryParameters['includeCommits'] = params.includeCommits;
            }

            if (params.includeRefUpdates !== undefined) {
                queryParameters['includeRefUpdates'] = params.includeRefUpdates;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves pushes associated with the specified repository.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Skip Number of pushes to skip.
         * @param $Top Number of pushes to return.
         * @param searchCriteriaIncludeLinks Whether to include the _links field on the shallow references
         * @param searchCriteriaIncludeRefUpdates Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
         * @param searchCriteriaRefName Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
         * @param searchCriteriaPusherId Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
         * @param searchCriteriaToDate Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
         * @param searchCriteriaFromDate Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
         */
        public getPushes (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; $Skip?: number; $Top?: number; searchCriteriaIncludeLinks?: boolean; searchCriteriaIncludeRefUpdates?: boolean; searchCriteriaRefName?: string; searchCriteriaPusherId?: string; searchCriteriaToDate?: Date; searchCriteriaFromDate?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitPush>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/pushes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPushes');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getPushes');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPushes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPushes');
            }
            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.searchCriteriaIncludeLinks !== undefined) {
                queryParameters['searchCriteria.includeLinks'] = params.searchCriteriaIncludeLinks;
            }

            if (params.searchCriteriaIncludeRefUpdates !== undefined) {
                queryParameters['searchCriteria.includeRefUpdates'] = params.searchCriteriaIncludeRefUpdates;
            }

            if (params.searchCriteriaRefName !== undefined) {
                queryParameters['searchCriteria.refName'] = params.searchCriteriaRefName;
            }

            if (params.searchCriteriaPusherId !== undefined) {
                queryParameters['searchCriteria.pusherId'] = params.searchCriteriaPusherId;
            }

            if (params.searchCriteriaToDate !== undefined) {
                queryParameters['searchCriteria.toDate'] = params.searchCriteriaToDate;
            }

            if (params.searchCriteriaFromDate !== undefined) {
                queryParameters['searchCriteria.fromDate'] = params.searchCriteriaFromDate;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class PythonApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a package version, moving it to the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a package version from the feed, moving it to the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersionFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Download a python package file directly. This API is intended for manual UI download options, not for programmatic access and scripting.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param fileName Name of the file in the package
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public downloadPackage (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; fileName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/packages/{packageName}/versions/{packageVersion}/{fileName}/content'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion))
                .replace('{' + 'fileName' + '}', String(params.fileName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling downloadPackage');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling downloadPackage');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling downloadPackage');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling downloadPackage');
            }
            // verify required parameter 'fileName' is set
            if (params.fileName == null) {
                throw new Error('Missing required parameter fileName when calling downloadPackage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling downloadPackage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param showDeleted True to show information for deleted package versions.
         */
        public getPackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; showDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersion');
            }
            if (params.showDeleted !== undefined) {
                queryParameters['showDeleted'] = params.showDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version in the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionMetadataFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PyPiPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version from the recycle bin to its associated feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Set the &#39;Deleted&#39; state to &#39;false&#39; to restore the package to its feed.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restorePackageVersionFromRecycleBin (params: {  organization: string; body: PyPiRecycleBinPackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restorePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update state for a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param body Details to be updated.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackageVersion (params: {  organization: string; body: PackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/pypi/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackageVersion');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling updatePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling updatePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class QueriesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a query, or moves a query.  Learn more about Work Item Query Language (WIQL) syntax [here](https://docs.microsoft.com/en-us/vsts/collaborate/wiql-syntax?toc&#x3D;/vsts/work/track/toc.json&amp;bc&#x3D;/vsts/work/track/breadcrumb/toc.json&amp;view&#x3D;vsts).
         * @param organization The name of the Azure DevOps organization.
         * @param body The query to create.
         * @param project Project ID or project name
         * @param query The parent id or path under which the query is to be created.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createQuery (params: {  organization: string; body: QueryHierarchyItem; project: string; query: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<QueryHierarchyItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queries/{query}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'query' + '}', String(params.query));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createQuery');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createQuery');
            }
            // verify required parameter 'query' is set
            if (params.query == null) {
                throw new Error('Missing required parameter query when calling createQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createQuery');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a query or a folder. This deletes any permission change on the deleted query or folder and any of its descendants if it is a folder. It is important to note that the deleted permission changes cannot be recovered upon undeleting the query or folder.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param query ID or path of the query or folder to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteQuery (params: {  organization: string; project: string; query: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queries/{query}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'query' + '}', String(params.query));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteQuery');
            }
            // verify required parameter 'query' is set
            if (params.query == null) {
                throw new Error('Missing required parameter query when calling deleteQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteQuery');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the root queries and their children
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand Include the query string (wiql), clauses, query result columns, and sort options in the results.
         * @param $Depth In the folder of queries, return child queries and folders to this depth.
         * @param $IncludeDeleted Include deleted queries and folders
         */
        public getQueries (params: {  organization: string; project: string; apiVersion: string; $Expand?: string; $Depth?: number; $IncludeDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<QueryHierarchyItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queries'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getQueries');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getQueries');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getQueries');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.$Depth !== undefined) {
                queryParameters['$depth'] = params.$Depth;
            }

            if (params.$IncludeDeleted !== undefined) {
                queryParameters['$includeDeleted'] = params.$IncludeDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of queries by ids (Maximum 1000)
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getQueriesBatch (params: {  organization: string; body: QueryBatchGetRequest; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<QueryHierarchyItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queriesbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getQueriesBatch');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getQueriesBatch');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getQueriesBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getQueriesBatch');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieves an individual query and its children
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param query ID or path of the query.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand Include the query string (wiql), clauses, query result columns, and sort options in the results.
         * @param $Depth In the folder of queries, return child queries and folders to this depth.
         * @param $IncludeDeleted Include deleted queries and folders
         */
        public getQuery (params: {  organization: string; project: string; query: string; apiVersion: string; $Expand?: string; $Depth?: number; $IncludeDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<QueryHierarchyItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queries/{query}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'query' + '}', String(params.query));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getQuery');
            }
            // verify required parameter 'query' is set
            if (params.query == null) {
                throw new Error('Missing required parameter query when calling getQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getQuery');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.$Depth !== undefined) {
                queryParameters['$depth'] = params.$Depth;
            }

            if (params.$IncludeDeleted !== undefined) {
                queryParameters['$includeDeleted'] = params.$IncludeDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a query or a folder. This allows you to update, rename and move queries and folders.
         * @param organization The name of the Azure DevOps organization.
         * @param body The query to update.
         * @param project Project ID or project name
         * @param query The ID or path for the query to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $UndeleteDescendants Undelete the children of this folder. It is important to note that this will not bring back the permission changes that were previously applied to the descendants.
         */
        public updateQuery (params: {  organization: string; body: QueryHierarchyItem; project: string; query: string; apiVersion: string; $UndeleteDescendants?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<QueryHierarchyItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/queries/{query}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'query' + '}', String(params.query));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateQuery');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateQuery');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateQuery');
            }
            // verify required parameter 'query' is set
            if (params.query == null) {
                throw new Error('Missing required parameter query when calling updateQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateQuery');
            }
            if (params.$UndeleteDescendants !== undefined) {
                queryParameters['$undeleteDescendants'] = params.$UndeleteDescendants;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RecycleBinApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get information about a package and all its versions within the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId The package Id (GUID Id, not the package name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         */
        public getRecycleBinPackage (params: {  organization: string; feedId: string; packageId: string; apiVersion: string; includeUrls?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/RecycleBin/Packages/{packageId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecycleBinPackage');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getRecycleBinPackage');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getRecycleBinPackage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecycleBinPackage');
            }
            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version within the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId The package Id (GUID Id, not the package name).
         * @param packageVersionId The package version Id 9guid Id, not the version string).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         */
        public getRecycleBinPackageVersion (params: {  organization: string; feedId: string; packageId: string; packageVersionId: string; apiVersion: string; includeUrls?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<RecycleBinPackageVersion> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/RecycleBin/Packages/{packageId}/Versions/{packageVersionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId))
                .replace('{' + 'packageVersionId' + '}', String(params.packageVersionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecycleBinPackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getRecycleBinPackageVersion');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getRecycleBinPackageVersion');
            }
            // verify required parameter 'packageVersionId' is set
            if (params.packageVersionId == null) {
                throw new Error('Missing required parameter packageVersionId when calling getRecycleBinPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecycleBinPackageVersion');
            }
            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of package versions within the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param packageId The package Id (GUID Id, not the package name).
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         */
        public getRecycleBinPackageVersions (params: {  organization: string; feedId: string; packageId: string; apiVersion: string; includeUrls?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<RecycleBinPackageVersion>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/RecycleBin/Packages/{packageId}/Versions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageId' + '}', String(params.packageId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecycleBinPackageVersions');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getRecycleBinPackageVersions');
            }
            // verify required parameter 'packageId' is set
            if (params.packageId == null) {
                throw new Error('Missing required parameter packageId when calling getRecycleBinPackageVersions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecycleBinPackageVersions');
            }
            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query for packages within the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or Id of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param protocolType Type of package (e.g. NuGet, npm, ...).
         * @param packageNameQuery Filter to packages matching this name.
         * @param includeUrls True to return REST Urls with the response.  Default is True.
         * @param $Top Get the top N packages.
         * @param $Skip Skip the first N packages.
         * @param includeAllVersions True to return all versions of the package in the response.  Default is false (latest version only).
         */
        public getRecycleBinPackages (params: {  organization: string; feedId: string; apiVersion: string; protocolType?: string; packageNameQuery?: string; includeUrls?: boolean; $Top?: number; $Skip?: number; includeAllVersions?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ModelPackage>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/RecycleBin/Packages'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecycleBinPackages');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getRecycleBinPackages');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecycleBinPackages');
            }
            if (params.protocolType !== undefined) {
                queryParameters['protocolType'] = params.protocolType;
            }

            if (params.packageNameQuery !== undefined) {
                queryParameters['packageNameQuery'] = params.packageNameQuery;
            }

            if (params.includeUrls !== undefined) {
                queryParameters['includeUrls'] = params.includeUrls;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.includeAllVersions !== undefined) {
                queryParameters['includeAllVersions'] = params.includeAllVersions;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RecyclebinApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Destroys the specified work item permanently from the Recycle Bin. This action can not be undone.
         * @param organization The name of the Azure DevOps organization.
         * @param id ID of the work item to be destroyed permanently
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public destroyWorkItem (params: {  organization: string; id: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/recyclebin/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling destroyWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling destroyWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling destroyWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling destroyWorkItem');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a deleted work item from Recycle Bin.
         * @param organization The name of the Azure DevOps organization.
         * @param id ID of the work item to be returned
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getDeletedWorkItem (params: {  organization: string; id: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemDelete> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/recyclebin/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeletedWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getDeletedWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeletedWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeletedWorkItem');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of the IDs and the URLs of the deleted the work items in the Recycle Bin.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getDeletedWorkItemShallowReferences (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemDeleteShallowReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/recyclebin'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeletedWorkItemShallowReferences');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeletedWorkItemShallowReferences');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeletedWorkItemShallowReferences');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restores the deleted work item from Recycle Bin.
         * @param organization The name of the Azure DevOps organization.
         * @param body Paylod with instructions to update the IsDeleted flag to false
         * @param id ID of the work item to be restored
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public restoreWorkItem (params: {  organization: string; body: WorkItemDeleteUpdate; id: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemDelete> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/recyclebin/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restoreWorkItem');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restoreWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling restoreWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling restoreWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restoreWorkItem');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RefsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Queries the provided repository for its refs and returns them.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param filter [optional] A filter to apply to the refs (starts with).
         * @param includeLinks [optional] Specifies if referenceLinks should be included in the result. default is false.
         * @param includeStatuses [optional] Includes up to the first 1000 commit statuses for each ref. The default value is false.
         * @param includeMyBranches [optional] Includes only branches that the user owns, the branches the user favorites, and the default branch. The default value is false. Cannot be combined with the filter parameter.
         * @param latestStatusesOnly [optional] True to include only the tip commit status for each ref. This option requires &#x60;includeStatuses&#x60; to be true. The default value is false.
         * @param peelTags [optional] Annotated tags will populate the PeeledObjectId property. default is false.
         * @param filterContains [optional] A filter to apply to the refs (contains).
         * @param $Top [optional] Maximum number of refs to return. It cannot be bigger than 1000. If it is not provided but continuationToken is, top will default to 100.
         * @param continuationToken The continuation token used for pagination.
         */
        public getRefs (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; filter?: string; includeLinks?: boolean; includeStatuses?: boolean; includeMyBranches?: boolean; latestStatusesOnly?: boolean; peelTags?: boolean; filterContains?: string; $Top?: number; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitRef>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/refs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRefs');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getRefs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRefs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRefs');
            }
            if (params.filter !== undefined) {
                queryParameters['filter'] = params.filter;
            }

            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.includeStatuses !== undefined) {
                queryParameters['includeStatuses'] = params.includeStatuses;
            }

            if (params.includeMyBranches !== undefined) {
                queryParameters['includeMyBranches'] = params.includeMyBranches;
            }

            if (params.latestStatusesOnly !== undefined) {
                queryParameters['latestStatusesOnly'] = params.latestStatusesOnly;
            }

            if (params.peelTags !== undefined) {
                queryParameters['peelTags'] = params.peelTags;
            }

            if (params.filterContains !== undefined) {
                queryParameters['filterContains'] = params.filterContains;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Lock or Unlock a branch.
         * @param organization The name of the Azure DevOps organization.
         * @param body The ref update action (lock/unlock) to perform
         * @param repositoryId The name or ID of the repository.
         * @param filter The name of the branch to lock/unlock
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId ID or name of the team project. Optional if specifying an ID for repository.
         */
        public updateRef (params: {  organization: string; body: GitRefUpdate; repositoryId: string; filter: string; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRef> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/refs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRef');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRef');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateRef');
            }
            // verify required parameter 'filter' is set
            if (params.filter == null) {
                throw new Error('Missing required parameter filter when calling updateRef');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateRef');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRef');
            }
            if (params.filter !== undefined) {
                queryParameters['filter'] = params.filter;
            }

            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creating, updating, or deleting refs(branches).  Updating a ref means making it point at a different commit than it used to. You must specify both the old and new commit to avoid race conditions.
         * @param organization The name of the Azure DevOps organization.
         * @param body List of ref updates to attempt to perform
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId ID or name of the team project. Optional if specifying an ID for repository.
         */
        public updateRefs (params: {  organization: string; body: Array<GitRefUpdate>; repositoryId: string; project: string; apiVersion: string; projectId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitRefUpdateResult>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/refs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRefs');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRefs');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateRefs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateRefs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRefs');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RefsFavoritesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a ref favorite
         * @param organization The name of the Azure DevOps organization.
         * @param body The ref favorite to create.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createFavorite (params: {  organization: string; body: GitRefFavorite; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRefFavorite> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/favorites/refs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createFavorite');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createFavorite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createFavorite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createFavorite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes the refs favorite specified
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param favoriteId The Id of the ref favorite to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteRefFavorite (params: {  organization: string; project: string; favoriteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/favorites/refs/{favoriteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'favoriteId' + '}', String(params.favoriteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteRefFavorite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteRefFavorite');
            }
            // verify required parameter 'favoriteId' is set
            if (params.favoriteId == null) {
                throw new Error('Missing required parameter favoriteId when calling deleteRefFavorite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteRefFavorite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the refs favorite for a favorite Id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param favoriteId The Id of the requested ref favorite.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRefFavorite (params: {  organization: string; project: string; favoriteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRefFavorite> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/favorites/refs/{favoriteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'favoriteId' + '}', String(params.favoriteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRefFavorite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRefFavorite');
            }
            // verify required parameter 'favoriteId' is set
            if (params.favoriteId == null) {
                throw new Error('Missing required parameter favoriteId when calling getRefFavorite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRefFavorite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the refs favorites for a repo and an identity.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param repositoryId The id of the repository.
         * @param identityId The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.
         */
        public getRefFavorites (params: {  organization: string; project: string; apiVersion: string; repositoryId?: string; identityId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitRefFavorite>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/favorites/refs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRefFavorites');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRefFavorites');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRefFavorites');
            }
            if (params.repositoryId !== undefined) {
                queryParameters['repositoryId'] = params.repositoryId;
            }

            if (params.identityId !== undefined) {
                queryParameters['identityId'] = params.identityId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReleasesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a release.
         * @param organization The name of the Azure DevOps organization.
         * @param body Metadata to create a release.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.8&#39; to use this version of the api.
         */
        public createRelease (params: {  organization: string; body: ReleaseStartMetadata; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Release> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRelease');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRelease');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createRelease');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRelease');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get logs for a release Id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getLogs (params: {  organization: string; project: string; releaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/logs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLogs');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getLogs');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getLogs');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLogs');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get release for a given revision number.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param definitionSnapshotRevision Definition snapshot revision number.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.8&#39; to use this version of the api.
         */
        public getReleaseRevision (params: {  organization: string; project: string; releaseId: number; definitionSnapshotRevision: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleaseRevision');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleaseRevision');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getReleaseRevision');
            }
            // verify required parameter 'definitionSnapshotRevision' is set
            if (params.definitionSnapshotRevision == null) {
                throw new Error('Missing required parameter definitionSnapshotRevision when calling getReleaseRevision');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleaseRevision');
            }
            if (params.definitionSnapshotRevision !== undefined) {
                queryParameters['definitionSnapshotRevision'] = params.definitionSnapshotRevision;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of releases
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.8&#39; to use this version of the api.
         * @param definitionId Releases from this release definition Id.
         * @param definitionEnvironmentId 
         * @param searchText Releases with names containing searchText.
         * @param createdBy Releases created by this user.
         * @param statusFilter Releases that have this status.
         * @param environmentStatusFilter 
         * @param minCreatedTime Releases that were created after this time.
         * @param maxCreatedTime Releases that were created before this time.
         * @param queryOrder Gets the results in the defined order of created date for releases. Default is descending.
         * @param $Top Number of releases to get. Default is 50.
         * @param continuationToken Gets the releases after the continuation token provided.
         * @param $Expand The property that should be expanded in the list of releases.
         * @param artifactTypeId Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
         * @param sourceId Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer &#39;uniqueSourceIdentifier&#39; inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
         * @param artifactVersionId Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId.
         * @param sourceBranchFilter Releases with given sourceBranchFilter will be returned.
         * @param isDeleted Gets the soft deleted releases, if true.
         * @param tagFilter A comma-delimited list of tags. Only releases with these tags will be returned.
         * @param propertyFilters A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not.
         * @param releaseIdFilter A comma-delimited list of releases Ids. Only releases with these Ids will be returned.
         * @param path Releases under this folder path will be returned
         */
        public getReleases (params: {  organization: string; project: string; apiVersion: string; definitionId?: number; definitionEnvironmentId?: number; searchText?: string; createdBy?: string; statusFilter?: string; environmentStatusFilter?: number; minCreatedTime?: Date; maxCreatedTime?: Date; queryOrder?: string; $Top?: number; continuationToken?: number; $Expand?: string; artifactTypeId?: string; sourceId?: string; artifactVersionId?: string; sourceBranchFilter?: string; isDeleted?: boolean; tagFilter?: string; propertyFilters?: string; releaseIdFilter?: string; path?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Release>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReleases');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReleases');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReleases');
            }
            if (params.definitionId !== undefined) {
                queryParameters['definitionId'] = params.definitionId;
            }

            if (params.definitionEnvironmentId !== undefined) {
                queryParameters['definitionEnvironmentId'] = params.definitionEnvironmentId;
            }

            if (params.searchText !== undefined) {
                queryParameters['searchText'] = params.searchText;
            }

            if (params.createdBy !== undefined) {
                queryParameters['createdBy'] = params.createdBy;
            }

            if (params.statusFilter !== undefined) {
                queryParameters['statusFilter'] = params.statusFilter;
            }

            if (params.environmentStatusFilter !== undefined) {
                queryParameters['environmentStatusFilter'] = params.environmentStatusFilter;
            }

            if (params.minCreatedTime !== undefined) {
                queryParameters['minCreatedTime'] = params.minCreatedTime;
            }

            if (params.maxCreatedTime !== undefined) {
                queryParameters['maxCreatedTime'] = params.maxCreatedTime;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.artifactTypeId !== undefined) {
                queryParameters['artifactTypeId'] = params.artifactTypeId;
            }

            if (params.sourceId !== undefined) {
                queryParameters['sourceId'] = params.sourceId;
            }

            if (params.artifactVersionId !== undefined) {
                queryParameters['artifactVersionId'] = params.artifactVersionId;
            }

            if (params.sourceBranchFilter !== undefined) {
                queryParameters['sourceBranchFilter'] = params.sourceBranchFilter;
            }

            if (params.isDeleted !== undefined) {
                queryParameters['isDeleted'] = params.isDeleted;
            }

            if (params.tagFilter !== undefined) {
                queryParameters['tagFilter'] = params.tagFilter;
            }

            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.releaseIdFilter !== undefined) {
                queryParameters['releaseIdFilter'] = params.releaseIdFilter;
            }

            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the task log of a release as a plain text file.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of release environment.
         * @param releaseDeployPhaseId Release deploy phase Id.
         * @param taskId ReleaseTask Id for the log.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param startLine Starting line number for logs
         * @param endLine Ending line number for logs
         */
        public getTaskLog (params: {  organization: string; project: string; releaseId: number; environmentId: number; releaseDeployPhaseId: number; taskId: number; apiVersion: string; startLine?: number; endLine?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}/environments/{environmentId}/deployPhases/{releaseDeployPhaseId}/tasks/{taskId}/logs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId))
                .replace('{' + 'releaseDeployPhaseId' + '}', String(params.releaseDeployPhaseId))
                .replace('{' + 'taskId' + '}', String(params.taskId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTaskLog');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTaskLog');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling getTaskLog');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling getTaskLog');
            }
            // verify required parameter 'releaseDeployPhaseId' is set
            if (params.releaseDeployPhaseId == null) {
                throw new Error('Missing required parameter releaseDeployPhaseId when calling getTaskLog');
            }
            // verify required parameter 'taskId' is set
            if (params.taskId == null) {
                throw new Error('Missing required parameter taskId when calling getTaskLog');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTaskLog');
            }
            if (params.startLine !== undefined) {
                queryParameters['startLine'] = params.startLine;
            }

            if (params.endLine !== undefined) {
                queryParameters['endLine'] = params.endLine;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a complete release object.
         * @param organization The name of the Azure DevOps organization.
         * @param body Release object for update.
         * @param project Project ID or project name
         * @param releaseId Id of the release to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.8&#39; to use this version of the api.
         */
        public updateRelease (params: {  organization: string; body: Release; project: string; releaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Release> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRelease');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRelease');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateRelease');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling updateRelease');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRelease');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the status of a release environment
         * @param organization The name of the Azure DevOps organization.
         * @param body Environment update meta data.
         * @param project Project ID or project name
         * @param releaseId Id of the release.
         * @param environmentId Id of release environment.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.6&#39; to use this version of the api.
         */
        public updateReleaseEnvironment (params: {  organization: string; body: ReleaseEnvironmentUpdateMetadata; project: string; releaseId: number; environmentId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReleaseEnvironment> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/Release/releases/{releaseId}/environments/{environmentId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId))
                .replace('{' + 'environmentId' + '}', String(params.environmentId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateReleaseEnvironment');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateReleaseEnvironment');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateReleaseEnvironment');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling updateReleaseEnvironment');
            }
            // verify required parameter 'environmentId' is set
            if (params.environmentId == null) {
                throw new Error('Missing required parameter environmentId when calling updateReleaseEnvironment');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateReleaseEnvironment');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update few properties of a release.
         * @param organization The name of the Azure DevOps organization.
         * @param body Properties of release to update.
         * @param project Project ID or project name
         * @param releaseId Id of the release to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.8&#39; to use this version of the api.
         */
        public updateReleaseResource (params: {  organization: string; body: ReleaseUpdateMetadata; project: string; releaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Release> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/release/releases/{releaseId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'releaseId' + '}', String(params.releaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateReleaseResource');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateReleaseResource');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateReleaseResource');
            }
            // verify required parameter 'releaseId' is set
            if (params.releaseId == null) {
                throw new Error('Missing required parameter releaseId when calling updateReleaseResource');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateReleaseResource');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets a build report.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param type 
         */
        public getBuildReport (params: {  organization: string; project: string; buildId: number; apiVersion: string; type?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildReportMetadata> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/report'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildReport');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildReport');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildReport');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildReport');
            }
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportingWorkItemLinksApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a batch of work item links
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param linkTypes A list of types to filter the results to specific link types. Omit this parameter to get work item links of all link types.
         * @param types A list of types to filter the results to specific work item types. Omit this parameter to get work item links of all work item types.
         * @param continuationToken Specifies the continuationToken to start the batch from. Omit this parameter to get the first batch of links.
         * @param startDateTime Date/time to use as a starting point for link changes. Only link changes that occurred after that date/time will be returned. Cannot be used in conjunction with &#39;watermark&#39; parameter.
         */
        public getReportingLinksByLinkType (params: {  organization: string; project: string; apiVersion: string; linkTypes?: string; types?: string; continuationToken?: string; startDateTime?: Date; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReportingWorkItemLinksBatch> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/reporting/workitemlinks'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getReportingLinksByLinkType');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getReportingLinksByLinkType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getReportingLinksByLinkType');
            }
            if (params.linkTypes !== undefined) {
                queryParameters['linkTypes'] = params.linkTypes;
            }

            if (params.types !== undefined) {
                queryParameters['types'] = params.types;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.startDateTime !== undefined) {
                queryParameters['startDateTime'] = params.startDateTime;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ReportingWorkItemRevisionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a batch of work item revisions with the option of including deleted items
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param fields A list of fields to return in work item revisions. Omit this parameter to get all reportable fields.
         * @param types A list of types to filter the results to specific work item types. Omit this parameter to get work item revisions of all work item types.
         * @param continuationToken Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
         * @param startDateTime Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with &#39;watermark&#39; parameter.
         * @param includeIdentityRef Return an identity reference instead of a string value for identity fields.
         * @param includeDeleted Specify if the deleted item should be returned.
         * @param includeTagRef Specify if the tag objects should be returned for System.Tags field.
         * @param includeLatestOnly Return only the latest revisions of work items, skipping all historical revisions
         * @param $Expand Return all the fields in work item revisions, including long text fields which are not returned by default
         * @param includeDiscussionChangesOnly Return only the those revisions of work items, where only history field was changed
         * @param $MaxPageSize The maximum number of results to return in this batch
         */
        public readReportingRevisionsGet (params: {  organization: string; project: string; apiVersion: string; fields?: string; types?: string; continuationToken?: string; startDateTime?: Date; includeIdentityRef?: boolean; includeDeleted?: boolean; includeTagRef?: boolean; includeLatestOnly?: boolean; $Expand?: string; includeDiscussionChangesOnly?: boolean; $MaxPageSize?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReportingWorkItemRevisionsBatch> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/reporting/workitemrevisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling readReportingRevisionsGet');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling readReportingRevisionsGet');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling readReportingRevisionsGet');
            }
            if (params.fields !== undefined) {
                queryParameters['fields'] = params.fields;
            }

            if (params.types !== undefined) {
                queryParameters['types'] = params.types;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.startDateTime !== undefined) {
                queryParameters['startDateTime'] = params.startDateTime;
            }

            if (params.includeIdentityRef !== undefined) {
                queryParameters['includeIdentityRef'] = params.includeIdentityRef;
            }

            if (params.includeDeleted !== undefined) {
                queryParameters['includeDeleted'] = params.includeDeleted;
            }

            if (params.includeTagRef !== undefined) {
                queryParameters['includeTagRef'] = params.includeTagRef;
            }

            if (params.includeLatestOnly !== undefined) {
                queryParameters['includeLatestOnly'] = params.includeLatestOnly;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.includeDiscussionChangesOnly !== undefined) {
                queryParameters['includeDiscussionChangesOnly'] = params.includeDiscussionChangesOnly;
            }

            if (params.$MaxPageSize !== undefined) {
                queryParameters['$maxPageSize'] = params.$MaxPageSize;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a batch of work item revisions. This request may be used if your list of fields is large enough that it may run the URL over the length limit.
         * @param organization The name of the Azure DevOps organization.
         * @param body An object that contains request settings: field filter, type filter, identity format
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param continuationToken Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
         * @param startDateTime Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with &#39;watermark&#39; parameter.
         * @param $Expand 
         */
        public readReportingRevisionsPost (params: {  organization: string; body: ReportingWorkItemRevisionsFilter; project: string; apiVersion: string; continuationToken?: string; startDateTime?: Date; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ReportingWorkItemRevisionsBatch> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/reporting/workitemrevisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling readReportingRevisionsPost');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling readReportingRevisionsPost');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling readReportingRevisionsPost');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling readReportingRevisionsPost');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.startDateTime !== undefined) {
                queryParameters['startDateTime'] = params.startDateTime;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RepositoriesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a git repository in a team project.
         * @param organization The name of the Azure DevOps organization.
         * @param body Specify the repo name, team project and/or parent repository. Team project information can be ommitted from gitRepositoryToCreate if the request is project-scoped (i.e., includes project Id).
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param sourceRef [optional] Specify the source refs to use while creating a fork repo
         */
        public createRepository (params: {  organization: string; body: GitRepositoryCreateOptions; project: string; apiVersion: string; sourceRef?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRepository> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRepository');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRepository');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createRepository');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRepository');
            }
            if (params.sourceRef !== undefined) {
                queryParameters['sourceRef'] = params.sourceRef;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a git repository
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteRepository (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteRepository');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deleteRepository');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteRepository');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteRepository');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Destroy (hard delete) a soft-deleted Git repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId The ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteRepositoryFromRecycleBin (params: {  organization: string; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteRepositoryFromRecycleBin');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteRepositoryFromRecycleBin');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling deleteRepositoryFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteRepositoryFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve deleted git repositories.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getDeletedRepositories (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitDeletedRepository>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/deletedrepositories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeletedRepositories');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeletedRepositories');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeletedRepositories');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve soft-deleted git repositories from the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRecycleBinRepositories (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitDeletedRepository>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/recycleBin/repositories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRecycleBinRepositories');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRecycleBinRepositories');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRecycleBinRepositories');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve git repositories.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param includeLinks [optional] True to include reference links. The default value is false.
         * @param includeAllUrls [optional] True to include all remote URLs. The default value is false.
         * @param includeHidden [optional] True to include hidden repositories. The default value is false.
         */
        public getRepositories (params: {  organization: string; project: string; apiVersion: string; includeLinks?: boolean; includeAllUrls?: boolean; includeHidden?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitRepository>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRepositories');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRepositories');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRepositories');
            }
            if (params.includeLinks !== undefined) {
                queryParameters['includeLinks'] = params.includeLinks;
            }

            if (params.includeAllUrls !== undefined) {
                queryParameters['includeAllUrls'] = params.includeAllUrls;
            }

            if (params.includeHidden !== undefined) {
                queryParameters['includeHidden'] = params.includeHidden;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve a git repository.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRepository (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRepository> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRepository');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getRepository');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRepository');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRepository');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Recover a soft-deleted Git repository. Recently deleted repositories go into a soft-delete state for a period of time before they are hard deleted and become unrecoverable.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param repositoryId The ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restoreRepositoryFromRecycleBin (params: {  organization: string; body: GitRecycleBinRepositoryDetails; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRepository> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/recycleBin/repositories/{repositoryId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restoreRepositoryFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restoreRepositoryFromRecycleBin');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling restoreRepositoryFromRecycleBin');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling restoreRepositoryFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restoreRepositoryFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates the Git repository with either a new repo name or a new default branch.
         * @param organization The name of the Azure DevOps organization.
         * @param body Specify a new repo name or a new default branch of the repository
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateRepository (params: {  organization: string; body: GitRepository; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRepository> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRepository');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRepository');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling updateRepository');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateRepository');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRepository');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RequestsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a new symbol request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The symbol request to create.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createRequestsAsync (params: {  organization: string; body: Request; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Request> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRequestsAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRequestsAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRequestsAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create debug entries for a symbol request as specified by its identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param body A batch that contains debug entries to create.
         * @param requestId The symbol request identifier.
         * @param collection A valid debug entry collection name. Must be &quot;debugentries&quot;.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createRequestsRequestIdDebugEntriesAsync (params: {  organization: string; body: DebugEntryCreateBatch; requestId: string; collection: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DebugEntry>> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests/{requestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'requestId' + '}', String(params.requestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRequestsRequestIdDebugEntriesAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRequestsRequestIdDebugEntriesAsync');
            }
            // verify required parameter 'requestId' is set
            if (params.requestId == null) {
                throw new Error('Missing required parameter requestId when calling createRequestsRequestIdDebugEntriesAsync');
            }
            // verify required parameter 'collection' is set
            if (params.collection == null) {
                throw new Error('Missing required parameter collection when calling createRequestsRequestIdDebugEntriesAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRequestsRequestIdDebugEntriesAsync');
            }
            if (params.collection !== undefined) {
                queryParameters['collection'] = params.collection;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a symbol request by request identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param requestId The symbol request identifier.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param synchronous If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.
         */
        public deleteRequestsRequestIdAsync (params: {  organization: string; requestId: string; apiVersion: string; synchronous?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests/{requestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'requestId' + '}', String(params.requestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteRequestsRequestIdAsync');
            }
            // verify required parameter 'requestId' is set
            if (params.requestId == null) {
                throw new Error('Missing required parameter requestId when calling deleteRequestsRequestIdAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteRequestsRequestIdAsync');
            }
            if (params.synchronous !== undefined) {
                queryParameters['synchronous'] = params.synchronous;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a symbol request by request name.
         * @param organization The name of the Azure DevOps organization.
         * @param requestName The symbol request name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param synchronous If true, delete all the debug entries under this request synchronously in the current session. If false, the deletion will be postponed to a later point and be executed automatically by the system.
         */
        public deleteRequestsRequestNameAsync (params: {  organization: string; requestName: string; apiVersion: string; synchronous?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteRequestsRequestNameAsync');
            }
            // verify required parameter 'requestName' is set
            if (params.requestName == null) {
                throw new Error('Missing required parameter requestName when calling deleteRequestsRequestNameAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteRequestsRequestNameAsync');
            }
            if (params.requestName !== undefined) {
                queryParameters['requestName'] = params.requestName;
            }

            if (params.synchronous !== undefined) {
                queryParameters['synchronous'] = params.synchronous;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param agentCloudId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getAgentCloudRequests (params: {  organization: string; agentCloudId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TaskAgentCloudRequest>> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/agentclouds/{agentCloudId}/requests'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'agentCloudId' + '}', String(params.agentCloudId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAgentCloudRequests');
            }
            // verify required parameter 'agentCloudId' is set
            if (params.agentCloudId == null) {
                throw new Error('Missing required parameter agentCloudId when calling getAgentCloudRequests');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAgentCloudRequests');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a symbol request by request identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param requestId The symbol request identifier.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRequestsRequestIdAsync (params: {  organization: string; requestId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Request> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests/{requestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'requestId' + '}', String(params.requestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRequestsRequestIdAsync');
            }
            // verify required parameter 'requestId' is set
            if (params.requestId == null) {
                throw new Error('Missing required parameter requestId when calling getRequestsRequestIdAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRequestsRequestIdAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a symbol request by request name.
         * @param organization The name of the Azure DevOps organization.
         * @param requestName The symbol request name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRequestsRequestNameAsync (params: {  organization: string; requestName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Request> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRequestsRequestNameAsync');
            }
            // verify required parameter 'requestName' is set
            if (params.requestName == null) {
                throw new Error('Missing required parameter requestName when calling getRequestsRequestNameAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRequestsRequestNameAsync');
            }
            if (params.requestName !== undefined) {
                queryParameters['requestName'] = params.requestName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a symbol request by request identifier.
         * @param organization The name of the Azure DevOps organization.
         * @param body The symbol request.
         * @param requestId The symbol request identifier.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateRequestsRequestIdAsync (params: {  organization: string; body: Request; requestId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Request> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests/{requestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'requestId' + '}', String(params.requestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRequestsRequestIdAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRequestsRequestIdAsync');
            }
            // verify required parameter 'requestId' is set
            if (params.requestId == null) {
                throw new Error('Missing required parameter requestId when calling updateRequestsRequestIdAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRequestsRequestIdAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a symbol request by request name.
         * @param organization The name of the Azure DevOps organization.
         * @param body The symbol request.
         * @param requestName The symbol request name.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateRequestsRequestNameAsync (params: {  organization: string; body: Request; requestName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Request> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/requests'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateRequestsRequestNameAsync');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateRequestsRequestNameAsync');
            }
            // verify required parameter 'requestName' is set
            if (params.requestName == null) {
                throw new Error('Missing required parameter requestName when calling updateRequestsRequestNameAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateRequestsRequestNameAsync');
            }
            if (params.requestName !== undefined) {
                queryParameters['requestName'] = params.requestName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ResourceUsageApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets information about build resources in the system.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getResourceUsage (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildResourceUsage> {
            const localVarPath = this.basePath + '/{organization}/_apis/build/resourceusage'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getResourceUsage');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getResourceUsage');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ResourcesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param definitionId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public authorizeDefinitionResources (params: {  organization: string; body: Array<DefinitionResourceReference>; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DefinitionResourceReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/resources'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling authorizeDefinitionResources');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling authorizeDefinitionResources');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling authorizeDefinitionResources');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling authorizeDefinitionResources');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling authorizeDefinitionResources');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getDefinitionResources (params: {  organization: string; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DefinitionResourceReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{definitionId}/resources'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionResources');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionResources');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionResources');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionResources');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ResultRetentionSettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get test result retention settings
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getResultRetentionSettings (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ResultRetentionSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/resultretentionsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getResultRetentionSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getResultRetentionSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getResultRetentionSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update test result retention settings
         * @param organization The name of the Azure DevOps organization.
         * @param body Test result retention settings details to be updated
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateResultRetentionSettings (params: {  organization: string; body: ResultRetentionSettings; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ResultRetentionSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/resultretentionsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateResultRetentionSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateResultRetentionSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateResultRetentionSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateResultRetentionSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add test results to a test run.
         * @param organization The name of the Azure DevOps organization.
         * @param body List of test results to add.
         * @param project Project ID or project name
         * @param runId Test run ID into which test results to add.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.6&#39; to use this version of the api.
         */
        public addTestResultsToTestRun (params: {  organization: string; body: Array<TestCaseResult>; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCaseResult>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/results'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addTestResultsToTestRun');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addTestResultsToTestRun');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addTestResultsToTestRun');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling addTestResultsToTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addTestResultsToTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testRunId The test run identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getLoadTestResult (params: {  organization: string; testRunId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestResults> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testRuns/{testRunId}/results'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getLoadTestResult');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getLoadTestResult');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getLoadTestResult');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a test result for a test run.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId Test run ID of a test result to fetch.
         * @param testCaseResultId Test result ID.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.6&#39; to use this version of the api.
         * @param detailsToInclude Details to include with test results. Default is None. Other values are Iterations, WorkItems and SubResults.
         */
        public getTestResultById (params: {  organization: string; project: string; runId: number; testCaseResultId: number; apiVersion: string; detailsToInclude?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestCaseResult> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/results/{testCaseResultId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId))
                .replace('{' + 'testCaseResultId' + '}', String(params.testCaseResultId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestResultById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestResultById');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestResultById');
            }
            // verify required parameter 'testCaseResultId' is set
            if (params.testCaseResultId == null) {
                throw new Error('Missing required parameter testCaseResultId when calling getTestResultById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestResultById');
            }
            if (params.detailsToInclude !== undefined) {
                queryParameters['detailsToInclude'] = params.detailsToInclude;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get test results for a test run.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId Test run ID of test results to fetch.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.6&#39; to use this version of the api.
         * @param detailsToInclude Details to include with test results. Default is None. Other values are Iterations and WorkItems.
         * @param $Skip Number of test results to skip from beginning.
         * @param $Top Number of test results to return. Maximum is 1000 when detailsToInclude is None and 200 otherwise.
         * @param outcomes Comma separated list of test outcomes to filter test results.
         */
        public getTestResults (params: {  organization: string; project: string; runId: number; apiVersion: string; detailsToInclude?: string; $Skip?: number; $Top?: number; outcomes?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCaseResult>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/results'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestResults');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestResults');
            }
            if (params.detailsToInclude !== undefined) {
                queryParameters['detailsToInclude'] = params.detailsToInclude;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.outcomes !== undefined) {
                queryParameters['outcomes'] = params.outcomes;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update test results in a test run.
         * @param organization The name of the Azure DevOps organization.
         * @param body List of test results to update.
         * @param project Project ID or project name
         * @param runId Test run ID whose test results to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.6&#39; to use this version of the api.
         */
        public updateTestResults (params: {  organization: string; body: Array<TestCaseResult>; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCaseResult>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Runs/{runId}/results'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestResults');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestResults');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling updateTestResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestResults');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RetentionPoliciesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete the retention policy for a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteFeedRetentionPolicies (params: {  organization: string; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/retentionpolicies'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteFeedRetentionPolicies');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deleteFeedRetentionPolicies');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteFeedRetentionPolicies');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the retention policy for a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getFeedRetentionPolicies (params: {  organization: string; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedRetentionPolicy> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/retentionpolicies'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFeedRetentionPolicies');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getFeedRetentionPolicies');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFeedRetentionPolicies');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Set the retention policy for a feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Feed retention policy.
         * @param feedId Name or ID of the feed.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setFeedRetentionPolicies (params: {  organization: string; body: FeedRetentionPolicy; feedId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<FeedRetentionPolicy> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/Feeds/{feedId}/retentionpolicies'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setFeedRetentionPolicies');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setFeedRetentionPolicies');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling setFeedRetentionPolicies');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setFeedRetentionPolicies');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RevertsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Starts the operation to create a new branch which reverts changes introduced by either a specific commit or commits that are associated to a pull request.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param repositoryId ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createRevert (params: {  organization: string; body: GitAsyncRefOperationParameters; project: string; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRevert> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/reverts'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRevert');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRevert');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createRevert');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createRevert');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRevert');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve information about a revert operation by revert Id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param revertId ID of the revert operation.
         * @param repositoryId ID of the repository.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRevert (params: {  organization: string; project: string; revertId: number; repositoryId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRevert> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/reverts/{revertId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'revertId' + '}', String(params.revertId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRevert');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRevert');
            }
            // verify required parameter 'revertId' is set
            if (params.revertId == null) {
                throw new Error('Missing required parameter revertId when calling getRevert');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getRevert');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRevert');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve information about a revert operation for a specific branch.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param repositoryId ID of the repository.
         * @param refName The GitAsyncRefOperationParameters generatedRefName used for the revert operation.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getRevertForRefName (params: {  organization: string; project: string; repositoryId: string; refName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitRevert> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/reverts'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRevertForRefName');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRevertForRefName');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getRevertForRefName');
            }
            // verify required parameter 'refName' is set
            if (params.refName == null) {
                throw new Error('Missing required parameter refName when calling getRevertForRefName');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRevertForRefName');
            }
            if (params.refName !== undefined) {
                queryParameters['refName'] = params.refName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RevisionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve a specific revision of a given policy by ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param configurationId The policy configuration ID.
         * @param revisionId The revision ID.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPolicyConfigurationRevision (params: {  organization: string; project: string; configurationId: number; revisionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyConfiguration> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}/revisions/{revisionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId))
                .replace('{' + 'revisionId' + '}', String(params.revisionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyConfigurationRevision');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyConfigurationRevision');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling getPolicyConfigurationRevision');
            }
            // verify required parameter 'revisionId' is set
            if (params.revisionId == null) {
                throw new Error('Missing required parameter revisionId when calling getPolicyConfigurationRevision');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyConfigurationRevision');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all revisions for a given policy.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param configurationId The policy configuration ID.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Top The number of revisions to retrieve.
         * @param $Skip The number of revisions to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
         */
        public getPolicyConfigurationRevisions (params: {  organization: string; project: string; configurationId: number; apiVersion: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PolicyConfiguration>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/configurations/{configurationId}/revisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'configurationId' + '}', String(params.configurationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyConfigurationRevisions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyConfigurationRevisions');
            }
            // verify required parameter 'configurationId' is set
            if (params.configurationId == null) {
                throw new Error('Missing required parameter configurationId when calling getPolicyConfigurationRevisions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyConfigurationRevisions');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a fully hydrated work item for the requested revision
         * @param organization The name of the Azure DevOps organization.
         * @param id 
         * @param revisionNumber 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param $Expand 
         */
        public getRevision (params: {  organization: string; id: number; revisionNumber: number; project: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{id}/revisions/{revisionNumber}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'revisionNumber' + '}', String(params.revisionNumber))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRevision');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getRevision');
            }
            // verify required parameter 'revisionNumber' is set
            if (params.revisionNumber == null) {
                throw new Error('Missing required parameter revisionNumber when calling getRevision');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRevision');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRevision');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns the list of fully hydrated work item revisions, paged.
         * @param organization The name of the Azure DevOps organization.
         * @param id 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param $Top 
         * @param $Skip 
         * @param $Expand 
         */
        public getRevisions (params: {  organization: string; id: number; project: string; apiVersion: string; $Top?: number; $Skip?: number; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{id}/revisions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRevisions');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getRevisions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getRevisions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRevisions');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RevocationRulesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a revocation rule to prevent the further usage of any OAuth authorizations that were created before the current point in time and which match the conditions in the rule.  Not all kinds of OAuth authorizations can be revoked directly. Some, such as self-describing session tokens, must instead by revoked by creating a rule which will be evaluated and used to reject matching OAuth credentials at authentication time. Revocation rules created through this endpoint will apply to all credentials that were issued before the datetime at which the rule was created and which match one or more additional conditions.
         * @param organization The name of the Azure DevOps organization.
         * @param body The revocation rule to create. The rule must specify a space-separated list of scopes, after which preexisting OAuth authorizations that match that any of the scopes will be rejected. For a list of all OAuth scopes supported by VSTS, see: https://docs.microsoft.com/en-us/vsts/integrate/get-started/authentication/oauth?view&#x3D;vsts#scopes The rule may also specify the time before which to revoke tokens.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createRevocationRule (params: {  organization: string; body: TokenAdminRevocationRule; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/tokenadmin/revocationrules'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createRevocationRule');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createRevocationRule');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createRevocationRule');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RevocationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Revokes the listed OAuth authorizations.
         * @param organization The name of the Azure DevOps organization.
         * @param body The list of objects containing the authorization IDs of the OAuth authorizations, such as session tokens retrieved by listed a users PATs, that should be revoked.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param isPublic Set to false for PAT tokens and true for SSH tokens.
         */
        public revokeAuthorizations (params: {  organization: string; body: Array<TokenAdminRevocation>; apiVersion: string; isPublic?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/tokenadmin/revocations'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling revokeAuthorizations');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling revokeAuthorizations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling revokeAuthorizations');
            }
            if (params.isPublic !== undefined) {
                queryParameters['isPublic'] = params.isPublic;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RowsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get rows on a board
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param board Name or ID of the specific board
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBoardRows (params: {  organization: string; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardRow>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/rows'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBoardRows');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBoardRows');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling getBoardRows');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getBoardRows');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBoardRows');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update rows on a board
         * @param organization The name of the Azure DevOps organization.
         * @param body List of board rows to update
         * @param project Project ID or project name
         * @param board Name or ID of the specific board
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBoardRows (params: {  organization: string; body: Array<BoardRow>; project: string; board: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BoardRow>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/boards/{board}/rows'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'board' + '}', String(params.board))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBoardRows');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBoardRows');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBoardRows');
            }
            // verify required parameter 'board' is set
            if (params.board == null) {
                throw new Error('Missing required parameter board when calling updateBoardRows');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateBoardRows');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBoardRows');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RulesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a rule to work item type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addProcessWorkItemTypeRule (params: {  organization: string; body: CreateProcessRuleRequest; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessRule> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/rules'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addProcessWorkItemTypeRule');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addProcessWorkItemTypeRule');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addProcessWorkItemTypeRule');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling addProcessWorkItemTypeRule');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addProcessWorkItemTypeRule');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a rule from the work item type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param ruleId The ID of the rule
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteProcessWorkItemTypeRule (params: {  organization: string; processId: string; witRefName: string; ruleId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/rules/{ruleId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteProcessWorkItemTypeRule');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteProcessWorkItemTypeRule');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling deleteProcessWorkItemTypeRule');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling deleteProcessWorkItemTypeRule');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteProcessWorkItemTypeRule');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single rule in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param ruleId The ID of the rule
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getProcessWorkItemTypeRule (params: {  organization: string; processId: string; witRefName: string; ruleId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessRule> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/rules/{ruleId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessWorkItemTypeRule');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessWorkItemTypeRule');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getProcessWorkItemTypeRule');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling getProcessWorkItemTypeRule');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessWorkItemTypeRule');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all rules in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getProcessWorkItemTypeRules (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProcessRule>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/rules'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessWorkItemTypeRules');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessWorkItemTypeRules');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getProcessWorkItemTypeRules');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessWorkItemTypeRules');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a rule in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param ruleId The ID of the rule
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateProcessWorkItemTypeRule (params: {  organization: string; body: UpdateProcessRuleRequest; processId: string; witRefName: string; ruleId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessRule> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/rules/{ruleId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'ruleId' + '}', String(params.ruleId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateProcessWorkItemTypeRule');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateProcessWorkItemTypeRule');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateProcessWorkItemTypeRule');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateProcessWorkItemTypeRule');
            }
            // verify required parameter 'ruleId' is set
            if (params.ruleId == null) {
                throw new Error('Missing required parameter ruleId when calling updateProcessWorkItemTypeRule');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateProcessWorkItemTypeRule');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class RunsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create new test run.
         * @param organization The name of the Azure DevOps organization.
         * @param body Run details RunCreateModel
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public createTestRun (params: {  organization: string; body: RunCreateModel; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRun> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestRun');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestRun');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a test run by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the run to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public deleteTestRun (params: {  organization: string; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs/{runId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestRun');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestRun');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling deleteTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a test run by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the run to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param includeDetails Defualt value is true. It includes details like run statistics,release,build,Test enviornment,Post process state and more
         */
        public getTestRunById (params: {  organization: string; project: string; runId: number; apiVersion: string; includeDetails?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRun> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs/{runId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRunById');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestRunById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunById');
            }
            if (params.includeDetails !== undefined) {
                queryParameters['includeDetails'] = params.includeDetails;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get test run statistics
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param runId ID of the run to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getTestRunStatistics (params: {  organization: string; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRunStatistic> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs/{runId}/Statistics'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRunStatistics');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRunStatistics');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling getTestRunStatistics');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRunStatistics');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test runs.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param buildUri URI of the build that the runs used.
         * @param owner Team foundation ID of the owner of the runs.
         * @param tmiRunId 
         * @param planId ID of the test plan that the runs are a part of.
         * @param includeRunDetails If true, include all the properties of the runs.
         * @param automated If true, only returns automated runs.
         * @param $Skip Number of test runs to skip.
         * @param $Top Number of test runs to return.
         */
        public getTestRuns (params: {  organization: string; project: string; apiVersion: string; buildUri?: string; owner?: string; tmiRunId?: string; planId?: number; includeRunDetails?: boolean; automated?: boolean; $Skip?: number; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestRun>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRuns');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestRuns');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRuns');
            }
            if (params.buildUri !== undefined) {
                queryParameters['buildUri'] = params.buildUri;
            }

            if (params.owner !== undefined) {
                queryParameters['owner'] = params.owner;
            }

            if (params.tmiRunId !== undefined) {
                queryParameters['tmiRunId'] = params.tmiRunId;
            }

            if (params.planId !== undefined) {
                queryParameters['planId'] = params.planId;
            }

            if (params.includeRunDetails !== undefined) {
                queryParameters['includeRunDetails'] = params.includeRunDetails;
            }

            if (params.automated !== undefined) {
                queryParameters['automated'] = params.automated;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update test run by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param body Run details RunUpdateModel
         * @param project Project ID or project name
         * @param runId ID of the run to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public updateTestRun (params: {  organization: string; body: RunUpdateModel; project: string; runId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRun> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/runs/{runId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'runId' + '}', String(params.runId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestRun');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestRun');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestRun');
            }
            // verify required parameter 'runId' is set
            if (params.runId == null) {
                throw new Error('Missing required parameter runId when calling updateTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SecurityNamespacesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * List all security namespaces or just the specified namespace.
         * @param organization The name of the Azure DevOps organization.
         * @param securityNamespaceId Security namespace identifier.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param localOnly If true, retrieve only local security namespaces.
         */
        public querySecurityNamespaces (params: {  organization: string; securityNamespaceId: string; apiVersion: string; localOnly?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SecurityNamespaceDescription>> {
            const localVarPath = this.basePath + '/{organization}/_apis/securitynamespaces/{securityNamespaceId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'securityNamespaceId' + '}', String(params.securityNamespaceId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling querySecurityNamespaces');
            }
            // verify required parameter 'securityNamespaceId' is set
            if (params.securityNamespaceId == null) {
                throw new Error('Missing required parameter securityNamespaceId when calling querySecurityNamespaces');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling querySecurityNamespaces');
            }
            if (params.localOnly !== undefined) {
                queryParameters['localOnly'] = params.localOnly;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ServiceSettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get all service-wide feed creation and administration permissions.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getGlobalPermissions (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GlobalPermission>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/globalpermissions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getGlobalPermissions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getGlobalPermissions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Set service-wide permissions that govern feed creation and administration.
         * @param organization The name of the Azure DevOps organization.
         * @param body New permissions for the organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public setGlobalPermissions (params: {  organization: string; body: Array<GlobalPermission>; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GlobalPermission>> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/globalpermissions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling setGlobalPermissions');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling setGlobalPermissions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling setGlobalPermissions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SessionApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a test session
         * @param organization The name of the Azure DevOps organization.
         * @param body Test session details for creation
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestSession (params: {  organization: string; body: TestSession; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestSession> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/test/session'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestSession');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestSession');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestSession');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling createTestSession');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestSession');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test sessions
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param period Period in days from now, for which test sessions are fetched.
         * @param allSessions If false, returns test sessions for current user. Otherwise, it returns test sessions for all users
         * @param includeAllProperties If true, it returns all properties of the test sessions. Otherwise, it returns the skinny version.
         * @param source Source of the test session.
         * @param includeOnlyCompletedSessions If true, it returns test sessions in completed state. Otherwise, it returns test sessions for all states
         */
        public getTestSessions (params: {  organization: string; project: string; team: string; apiVersion: string; period?: number; allSessions?: boolean; includeAllProperties?: boolean; source?: string; includeOnlyCompletedSessions?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestSession>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/test/session'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestSessions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestSessions');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTestSessions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestSessions');
            }
            if (params.period !== undefined) {
                queryParameters['period'] = params.period;
            }

            if (params.allSessions !== undefined) {
                queryParameters['allSessions'] = params.allSessions;
            }

            if (params.includeAllProperties !== undefined) {
                queryParameters['includeAllProperties'] = params.includeAllProperties;
            }

            if (params.source !== undefined) {
                queryParameters['source'] = params.source;
            }

            if (params.includeOnlyCompletedSessions !== undefined) {
                queryParameters['includeOnlyCompletedSessions'] = params.includeOnlyCompletedSessions;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a test session
         * @param organization The name of the Azure DevOps organization.
         * @param body Test session details for update
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestSession (params: {  organization: string; body: TestSession; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestSession> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/test/session'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestSession');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestSession');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestSession');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateTestSession');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestSession');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the build settings.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBuildSettings (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/settings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSettings (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationAdminSettings> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/settings'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates the build settings.
         * @param organization The name of the Azure DevOps organization.
         * @param body The new settings.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBuildSettings (params: {  organization: string; body: BuildSettings; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildSettings> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/settings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBuildSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBuildSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateBuildSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBuildSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param body 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSettings (params: {  body: NotificationAdminSettingsUpdateParameters; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationAdminSettings> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/settings'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSettings');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class ShelvesetsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a single deep shelveset.
         * @param organization The name of the Azure DevOps organization.
         * @param shelvesetId Shelveset&#39;s unique ID
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param requestDataIncludeLinks Whether to include the _links field on the shallow references. Does not apply when requesting a single deep shelveset object. Links will always be included in the deep shelveset.
         * @param requestDataIncludeWorkItems Whether to include workItems
         * @param requestDataIncludeDetails Whether to include policyOverride and notes Only applies when requesting a single deep shelveset
         * @param requestDataMaxChangeCount Max number of changes to include
         * @param requestDataMaxCommentLength Max length of comment
         * @param requestDataOwner Owner&#39;s ID. Could be a name or a guid.
         * @param requestDataName Shelveset&#39;s name
         */
        public getShelveset (params: {  organization: string; shelvesetId: string; apiVersion: string; requestDataIncludeLinks?: boolean; requestDataIncludeWorkItems?: boolean; requestDataIncludeDetails?: boolean; requestDataMaxChangeCount?: number; requestDataMaxCommentLength?: number; requestDataOwner?: string; requestDataName?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TfvcShelveset> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/shelvesets'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getShelveset');
            }
            // verify required parameter 'shelvesetId' is set
            if (params.shelvesetId == null) {
                throw new Error('Missing required parameter shelvesetId when calling getShelveset');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getShelveset');
            }
            if (params.shelvesetId !== undefined) {
                queryParameters['shelvesetId'] = params.shelvesetId;
            }

            if (params.requestDataIncludeLinks !== undefined) {
                queryParameters['requestData.includeLinks'] = params.requestDataIncludeLinks;
            }

            if (params.requestDataIncludeWorkItems !== undefined) {
                queryParameters['requestData.includeWorkItems'] = params.requestDataIncludeWorkItems;
            }

            if (params.requestDataIncludeDetails !== undefined) {
                queryParameters['requestData.includeDetails'] = params.requestDataIncludeDetails;
            }

            if (params.requestDataMaxChangeCount !== undefined) {
                queryParameters['requestData.maxChangeCount'] = params.requestDataMaxChangeCount;
            }

            if (params.requestDataMaxCommentLength !== undefined) {
                queryParameters['requestData.maxCommentLength'] = params.requestDataMaxCommentLength;
            }

            if (params.requestDataOwner !== undefined) {
                queryParameters['requestData.owner'] = params.requestDataOwner;
            }

            if (params.requestDataName !== undefined) {
                queryParameters['requestData.name'] = params.requestDataName;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get changes included in a shelveset.
         * @param organization The name of the Azure DevOps organization.
         * @param shelvesetId Shelveset&#39;s unique ID
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Top Max number of changes to return
         * @param $Skip Number of changes to skip
         */
        public getShelvesetChanges (params: {  organization: string; shelvesetId: string; apiVersion: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TfvcChange>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/shelvesets/changes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getShelvesetChanges');
            }
            // verify required parameter 'shelvesetId' is set
            if (params.shelvesetId == null) {
                throw new Error('Missing required parameter shelvesetId when calling getShelvesetChanges');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getShelvesetChanges');
            }
            if (params.shelvesetId !== undefined) {
                queryParameters['shelvesetId'] = params.shelvesetId;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get work items associated with a shelveset.
         * @param organization The name of the Azure DevOps organization.
         * @param shelvesetId Shelveset&#39;s unique ID
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getShelvesetWorkItems (params: {  organization: string; shelvesetId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<AssociatedWorkItem>> {
            const localVarPath = this.basePath + '/{organization}/_apis/tfvc/shelvesets/workitems'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getShelvesetWorkItems');
            }
            // verify required parameter 'shelvesetId' is set
            if (params.shelvesetId == null) {
                throw new Error('Missing required parameter shelvesetId when calling getShelvesetWorkItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getShelvesetWorkItems');
            }
            if (params.shelvesetId !== undefined) {
                queryParameters['shelvesetId'] = params.shelvesetId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SourceProvidersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the contents of a file in the given source code repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
         * @param commitOrBranch The identifier of the commit or branch from which a file&#39;s contents are retrieved.
         * @param path The path to the file to retrieve, relative to the root of the repository.
         */
        public getFileContents (params: {  organization: string; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; commitOrBranch?: string; path?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/filecontents'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getFileContents');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getFileContents');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling getFileContents');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getFileContents');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.commitOrBranch !== undefined) {
                queryParameters['commitOrBranch'] = params.commitOrBranch;
            }

            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the contents of a directory in the given source code repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
         * @param commitOrBranch The identifier of the commit or branch from which a file&#39;s contents are retrieved.
         * @param path The path contents to list, relative to the root of the repository.
         */
        public getPathContents (params: {  organization: string; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; commitOrBranch?: string; path?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SourceRepositoryItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/pathcontents'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPathContents');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPathContents');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling getPathContents');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPathContents');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.commitOrBranch !== undefined) {
                queryParameters['commitOrBranch'] = params.commitOrBranch;
            }

            if (params.path !== undefined) {
                queryParameters['path'] = params.path;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a pull request object from source provider.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param pullRequestId Vendor-specific id of the pull request.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param repositoryId Vendor-specific identifier or the name of the repository that contains the pull request.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         */
        public getPullRequest (params: {  organization: string; project: string; providerName: string; pullRequestId: string; apiVersion: string; repositoryId?: string; serviceEndpointId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PullRequest> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/pullrequests/{pullRequestId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName))
                .replace('{' + 'pullRequestId' + '}', String(params.pullRequestId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPullRequest');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPullRequest');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling getPullRequest');
            }
            // verify required parameter 'pullRequestId' is set
            if (params.pullRequestId == null) {
                throw new Error('Missing required parameter pullRequestId when calling getPullRequest');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPullRequest');
            }
            if (params.repositoryId !== undefined) {
                queryParameters['repositoryId'] = params.repositoryId;
            }

            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of branches for the given source code repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
         */
        public listBranches (params: {  organization: string; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/branches'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listBranches');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling listBranches');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling listBranches');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listBranches');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of source code repositories.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of a single repository to get.
         * @param resultSet &#39;top&#39; for the repositories most relevant for the endpoint. If not set, all repositories are returned. Ignored if &#39;repository&#39; is set.
         * @param pageResults If set to true, this will limit the set of results and will return a continuation token to continue the query.
         * @param continuationToken When paging results, this is a continuation token, returned by a previous call to this method, that can be used to return the next set of repositories.
         */
        public listRepositories (params: {  organization: string; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; resultSet?: string; pageResults?: boolean; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SourceRepositories> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/repositories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listRepositories');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling listRepositories');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling listRepositories');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listRepositories');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.resultSet !== undefined) {
                queryParameters['resultSet'] = params.resultSet;
            }

            if (params.pageResults !== undefined) {
                queryParameters['pageResults'] = params.pageResults;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of source providers and their capabilities.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public listSourceProviders (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SourceProviderAttributes>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceproviders'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listSourceProviders');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling listSourceProviders');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listSourceProviders');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of webhooks installed in the given source code repository.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
         */
        public listWebhooks (params: {  organization: string; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<RepositoryWebhook>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/webhooks'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listWebhooks');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling listWebhooks');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling listWebhooks');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listWebhooks');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Recreates the webhooks for the specified triggers in the given source code repository.
         * @param organization The name of the Azure DevOps organization.
         * @param body The types of triggers to restore webhooks for.
         * @param project Project ID or project name
         * @param providerName The name of the source provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param serviceEndpointId If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
         * @param repository If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
         */
        public restoreWebhooks (params: {  organization: string; body: Array<string>; project: string; providerName: string; apiVersion: string; serviceEndpointId?: string; repository?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/sourceProviders/{providerName}/webhooks'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'providerName' + '}', String(params.providerName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restoreWebhooks');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restoreWebhooks');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling restoreWebhooks');
            }
            // verify required parameter 'providerName' is set
            if (params.providerName == null) {
                throw new Error('Missing required parameter providerName when calling restoreWebhooks');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restoreWebhooks');
            }
            if (params.serviceEndpointId !== undefined) {
                queryParameters['serviceEndpointId'] = params.serviceEndpointId;
            }

            if (params.repository !== undefined) {
                queryParameters['repository'] = params.repository;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createStateDefinition (params: {  organization: string; body: WorkItemStateInputModel; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createStateDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createStateDefinition');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createStateDefinition');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling createStateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createStateDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createStateDefinition_1 (params: {  organization: string; body: WorkItemStateInputModel; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createStateDefinition_1');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createStateDefinition_1');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createStateDefinition_1');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling createStateDefinition_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createStateDefinition_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteStateDefinition (params: {  organization: string; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteStateDefinition');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteStateDefinition');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling deleteStateDefinition');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling deleteStateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteStateDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteStateDefinition_2 (params: {  organization: string; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteStateDefinition_2');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteStateDefinition_2');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling deleteStateDefinition_2');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling deleteStateDefinition_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteStateDefinition_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId The ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getStateDefinition (params: {  organization: string; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStateDefinition');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getStateDefinition');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getStateDefinition');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling getStateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStateDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single state definition in a work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId The ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getStateDefinition_3 (params: {  organization: string; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStateDefinition_3');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getStateDefinition_3');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getStateDefinition_3');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling getStateDefinition_3');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStateDefinition_3');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all state definitions in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getStateDefinitions (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemStateResultModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStateDefinitions');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getStateDefinitions');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getStateDefinitions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStateDefinitions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all state definitions in a work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getStateDefinitions_4 (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemStateResultModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStateDefinitions_4');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getStateDefinitions_4');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getStateDefinitions_4');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStateDefinitions_4');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Hides a state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId The ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public hideStateDefinition (params: {  organization: string; body: HideStateModel; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling hideStateDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling hideStateDefinition');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling hideStateDefinition');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling hideStateDefinition');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling hideStateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling hideStateDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Hides a state definition in the work item type of the process.Only states with customizationType:System can be hidden.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId The ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public hideStateDefinition_5 (params: {  organization: string; body: HideStateModel; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling hideStateDefinition_5');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling hideStateDefinition_5');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling hideStateDefinition_5');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling hideStateDefinition_5');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling hideStateDefinition_5');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling hideStateDefinition_5');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a given state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateStateDefinition (params: {  organization: string; body: WorkItemStateInputModel; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateStateDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateStateDefinition');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateStateDefinition');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateStateDefinition');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling updateStateDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateStateDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a given state definition in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId ID of the process
         * @param witRefName The reference name of the work item type
         * @param stateId ID of the state
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateStateDefinition_6 (params: {  organization: string; body: WorkItemStateInputModel; processId: string; witRefName: string; stateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemStateResultModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workItemTypes/{witRefName}/states/{stateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName))
                .replace('{' + 'stateId' + '}', String(params.stateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateStateDefinition_6');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateStateDefinition_6');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateStateDefinition_6');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateStateDefinition_6');
            }
            // verify required parameter 'stateId' is set
            if (params.stateId == null) {
                throw new Error('Missing required parameter stateId when calling updateStateDefinition_6');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateStateDefinition_6');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve statistics about all branches within a repository.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId The name or ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param baseVersionDescriptorVersionOptions Version options - Specify additional modifiers to version (e.g Previous)
         * @param baseVersionDescriptorVersion Version string identifier (name of tag/branch, SHA1 of commit)
         * @param baseVersionDescriptorVersionType Version type (branch, tag, or commit). Determines how Id is interpreted
         */
        public getBranches (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; baseVersionDescriptorVersionOptions?: string; baseVersionDescriptorVersion?: string; baseVersionDescriptorVersionType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitBranchStats>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/stats/branches'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBranches');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getBranches');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBranches');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBranches');
            }
            if (params.baseVersionDescriptorVersionOptions !== undefined) {
                queryParameters['baseVersionDescriptor.versionOptions'] = params.baseVersionDescriptorVersionOptions;
            }

            if (params.baseVersionDescriptorVersion !== undefined) {
                queryParameters['baseVersionDescriptor.version'] = params.baseVersionDescriptorVersion;
            }

            if (params.baseVersionDescriptorVersionType !== undefined) {
                queryParameters['baseVersionDescriptor.versionType'] = params.baseVersionDescriptorVersionType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatusApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * &lt;p&gt;Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and configuration.&lt;/p&gt; &lt;p&gt;If there are more than one, then it is required to pass in a stageName value when specifying a jobName, and the same rule then applies for both if passing a configuration parameter.&lt;/p&gt;
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definition Either the definition name with optional leading folder path, or the definition id.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param branchName Only consider the most recent build for this branch.
         * @param stageName Use this stage within the pipeline to render the status.
         * @param jobName Use this job within a stage of the pipeline to render the status.
         * @param configuration Use this job configuration to render the status
         * @param label Replaces the default text on the left side of the badge.
         */
        public getStatusBadge (params: {  organization: string; project: string; definition: string; apiVersion: string; branchName?: string; stageName?: string; jobName?: string; configuration?: string; label?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<string> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/status/{definition}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definition' + '}', String(params.definition));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStatusBadge');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getStatusBadge');
            }
            // verify required parameter 'definition' is set
            if (params.definition == null) {
                throw new Error('Missing required parameter definition when calling getStatusBadge');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStatusBadge');
            }
            if (params.branchName !== undefined) {
                queryParameters['branchName'] = params.branchName;
            }

            if (params.stageName !== undefined) {
                queryParameters['stageName'] = params.stageName;
            }

            if (params.jobName !== undefined) {
                queryParameters['jobName'] = params.jobName;
            }

            if (params.configuration !== undefined) {
                queryParameters['configuration'] = params.configuration;
            }

            if (params.label !== undefined) {
                queryParameters['label'] = params.label;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StatusesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create Git commit status.
         * @param organization The name of the Azure DevOps organization.
         * @param body Git commit status object to create.
         * @param commitId ID of the Git commit.
         * @param repositoryId ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createCommitStatus (params: {  organization: string; body: GitStatus; commitId: string; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitStatus> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'commitId' + '}', String(params.commitId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createCommitStatus');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createCommitStatus');
            }
            // verify required parameter 'commitId' is set
            if (params.commitId == null) {
                throw new Error('Missing required parameter commitId when calling createCommitStatus');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling createCommitStatus');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createCommitStatus');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createCommitStatus');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get statuses associated with the Git commit.
         * @param organization The name of the Azure DevOps organization.
         * @param commitId ID of the Git commit.
         * @param repositoryId ID of the repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param top Optional. The number of statuses to retrieve. Default is 1000.
         * @param skip Optional. The number of statuses to ignore. Default is 0. For example, to retrieve results 101-150, set top to 50 and skip to 100.
         * @param latestOnly The flag indicates whether to get only latest statuses grouped by &#x60;Context.Name&#x60; and &#x60;Context.Genre&#x60;.
         */
        public getStatuses (params: {  organization: string; commitId: string; repositoryId: string; project: string; apiVersion: string; top?: number; skip?: number; latestOnly?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitStatus>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/commits/{commitId}/statuses'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'commitId' + '}', String(params.commitId))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStatuses');
            }
            // verify required parameter 'commitId' is set
            if (params.commitId == null) {
                throw new Error('Missing required parameter commitId when calling getStatuses');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getStatuses');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getStatuses');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStatuses');
            }
            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.skip !== undefined) {
                queryParameters['skip'] = params.skip;
            }

            if (params.latestOnly !== undefined) {
                queryParameters['latestOnly'] = params.latestOnly;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class StorageKeysApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Resolve a descriptor to a storage key.
         * @param subjectDescriptor 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getStorageKey (params: {  subjectDescriptor: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphStorageKeyResult> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/storagekeys/{subjectDescriptor}'
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling getStorageKey');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getStorageKey');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getStorageKey');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SubjectLookupApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Resolve descriptors to users, groups or scopes (Subjects) in a batch.
         * @param organization The name of the Azure DevOps organization.
         * @param body A list of descriptors that specifies a subset of subjects to retrieve. Each descriptor uniquely identifies the subject across all instance scopes, but only at a single point in time.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public lookupSubjects (params: {  organization: string; body: GraphSubjectLookup; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{ [key: string]: GraphSubject; }> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/subjectlookup'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling lookupSubjects');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling lookupSubjects');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling lookupSubjects');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SubscribersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param subscriberId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSubscriber (params: {  subscriberId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationSubscriber> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscribers/{subscriberId}'
                .replace('{' + 'subscriberId' + '}', String(params.subscriberId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'subscriberId' is set
            if (params.subscriberId == null) {
                throw new Error('Missing required parameter subscriberId when calling getSubscriber');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscriber');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscriber');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param body 
         * @param subscriberId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSubscriber (params: {  body: NotificationSubscriberUpdateParameters; subscriberId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationSubscriber> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscribers/{subscriberId}'
                .replace('{' + 'subscriberId' + '}', String(params.subscriberId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSubscriber');
            }
            // verify required parameter 'subscriberId' is set
            if (params.subscriberId == null) {
                throw new Error('Missing required parameter subscriberId when calling updateSubscriber');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSubscriber');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSubscriber');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SubscriptionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a subscription.
         * @param organization The name of the Azure DevOps organization.
         * @param body Subscription to be created.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createSubscription (params: {  organization: string; body: Subscription; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Subscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createSubscription');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createSubscription');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createSubscription');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create a new subscription.
         * @param body 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createSubscription_1 (params: {  body: NotificationSubscriptionCreateParameters; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationSubscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createSubscription_1');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createSubscription_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createSubscription_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query for service hook subscriptions.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createSubscriptionsQuery (params: {  organization: string; body: SubscriptionsQuery; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionsQuery> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptionsquery'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createSubscriptionsQuery');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createSubscriptionsQuery');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createSubscriptionsQuery');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a specific service hooks subscription.
         * @param organization The name of the Azure DevOps organization.
         * @param subscriptionId ID for a subscription.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteSubscription (params: {  organization: string; subscriptionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteSubscription');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling deleteSubscription');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteSubscription');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a subscription.
         * @param subscriptionId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteSubscription_2 (params: {  subscriptionId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions/{subscriptionId}'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling deleteSubscription_2');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteSubscription_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteSubscription_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific service hooks subscription.
         * @param organization The name of the Azure DevOps organization.
         * @param subscriptionId ID for a subscription.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSubscription (params: {  organization: string; subscriptionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Subscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscription');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getSubscription');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscription');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get available subscription templates.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSubscriptionTemplates (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<NotificationSubscriptionTemplate>> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptiontemplates'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscriptionTemplates');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscriptionTemplates');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a notification subscription by its ID.
         * @param subscriptionId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param queryFlags 
         */
        public getSubscription_3 (params: {  subscriptionId: string; organization: string; apiVersion: string; queryFlags?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationSubscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions/{subscriptionId}'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling getSubscription_3');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSubscription_3');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSubscription_3');
            }
            if (params.queryFlags !== undefined) {
                queryParameters['queryFlags'] = params.queryFlags;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of subscriptions.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param publisherId ID for a subscription.
         * @param eventType Maximum number of notifications to return. Default is 100.
         * @param consumerId ID for a consumer.
         * @param consumerActionId ID for a consumerActionId.
         */
        public listSubscriptions (params: {  organization: string; apiVersion: string; publisherId?: string; eventType?: string; consumerId?: string; consumerActionId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Subscription>> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listSubscriptions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listSubscriptions');
            }
            if (params.publisherId !== undefined) {
                queryParameters['publisherId'] = params.publisherId;
            }

            if (params.eventType !== undefined) {
                queryParameters['eventType'] = params.eventType;
            }

            if (params.consumerId !== undefined) {
                queryParameters['consumerId'] = params.consumerId;
            }

            if (params.consumerActionId !== undefined) {
                queryParameters['consumerActionId'] = params.consumerActionId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param targetId 
         * @param ids 
         * @param queryFlags 
         */
        public listSubscriptions_4 (params: {  organization: string; apiVersion: string; targetId?: string; ids?: string; queryFlags?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<NotificationSubscription>> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listSubscriptions_4');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listSubscriptions_4');
            }
            if (params.targetId !== undefined) {
                queryParameters['targetId'] = params.targetId;
            }

            if (params.ids !== undefined) {
                queryParameters['ids'] = params.ids;
            }

            if (params.queryFlags !== undefined) {
                queryParameters['queryFlags'] = params.queryFlags;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Query for subscriptions. A subscription is returned if it matches one or more of the specified conditions.
         * @param body 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public querySubscriptions (params: {  body: SubscriptionQuery; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<NotificationSubscription>> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptionquery'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling querySubscriptions');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling querySubscriptions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling querySubscriptions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a subscription. &lt;param name&#x3D;&quot;subscriptionId&quot;&gt;ID for a subscription that you wish to update.&lt;/param&gt;
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param subscriptionId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public replaceSubscription (params: {  organization: string; body: Subscription; subscriptionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Subscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/hooks/subscriptions/{subscriptionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceSubscription');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceSubscription');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling replaceSubscription');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceSubscription');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update an existing subscription. Depending on the type of subscription and permissions, the caller can update the description, filter settings, channel (delivery) settings and more.
         * @param body 
         * @param subscriptionId 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSubscription (params: {  body: NotificationSubscriptionUpdateParameters; subscriptionId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<NotificationSubscription> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/subscriptions/{subscriptionId}'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSubscription');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling updateSubscription');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSubscription');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSubscription');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the specified user&#39;s settings for the specified subscription. This API is typically used to opt in or out of a shared subscription. User settings can only be applied to shared subscriptions, like team subscriptions or default subscriptions.
         * @param body 
         * @param subscriptionId 
         * @param userId ID of the user
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateSubscriptionUserSettings (params: {  body: SubscriptionUserSettings; subscriptionId: string; userId: string; organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SubscriptionUserSettings> {
            const localVarPath = this.basePath + '/{organization}/_apis/notification/Subscriptions/{subscriptionId}/usersettings/{userId}'
                .replace('{' + 'subscriptionId' + '}', String(params.subscriptionId))
                .replace('{' + 'userId' + '}', String(params.userId))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSubscriptionUserSettings');
            }
            // verify required parameter 'subscriptionId' is set
            if (params.subscriptionId == null) {
                throw new Error('Missing required parameter subscriptionId when calling updateSubscriptionUserSettings');
            }
            // verify required parameter 'userId' is set
            if (params.userId == null) {
                throw new Error('Missing required parameter userId when calling updateSubscriptionUserSettings');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSubscriptionUserSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSubscriptionUserSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SuggestionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve a pull request suggestion for a particular repository or team project.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId ID of the git repository.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSuggestions (params: {  organization: string; repositoryId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GitSuggestion>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/suggestions'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSuggestions');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getSuggestions');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getSuggestions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSuggestions');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SuiteTestCaseApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add test cases to a suite with specified configurations
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addTestCasesToSuite (params: {  organization: string; body: Array<SuiteTestCaseCreateUpdateParameters>; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestCase'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addTestCasesToSuite');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addTestCasesToSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addTestCasesToSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling addTestCasesToSuite');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling addTestCasesToSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addTestCasesToSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param testCaseIds 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param witFields 
         */
        public getTestCase (params: {  organization: string; project: string; planId: number; suiteId: number; testCaseIds: string; apiVersion: string; witFields?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestCase/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestCase');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestCase');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestCase');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getTestCase');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling getTestCase');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestCase');
            }
            if (params.witFields !== undefined) {
                queryParameters['witFields'] = params.witFields;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get Test Case List return those test cases which have all the configuration Ids as mentioned in the optional paramter. If configuration Ids is null, it return all the test cases
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param testIds 
         * @param configurationIds 
         * @param witFields 
         * @param continuationToken 
         */
        public getTestCaseList (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; testIds?: string; configurationIds?: string; witFields?: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestCase'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestCaseList');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestCaseList');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestCaseList');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getTestCaseList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestCaseList');
            }
            if (params.testIds !== undefined) {
                queryParameters['testIds'] = params.testIds;
            }

            if (params.configurationIds !== undefined) {
                queryParameters['configurationIds'] = params.configurationIds;
            }

            if (params.witFields !== undefined) {
                queryParameters['witFields'] = params.witFields;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes test cases from a suite based on the list of test case Ids provided.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param testCaseIds 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public removeTestCasesFromSuite (params: {  organization: string; project: string; planId: number; suiteId: number; testCaseIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestCase/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeTestCasesFromSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling removeTestCasesFromSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling removeTestCasesFromSuite');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling removeTestCasesFromSuite');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling removeTestCasesFromSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeTestCasesFromSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the configurations for test cases
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateSuiteTestCases (params: {  organization: string; body: Array<SuiteTestCaseCreateUpdateParameters>; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestCase'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSuiteTestCases');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSuiteTestCases');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateSuiteTestCases');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateSuiteTestCases');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling updateSuiteTestCases');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSuiteTestCases');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class SymsrvApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Given a client key, returns the best matched debug entry.
         * @param organization The name of the Azure DevOps organization.
         * @param debugEntryClientKey A &quot;client key&quot; used by both ends of Microsoft&#39;s symbol protocol to identify a debug entry. The semantics of client key is governed by symsrv and is beyond the scope of this documentation.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSymSrvDebugEntryClientKeyAsync (params: {  organization: string; debugEntryClientKey: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/symbol/symsrv/{debugEntryClientKey}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'debugEntryClientKey' + '}', String(params.debugEntryClientKey));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSymSrvDebugEntryClientKeyAsync');
            }
            // verify required parameter 'debugEntryClientKey' is set
            if (params.debugEntryClientKey == null) {
                throw new Error('Missing required parameter debugEntryClientKey when calling getSymSrvDebugEntryClientKeyAsync');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSymSrvDebugEntryClientKeyAsync');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TagsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a tag to a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param tag The tag to add.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addBuildTag (params: {  organization: string; project: string; buildId: number; tag: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'tag' + '}', String(params.tag));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addBuildTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addBuildTag');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling addBuildTag');
            }
            // verify required parameter 'tag' is set
            if (params.tag == null) {
                throw new Error('Missing required parameter tag when calling addBuildTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addBuildTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Adds tags to a build.
         * @param organization The name of the Azure DevOps organization.
         * @param body The tags to add.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addBuildTags (params: {  organization: string; body: Array<string>; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/tags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addBuildTags');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addBuildTags');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addBuildTags');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling addBuildTags');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addBuildTags');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Adds a tag to a definition
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param tag The tag to add.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addDefinitionTag (params: {  organization: string; project: string; definitionId: number; tag: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId))
                .replace('{' + 'tag' + '}', String(params.tag));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addDefinitionTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addDefinitionTag');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling addDefinitionTag');
            }
            // verify required parameter 'tag' is set
            if (params.tag == null) {
                throw new Error('Missing required parameter tag when calling addDefinitionTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addDefinitionTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Adds multiple tags to a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param body The tags to add.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addDefinitionTags (params: {  organization: string; body: Array<string>; project: string; definitionId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addDefinitionTags');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addDefinitionTags');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addDefinitionTags');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling addDefinitionTags');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addDefinitionTags');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a tag from a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param tag The tag to remove.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteBuildTag (params: {  organization: string; project: string; buildId: number; tag: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'tag' + '}', String(params.tag));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteBuildTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteBuildTag');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling deleteBuildTag');
            }
            // verify required parameter 'tag' is set
            if (params.tag == null) {
                throw new Error('Missing required parameter tag when calling deleteBuildTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteBuildTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a tag from a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param tag The tag to remove.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteDefinitionTag (params: {  organization: string; project: string; definitionId: number; tag: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId))
                .replace('{' + 'tag' + '}', String(params.tag));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteDefinitionTag');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteDefinitionTag');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling deleteDefinitionTag');
            }
            // verify required parameter 'tag' is set
            if (params.tag == null) {
                throw new Error('Missing required parameter tag when calling deleteDefinitionTag');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteDefinitionTag');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the tags for a build.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId The ID of the build.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getBuildTags (params: {  organization: string; project: string; buildId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/tags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildTags');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildTags');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildTags');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildTags');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the tags for a definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param definitionId The ID of the definition.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param revision The definition revision number. If not specified, uses the latest revision of the definition.
         */
        public getDefinitionTags (params: {  organization: string; project: string; definitionId: number; apiVersion: string; revision?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'definitionId' + '}', String(params.definitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDefinitionTags');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDefinitionTags');
            }
            // verify required parameter 'definitionId' is set
            if (params.definitionId == null) {
                throw new Error('Missing required parameter definitionId when calling getDefinitionTags');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDefinitionTags');
            }
            if (params.revision !== undefined) {
                queryParameters['revision'] = params.revision;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a list of all build and definition tags in the project.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getTags (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<string>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/tags'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTags');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTags');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTags');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TargetsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a deployment target in a deployment group. This deletes the agent from associated deployment pool too.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group in which deployment target is deleted.
         * @param targetId ID of the deployment target to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteDeploymentTarget (params: {  organization: string; project: string; deploymentGroupId: number; targetId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}/targets/{targetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId))
                .replace('{' + 'targetId' + '}', String(params.targetId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteDeploymentTarget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteDeploymentTarget');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling deleteDeploymentTarget');
            }
            // verify required parameter 'targetId' is set
            if (params.targetId == null) {
                throw new Error('Missing required parameter targetId when calling deleteDeploymentTarget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteDeploymentTarget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a deployment target by its ID in a deployment group
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group to which deployment target belongs.
         * @param targetId ID of the deployment target to return.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Expand Include these additional details in the returned objects.
         */
        public getDeploymentTarget (params: {  organization: string; project: string; deploymentGroupId: number; targetId: number; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<DeploymentMachine> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}/targets/{targetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId))
                .replace('{' + 'targetId' + '}', String(params.targetId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeploymentTarget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeploymentTarget');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling getDeploymentTarget');
            }
            // verify required parameter 'targetId' is set
            if (params.targetId == null) {
                throw new Error('Missing required parameter targetId when calling getDeploymentTarget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeploymentTarget');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of deployment targets in a deployment group.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param tags Get only the deployment targets that contain all these comma separted list of tags.
         * @param name Name pattern of the deployment targets to return.
         * @param partialNameMatch When set to true, treats **name** as pattern. Else treats it as absolute match. Default is **false**.
         * @param $Expand Include these additional details in the returned objects.
         * @param agentStatus Get only deployment targets that have this status.
         * @param agentJobResult Get only deployment targets that have this last job result.
         * @param continuationToken Get deployment targets with names greater than this continuationToken lexicographically.
         * @param $Top Maximum number of deployment targets to return. Default is **1000**.
         * @param enabled Get only deployment targets that are enabled or disabled. Default is &#39;null&#39; which returns all the targets.
         * @param propertyFilters 
         */
        public getDeploymentTargets (params: {  organization: string; project: string; deploymentGroupId: number; apiVersion: string; tags?: string; name?: string; partialNameMatch?: boolean; $Expand?: string; agentStatus?: string; agentJobResult?: string; continuationToken?: string; $Top?: number; enabled?: boolean; propertyFilters?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DeploymentMachine>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}/targets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getDeploymentTargets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getDeploymentTargets');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling getDeploymentTargets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getDeploymentTargets');
            }
            if (params.tags !== undefined) {
                queryParameters['tags'] = params.tags;
            }

            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.partialNameMatch !== undefined) {
                queryParameters['partialNameMatch'] = params.partialNameMatch;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.agentStatus !== undefined) {
                queryParameters['agentStatus'] = params.agentStatus;
            }

            if (params.agentJobResult !== undefined) {
                queryParameters['agentJobResult'] = params.agentJobResult;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.enabled !== undefined) {
                queryParameters['enabled'] = params.enabled;
            }

            if (params.propertyFilters !== undefined) {
                queryParameters['propertyFilters'] = params.propertyFilters;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update tags of a list of deployment targets in a deployment group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Deployment targets with tags to udpdate.
         * @param project Project ID or project name
         * @param deploymentGroupId ID of the deployment group in which deployment targets are updated.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateDeploymentTargets (params: {  organization: string; body: Array<DeploymentTargetUpdateParameter>; project: string; deploymentGroupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<DeploymentMachine>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/deploymentgroups/{deploymentGroupId}/targets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'deploymentGroupId' + '}', String(params.deploymentGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateDeploymentTargets');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateDeploymentTargets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateDeploymentTargets');
            }
            // verify required parameter 'deploymentGroupId' is set
            if (params.deploymentGroupId == null) {
                throw new Error('Missing required parameter deploymentGroupId when calling updateDeploymentTargets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateDeploymentTargets');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TaskgroupsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a task group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Task group object to create.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addTaskGroup (params: {  organization: string; body: TaskGroupCreateParameter; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TaskGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/taskgroups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addTaskGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addTaskGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addTaskGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addTaskGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a task group.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param taskGroupId Id of the task group to be deleted.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param comment Comments to delete.
         */
        public deleteTaskGroup (params: {  organization: string; project: string; taskGroupId: string; apiVersion: string; comment?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/taskgroups/{taskGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'taskGroupId' + '}', String(params.taskGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTaskGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTaskGroup');
            }
            // verify required parameter 'taskGroupId' is set
            if (params.taskGroupId == null) {
                throw new Error('Missing required parameter taskGroupId when calling deleteTaskGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTaskGroup');
            }
            if (params.comment !== undefined) {
                queryParameters['comment'] = params.comment;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * List task groups.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param taskGroupId Id of the task group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param expanded &#39;true&#39; to recursively expand task groups. Default is &#39;false&#39;.
         * @param taskIdFilter Guid of the taskId to filter.
         * @param deleted &#39;true&#39;to include deleted task groups. Default is &#39;false&#39;.
         * @param $Top Number of task groups to get.
         * @param continuationToken Gets the task groups after the continuation token provided.
         * @param queryOrder Gets the results in the defined order. Default is &#39;CreatedOnDescending&#39;.
         */
        public getTaskGroups (params: {  organization: string; project: string; taskGroupId: string; apiVersion: string; expanded?: boolean; taskIdFilter?: string; deleted?: boolean; $Top?: number; continuationToken?: Date; queryOrder?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TaskGroup>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/taskgroups/{taskGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'taskGroupId' + '}', String(params.taskGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTaskGroups');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTaskGroups');
            }
            // verify required parameter 'taskGroupId' is set
            if (params.taskGroupId == null) {
                throw new Error('Missing required parameter taskGroupId when calling getTaskGroups');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTaskGroups');
            }
            if (params.expanded !== undefined) {
                queryParameters['expanded'] = params.expanded;
            }

            if (params.taskIdFilter !== undefined) {
                queryParameters['taskIdFilter'] = params.taskIdFilter;
            }

            if (params.deleted !== undefined) {
                queryParameters['deleted'] = params.deleted;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.queryOrder !== undefined) {
                queryParameters['queryOrder'] = params.queryOrder;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a task group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Task group to update.
         * @param project Project ID or project name
         * @param taskGroupId Id of the task group to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTaskGroup (params: {  organization: string; body: TaskGroupUpdateParameter; project: string; taskGroupId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TaskGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/taskgroups/{taskGroupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'taskGroupId' + '}', String(params.taskGroupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTaskGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTaskGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTaskGroup');
            }
            // verify required parameter 'taskGroupId' is set
            if (params.taskGroupId == null) {
                throw new Error('Missing required parameter taskGroupId when calling updateTaskGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTaskGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamdaysoffApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get team&#39;s days off for an iteration
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTeamDaysOff (params: {  organization: string; project: string; iterationId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSettingsDaysOff> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/teamdaysoff'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamDaysOff');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTeamDaysOff');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling getTeamDaysOff');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTeamDaysOff');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamDaysOff');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Set a team&#39;s days off for an iteration
         * @param organization The name of the Azure DevOps organization.
         * @param body Team&#39;s days off patch containting a list of start and end dates
         * @param project Project ID or project name
         * @param iterationId ID of the iteration
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTeamDaysOff (params: {  organization: string; body: TeamSettingsDaysOffPatch; project: string; iterationId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSettingsDaysOff> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/iterations/{iterationId}/teamdaysoff'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'iterationId' + '}', String(params.iterationId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTeamDaysOff');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTeamDaysOff');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTeamDaysOff');
            }
            // verify required parameter 'iterationId' is set
            if (params.iterationId == null) {
                throw new Error('Missing required parameter iterationId when calling updateTeamDaysOff');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateTeamDaysOff');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTeamDaysOff');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamfieldvaluesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a collection of team field values
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTeamFieldValues (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamFieldValues> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/teamfieldvalues'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamFieldValues');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTeamFieldValues');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTeamFieldValues');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamFieldValues');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update team field values
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTeamFieldValues (params: {  organization: string; body: TeamFieldValuesPatch; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamFieldValues> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings/teamfieldvalues'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTeamFieldValues');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTeamFieldValues');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTeamFieldValues');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateTeamFieldValues');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTeamFieldValues');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a team in a team project.  Possible failure scenarios Invalid project name/ID (project doesn&#39;t exist) 404 Invalid team name or description 400 Team already exists 400 Insufficient privileges 400
         * @param organization The name of the Azure DevOps organization.
         * @param body The team data used to create the team.
         * @param projectId The name or ID (GUID) of the team project in which to create the team.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createTeam (params: {  organization: string; body: WebApiTeam; projectId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WebApiTeam> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTeam');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTeam');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling createTeam');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTeam');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a team.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The name or ID (GUID) of the team project containing the team to delete.
         * @param teamId The name of ID of the team to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteTeam (params: {  organization: string; projectId: string; teamId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams/{teamId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTeam');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling deleteTeam');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling deleteTeam');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTeam');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of all teams.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Mine If true return all the teams requesting user is member, otherwise return all the teams user has read access
         * @param $Top Maximum number of teams to return.
         * @param $Skip Number of teams to skip.
         */
        public getAllTeams (params: {  organization: string; apiVersion: string; $Mine?: boolean; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WebApiTeam>> {
            const localVarPath = this.basePath + '/{organization}/_apis/teams'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAllTeams');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAllTeams');
            }
            if (params.$Mine !== undefined) {
                queryParameters['$mine'] = params.$Mine;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific team.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The name or ID (GUID) of the team project containing the team.
         * @param teamId The name or ID (GUID) of the team.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getTeam (params: {  organization: string; projectId: string; teamId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WebApiTeam> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams/{teamId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeam');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling getTeam');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling getTeam');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeam');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of members for a specific team.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId The name or ID (GUID) of the team project the team belongs to.
         * @param teamId The name or ID (GUID) of the team .
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Top 
         * @param $Skip 
         */
        public getTeamMembersWithExtendedProperties (params: {  organization: string; projectId: string; teamId: string; apiVersion: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TeamMember>> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams/{teamId}/members'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamMembersWithExtendedProperties');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling getTeamMembersWithExtendedProperties');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling getTeamMembersWithExtendedProperties');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamMembersWithExtendedProperties');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of teams.
         * @param organization The name of the Azure DevOps organization.
         * @param projectId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Mine If true return all the teams requesting user is member, otherwise return all the teams user has read access
         * @param $Top Maximum number of teams to return.
         * @param $Skip Number of teams to skip.
         */
        public getTeams (params: {  organization: string; projectId: string; apiVersion: string; $Mine?: boolean; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WebApiTeam>> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeams');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling getTeams');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeams');
            }
            if (params.$Mine !== undefined) {
                queryParameters['$mine'] = params.$Mine;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a team&#39;s name and/or description.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param projectId The name or ID (GUID) of the team project containing the team to update.
         * @param teamId The name of ID of the team to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateTeam (params: {  organization: string; body: WebApiTeam; projectId: string; teamId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WebApiTeam> {
            const localVarPath = this.basePath + '/{organization}/_apis/projects/{projectId}/teams/{teamId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'projectId' + '}', String(params.projectId))
                .replace('{' + 'teamId' + '}', String(params.teamId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTeam');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTeam');
            }
            // verify required parameter 'projectId' is set
            if (params.projectId == null) {
                throw new Error('Missing required parameter projectId when calling updateTeam');
            }
            // verify required parameter 'teamId' is set
            if (params.teamId == null) {
                throw new Error('Missing required parameter teamId when calling updateTeam');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTeam');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TeamsettingsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a team&#39;s settings
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTeamSettings (params: {  organization: string; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSetting> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTeamSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTeamSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTeamSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTeamSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a team&#39;s settings
         * @param organization The name of the Azure DevOps organization.
         * @param body TeamSettings changes
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTeamSettings (params: {  organization: string; body: TeamSettingsPatch; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TeamSetting> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/work/teamsettings'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTeamSettings');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTeamSettings');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTeamSettings');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateTeamSettings');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTeamSettings');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TemplatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a template
         * @param organization The name of the Azure DevOps organization.
         * @param body Template contents
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTemplate (params: {  organization: string; body: WorkItemTemplate; project: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTemplate> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/templates'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTemplate');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTemplate');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling createTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTemplate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes a build definition template.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param templateId The ID of the template.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public deleteTemplate (params: {  organization: string; project: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTemplate');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling deleteTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTemplate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes the template with given id
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param templateId Template id
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTemplate_1 (params: {  organization: string; project: string; team: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTemplate_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTemplate_1');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling deleteTemplate_1');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling deleteTemplate_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTemplate_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets a specific build definition template.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param templateId The ID of the requested template.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getTemplate (params: {  organization: string; project: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinitionTemplate> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTemplate');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling getTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTemplate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the template with specified id
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param templateId Template Id
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTemplate_2 (params: {  organization: string; project: string; team: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTemplate> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTemplate_2');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTemplate_2');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTemplate_2');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling getTemplate_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTemplate_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets all definition templates.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getTemplates (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<BuildDefinitionTemplate>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/templates'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTemplates');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTemplates');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTemplates');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets template
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param workitemtypename Optional, When specified returns templates for given Work item type.
         */
        public getTemplates_3 (params: {  organization: string; project: string; team: string; apiVersion: string; workitemtypename?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTemplateReference>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/templates'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTemplates_3');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTemplates_3');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getTemplates_3');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTemplates_3');
            }
            if (params.workitemtypename !== undefined) {
                queryParameters['workitemtypename'] = params.workitemtypename;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replace template contents
         * @param organization The name of the Azure DevOps organization.
         * @param body Template contents to replace with
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param templateId Template id
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public replaceTemplate (params: {  organization: string; body: WorkItemTemplate; project: string; team: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTemplate> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceTemplate');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceTemplate');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceTemplate');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling replaceTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceTemplate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates an existing build definition template.
         * @param organization The name of the Azure DevOps organization.
         * @param body The new version of the template.
         * @param project Project ID or project name
         * @param templateId The ID of the template.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public saveTemplate (params: {  organization: string; body: BuildDefinitionTemplate; project: string; templateId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<BuildDefinitionTemplate> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/definitions/templates/{templateId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'templateId' + '}', String(params.templateId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling saveTemplate');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling saveTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling saveTemplate');
            }
            // verify required parameter 'templateId' is set
            if (params.templateId == null) {
                throw new Error('Missing required parameter templateId when calling saveTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling saveTemplate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestCasesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a test case.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testCaseId Id of test case to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestCase (params: {  organization: string; project: string; testCaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/testcases/{testCaseId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testCaseId' + '}', String(params.testCaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestCase');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestCase');
            }
            // verify required parameter 'testCaseId' is set
            if (params.testCaseId == null) {
                throw new Error('Missing required parameter testCaseId when calling deleteTestCase');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestCase');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a test case.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testCaseId Id of test case to be deleted.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestCase_1 (params: {  organization: string; project: string; testCaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/testcases/{testCaseId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testCaseId' + '}', String(params.testCaseId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestCase_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestCase_1');
            }
            // verify required parameter 'testCaseId' is set
            if (params.testCaseId == null) {
                throw new Error('Missing required parameter testCaseId when calling deleteTestCase_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestCase_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestDefinitionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body Test definition to be created
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestDefinition (params: {  organization: string; body: TestDefinition; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestDefinition> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdefinitions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testDefinitionId The test definition identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestDefinition (params: {  organization: string; testDefinitionId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestDefinition> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdefinitions/{testDefinitionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testDefinitionId' + '}', String(params.testDefinitionId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestDefinition');
            }
            // verify required parameter 'testDefinitionId' is set
            if (params.testDefinitionId == null) {
                throw new Error('Missing required parameter testDefinitionId when calling getTestDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param fromDate Date after which test definitions were created
         * @param toDate Date before which test definitions were crated
         * @param top 
         */
        public getTestDefinitions (params: {  organization: string; apiVersion: string; fromDate?: string; toDate?: string; top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestDefinitionBasic>> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdefinitions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestDefinitions');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestDefinitions');
            }
            if (params.fromDate !== undefined) {
                queryParameters['fromDate'] = params.fromDate;
            }

            if (params.toDate !== undefined) {
                queryParameters['toDate'] = params.toDate;
            }

            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestDefinition (params: {  organization: string; body: TestDefinition; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestDefinition> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdefinitions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestDefinition');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestDefinition');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestDefinition');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestDropsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body Test drop to be created
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestDrop (params: {  organization: string; body: TestDrop; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestDrop> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdrops'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestDrop');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestDrop');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestDrop');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testDropId The test drop identifier
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestDrop (params: {  organization: string; testDropId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestDrop> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testdrops/{testDropId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testDropId' + '}', String(params.testDropId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestDrop');
            }
            // verify required parameter 'testDropId' is set
            if (params.testDropId == null) {
                throw new Error('Missing required parameter testDropId when calling getTestDrop');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestDrop');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestHistoryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get history of a test method using TestHistoryQuery
         * @param organization The name of the Azure DevOps organization.
         * @param body TestHistoryQuery to get history
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public queryTestHistory (params: {  organization: string; body: TestHistoryQuery; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestHistoryQuery> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Results/testhistory'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryTestHistory');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryTestHistory');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryTestHistory');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryTestHistory');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestPlanCloneApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Clone test plan
         * @param organization The name of the Azure DevOps organization.
         * @param body Plan Clone Request Body detail TestPlanCloneRequest
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param deepClone Clones all the associated test cases as well
         */
        public cloneTestPlan (params: {  organization: string; body: CloneTestPlanParams; project: string; apiVersion: string; deepClone?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CloneTestPlanOperationInformation> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/CloneOperation'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling cloneTestPlan');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling cloneTestPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling cloneTestPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling cloneTestPlan');
            }
            if (params.deepClone !== undefined) {
                queryParameters['deepClone'] = params.deepClone;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get clone information.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param cloneOperationId Operation ID returned when we queue a clone operation
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getCloneInformation (params: {  organization: string; project: string; cloneOperationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CloneTestPlanOperationInformation> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/CloneOperation/{cloneOperationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'cloneOperationId' + '}', String(params.cloneOperationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getCloneInformation');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getCloneInformation');
            }
            // verify required parameter 'cloneOperationId' is set
            if (params.cloneOperationId == null) {
                throw new Error('Missing required parameter cloneOperationId when calling getCloneInformation');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getCloneInformation');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestPlansApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a test plan.
         * @param organization The name of the Azure DevOps organization.
         * @param body A testPlanCreateParams object.TestPlanCreateParams
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestPlan (params: {  organization: string; body: TestPlanCreateParams; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestPlan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/plans'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestPlan');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestPlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a test plan.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan to be deleted.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestPlan (params: {  organization: string; project: string; planId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/plans/{planId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestPlan');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling deleteTestPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestPlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a test plan by Id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestPlanById (params: {  organization: string; project: string; planId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestPlan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/plans/{planId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestPlanById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestPlanById');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestPlanById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestPlanById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test plans
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param owner Filter for test plan by owner ID or name
         * @param continuationToken If the list of plans returned is not complete, a continuation token to query next batch of plans is included in the response header as &quot;x-ms-continuationtoken&quot;. Omit this parameter to get the first batch of test plans.
         * @param includePlanDetails Get all properties of the test plan
         * @param filterActivePlans Get just the active plans
         */
        public getTestPlans (params: {  organization: string; project: string; apiVersion: string; owner?: string; continuationToken?: string; includePlanDetails?: boolean; filterActivePlans?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPlan>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/plans'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestPlans');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestPlans');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestPlans');
            }
            if (params.owner !== undefined) {
                queryParameters['owner'] = params.owner;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.includePlanDetails !== undefined) {
                queryParameters['includePlanDetails'] = params.includePlanDetails;
            }

            if (params.filterActivePlans !== undefined) {
                queryParameters['filterActivePlans'] = params.filterActivePlans;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a test plan.
         * @param organization The name of the Azure DevOps organization.
         * @param body A testPlanUpdateParams object.TestPlanUpdateParams
         * @param project Project ID or project name
         * @param planId ID of the test plan to be updated.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestPlan (params: {  organization: string; body: TestPlanUpdateParams; project: string; planId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestPlan> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/plans/{planId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestPlan');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestPlan');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateTestPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestPlan');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestPointApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a list of points based on point Ids provided.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param pointIds 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getPoints (params: {  organization: string; project: string; planId: number; suiteId: number; pointIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestPoint/{pointIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'pointIds' + '}', String(params.pointIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPoints');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPoints');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getPoints');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getPoints');
            }
            // verify required parameter 'pointIds' is set
            if (params.pointIds == null) {
                throw new Error('Missing required parameter pointIds when calling getPoints');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPoints');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all the points inside a suite based on some filters
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param testPointIds 
         * @param testCaseId 
         * @param continuationToken 
         */
        public getPointsList (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; testPointIds?: string; testCaseId?: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestPoint'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPointsList');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPointsList');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getPointsList');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getPointsList');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPointsList');
            }
            if (params.testPointIds !== undefined) {
                queryParameters['testPointIds'] = params.testPointIds;
            }

            if (params.testCaseId !== undefined) {
                queryParameters['testCaseId'] = params.testCaseId;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update Test Points. This is used to Reset test point to active, update the outcome of a test point or update the tester of a test point
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param planId 
         * @param suiteId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateTestPoints (params: {  organization: string; body: Array<TestPointUpdateParams>; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestPoint>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/Suites/{suiteId}/TestPoint'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestPoints');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestPoints');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestPoints');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateTestPoints');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling updateTestPoints');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestPoints');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestRunsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestRun (params: {  organization: string; body: TestRun; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRun> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testruns'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestRun');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param testRunId Unique ID of the test run
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestRun (params: {  organization: string; testRunId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestRun> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testruns/{testRunId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRun');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling getTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns test runs based on the filter specified. Returns all runs of the tenant if there is no filter.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param name Name for the test run. Names are not unique. Test runs with same name are assigned sequential rolling numbers.
         * @param requestedBy Filter by the user who requested the test run. Here requestedBy should be the display name of the user.
         * @param status Filter by the test run status.
         * @param runType Valid values include: null, one of TestRunType, or &quot;*&quot;
         * @param fromDate Filter by the test runs that have been modified after the fromDate timestamp.
         * @param toDate Filter by the test runs that have been modified before the toDate timestamp.
         * @param detailed Include the detailed test run attributes.
         * @param top The maximum number of test runs to return.
         * @param runsourceidentifier 
         * @param retentionState 
         */
        public getTestRuns (params: {  organization: string; apiVersion: string; name?: string; requestedBy?: string; status?: string; runType?: string; fromDate?: string; toDate?: string; detailed?: boolean; top?: number; runsourceidentifier?: string; retentionState?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<any> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testruns'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestRuns');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestRuns');
            }
            if (params.name !== undefined) {
                queryParameters['name'] = params.name;
            }

            if (params.requestedBy !== undefined) {
                queryParameters['requestedBy'] = params.requestedBy;
            }

            if (params.status !== undefined) {
                queryParameters['status'] = params.status;
            }

            if (params.runType !== undefined) {
                queryParameters['runType'] = params.runType;
            }

            if (params.fromDate !== undefined) {
                queryParameters['fromDate'] = params.fromDate;
            }

            if (params.toDate !== undefined) {
                queryParameters['toDate'] = params.toDate;
            }

            if (params.detailed !== undefined) {
                queryParameters['detailed'] = params.detailed;
            }

            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.runsourceidentifier !== undefined) {
                queryParameters['runsourceidentifier'] = params.runsourceidentifier;
            }

            if (params.retentionState !== undefined) {
                queryParameters['retentionState'] = params.retentionState;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param testRunId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestRun (params: {  organization: string; body: TestRun; testRunId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/clt/testruns/{testRunId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'testRunId' + '}', String(params.testRunId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestRun');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestRun');
            }
            // verify required parameter 'testRunId' is set
            if (params.testRunId == null) {
                throw new Error('Missing required parameter testRunId when calling updateTestRun');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestRun');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestSuiteCloneApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Clone test suite
         * @param organization The name of the Azure DevOps organization.
         * @param body Suite Clone Request Body detail TestSuiteCloneRequest
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param deepClone Clones all the associated test cases as well
         */
        public cloneTestSuite (params: {  organization: string; body: CloneTestSuiteParams; project: string; apiVersion: string; deepClone?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CloneTestSuiteOperationInformation> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Suites/CloneOperation'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling cloneTestSuite');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling cloneTestSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling cloneTestSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling cloneTestSuite');
            }
            if (params.deepClone !== undefined) {
                queryParameters['deepClone'] = params.deepClone;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get clone information.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param cloneOperationId Operation ID returned when we queue a clone operation
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getSuiteCloneInformation (params: {  organization: string; project: string; cloneOperationId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<CloneTestSuiteOperationInformation> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Suites/CloneOperation/{cloneOperationId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'cloneOperationId' + '}', String(params.cloneOperationId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSuiteCloneInformation');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getSuiteCloneInformation');
            }
            // verify required parameter 'cloneOperationId' is set
            if (params.cloneOperationId == null) {
                throw new Error('Missing required parameter cloneOperationId when calling getSuiteCloneInformation');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSuiteCloneInformation');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestSuiteEntryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a list of test suite entries in the test suite.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param suiteId Id of the parent suite.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param suiteEntryType 
         */
        public getSuiteEntries (params: {  organization: string; project: string; suiteId: number; apiVersion: string; suiteEntryType?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SuiteEntry>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/suiteentry/{suiteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSuiteEntries');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getSuiteEntries');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getSuiteEntries');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSuiteEntries');
            }
            if (params.suiteEntryType !== undefined) {
                queryParameters['suiteEntryType'] = params.suiteEntryType;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Reorder test suite entries in the test suite.
         * @param organization The name of the Azure DevOps organization.
         * @param body List of SuiteEntry to reorder.
         * @param project Project ID or project name
         * @param suiteId Id of the parent test suite.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public reorderSuiteEntries (params: {  organization: string; body: Array<SuiteEntryUpdateParams>; project: string; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SuiteEntry>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/suiteentry/{suiteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling reorderSuiteEntries');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling reorderSuiteEntries');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling reorderSuiteEntries');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling reorderSuiteEntries');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling reorderSuiteEntries');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TestSuitesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add test cases to suite.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suite.
         * @param suiteId ID of the test suite to which the test cases must be added.
         * @param testCaseIds IDs of the test cases to add to the suite. Ids are specified in comma separated format.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public addTestCasesToSuite (params: {  organization: string; project: string; planId: number; suiteId: number; testCaseIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SuiteTestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/suites/{suiteId}/testcases/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addTestCasesToSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addTestCasesToSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling addTestCasesToSuite');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling addTestCasesToSuite');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling addTestCasesToSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addTestCasesToSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Create test suite.
         * @param organization The name of the Azure DevOps organization.
         * @param body Parameters for suite creation
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suites.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestSuite (params: {  organization: string; body: TestSuiteCreateParams; project: string; planId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestSuite> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/suites'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestSuite');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling createTestSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete test suite.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suite.
         * @param suiteId ID of the test suite to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestSuite (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/suites/{suiteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling deleteTestSuite');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling deleteTestSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Find the list of all test suites in which a given test case is present. This is helpful if you need to find out which test suites are using a test case, when you need to make changes to a test case.
         * @param organization The name of the Azure DevOps organization.
         * @param testCaseId ID of the test case for which suites need to be fetched.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getSuitesByTestCaseId (params: {  organization: string; testCaseId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestSuite>> {
            const localVarPath = this.basePath + '/{organization}/_apis/testplan/suites'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getSuitesByTestCaseId');
            }
            // verify required parameter 'testCaseId' is set
            if (params.testCaseId == null) {
                throw new Error('Missing required parameter testCaseId when calling getSuitesByTestCaseId');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getSuitesByTestCaseId');
            }
            if (params.testCaseId !== undefined) {
                queryParameters['testCaseId'] = params.testCaseId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a specific test case in a test suite with test case id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suites.
         * @param suiteId ID of the suite that contains the test case.
         * @param testCaseIds ID of the test case to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getTestCaseById (params: {  organization: string; project: string; planId: number; suiteId: number; testCaseIds: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<SuiteTestCase> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/suites/{suiteId}/testcases/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestCaseById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestCaseById');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestCaseById');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getTestCaseById');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling getTestCaseById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestCaseById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all test cases in a suite.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suites.
         * @param suiteId ID of the suite to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getTestCases (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SuiteTestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/suites/{suiteId}/testcases'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestCases');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestCases');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestCases');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getTestCases');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestCases');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get test suite by suite id.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suites.
         * @param suiteId ID of the suite to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param expand Include the children suites and testers details
         */
        public getTestSuiteById (params: {  organization: string; project: string; planId: number; suiteId: number; apiVersion: string; expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestSuite> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/suites/{suiteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestSuiteById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestSuiteById');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestSuiteById');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling getTestSuiteById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestSuiteById');
            }
            if (params.expand !== undefined) {
                queryParameters['expand'] = params.expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get test suites for plan.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan for which suites are requested.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param expand Include the children suites and testers details.
         * @param continuationToken If the list of suites returned is not complete, a continuation token to query next batch of suites is included in the response header as &quot;x-ms-continuationtoken&quot;. Omit this parameter to get the first batch of test suites.
         * @param asTreeView If the suites returned should be in a tree structure.
         */
        public getTestSuitesForPlan (params: {  organization: string; project: string; planId: number; apiVersion: string; expand?: string; continuationToken?: string; asTreeView?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestSuite>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/suites'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestSuitesForPlan');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestSuitesForPlan');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling getTestSuitesForPlan');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestSuitesForPlan');
            }
            if (params.expand !== undefined) {
                queryParameters['expand'] = params.expand;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.asTreeView !== undefined) {
                queryParameters['asTreeView'] = params.asTreeView;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * The test points associated with the test cases are removed from the test suite. The test case work item is not deleted from the system. See test cases resource to delete a test case permanently.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suite.
         * @param suiteId ID of the suite to get.
         * @param testCaseIds IDs of the test cases to remove from the suite.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public removeTestCasesFromSuiteUrl (params: {  organization: string; project: string; planId: number; suiteId: number; testCaseIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/suites/{suiteId}/testcases/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeTestCasesFromSuiteUrl');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling removeTestCasesFromSuiteUrl');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling removeTestCasesFromSuiteUrl');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling removeTestCasesFromSuiteUrl');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling removeTestCasesFromSuiteUrl');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeTestCasesFromSuiteUrl');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates the properties of the test case association in a suite.
         * @param organization The name of the Azure DevOps organization.
         * @param body Model for updation of the properties of test case suite association.
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suite.
         * @param suiteId ID of the test suite to which the test cases must be added.
         * @param testCaseIds IDs of the test cases to add to the suite. Ids are specified in comma separated format.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public updateSuiteTestCases (params: {  organization: string; body: SuiteTestCaseUpdateModel; project: string; planId: number; suiteId: number; testCaseIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<SuiteTestCase>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/test/Plans/{planId}/suites/{suiteId}/testcases/{testCaseIds}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId))
                .replace('{' + 'testCaseIds' + '}', String(params.testCaseIds));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateSuiteTestCases');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateSuiteTestCases');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateSuiteTestCases');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateSuiteTestCases');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling updateSuiteTestCases');
            }
            // verify required parameter 'testCaseIds' is set
            if (params.testCaseIds == null) {
                throw new Error('Missing required parameter testCaseIds when calling updateSuiteTestCases');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateSuiteTestCases');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update test suite.
         * @param organization The name of the Azure DevOps organization.
         * @param body Parameters for suite updation
         * @param project Project ID or project name
         * @param planId ID of the test plan that contains the suites.
         * @param suiteId ID of the parent suite.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestSuite (params: {  organization: string; body: TestSuiteUpdateParams; project: string; planId: number; suiteId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestSuite> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/Plans/{planId}/suites/{suiteId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'planId' + '}', String(params.planId))
                .replace('{' + 'suiteId' + '}', String(params.suiteId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestSuite');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestSuite');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestSuite');
            }
            // verify required parameter 'planId' is set
            if (params.planId == null) {
                throw new Error('Missing required parameter planId when calling updateTestSuite');
            }
            // verify required parameter 'suiteId' is set
            if (params.suiteId == null) {
                throw new Error('Missing required parameter suiteId when calling updateTestSuite');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestSuite');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TimelineApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets details for a build
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param buildId 
         * @param timelineId 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param changeId 
         * @param planId 
         */
        public getBuildTimeline (params: {  organization: string; project: string; buildId: number; timelineId: string; apiVersion: string; changeId?: number; planId?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Timeline> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/build/builds/{buildId}/timeline/{timelineId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'buildId' + '}', String(params.buildId))
                .replace('{' + 'timelineId' + '}', String(params.timelineId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBuildTimeline');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getBuildTimeline');
            }
            // verify required parameter 'buildId' is set
            if (params.buildId == null) {
                throw new Error('Missing required parameter buildId when calling getBuildTimeline');
            }
            // verify required parameter 'timelineId' is set
            if (params.timelineId == null) {
                throw new Error('Missing required parameter timelineId when calling getBuildTimeline');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBuildTimeline');
            }
            if (params.changeId !== undefined) {
                queryParameters['changeId'] = params.changeId;
            }

            if (params.planId !== undefined) {
                queryParameters['planId'] = params.planId;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TokenListGlobalIdentitiesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Revokes the listed OAuth authorizations.
         * @param body The list of identities containing the authorization IDs of the OAuth authorizations, such as session tokens retrieved by listed a users PATs, that should be checked for global access tokens.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param isPublic Set to false for PAT tokens and true for SSH tokens.
         */
        public listIdentitiesWithGlobalAccessTokens (params: {  body: Array<TokenAdminRevocation>; apiVersion: string; isPublic?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/_apis/tokenadministration/tokenlistglobalidentities';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling listIdentitiesWithGlobalAccessTokens');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listIdentitiesWithGlobalAccessTokens');
            }
            if (params.isPublic !== undefined) {
                queryParameters['isPublic'] = params.isPublic;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TokenPersonalAccessTokensApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Lists of all the session token details of the personal access tokens (PATs) for a particular user.
         * @param body 
         * @param subjectDescriptor The descriptor of the target user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param pageSize The maximum number of results to return on each page.
         * @param continuationToken An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
         * @param siPublic 
         */
        public listPersonalAccessTokens (params: {  body: Array<string>; subjectDescriptor: string; apiVersion: string; pageSize?: number; continuationToken?: string; siPublic?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TokenAdminPagedSessionTokens> {
            const localVarPath = this.basePath + '/_apis/tokenadministration/tokenpersonalaccesstokens/{subjectDescriptor}'
                .replace('{' + 'subjectDescriptor' + '}', String(params.subjectDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling listPersonalAccessTokens');
            }
            // verify required parameter 'subjectDescriptor' is set
            if (params.subjectDescriptor == null) {
                throw new Error('Missing required parameter subjectDescriptor when calling listPersonalAccessTokens');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listPersonalAccessTokens');
            }
            if (params.pageSize !== undefined) {
                queryParameters['pageSize'] = params.pageSize;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.siPublic !== undefined) {
                queryParameters['siPublic'] = params.siPublic;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TokenRevocationsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Revokes the listed OAuth authorizations.
         * @param body The list of objects containing the authorization IDs of the OAuth authorizations, such as session tokens retrieved by listed a users PATs, that should be revoked.
         * @param hostId Host Id to display on the notification page to manage tokens.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param isPublic Set to false for PAT tokens and true for SSH tokens.
         */
        public revokeAuthorizations (params: {  body: TokenAdministrationRevocation; hostId: string; apiVersion: string; isPublic?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/_apis/tokenadministration/tokenrevocations';

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling revokeAuthorizations');
            }
            // verify required parameter 'hostId' is set
            if (params.hostId == null) {
                throw new Error('Missing required parameter hostId when calling revokeAuthorizations');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling revokeAuthorizations');
            }
            if (params.hostId !== undefined) {
                queryParameters['hostId'] = params.hostId;
            }

            if (params.isPublic !== undefined) {
                queryParameters['isPublic'] = params.isPublic;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TreesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.  Repositories have both a name and an identifier. Identifiers are globally unique, but several projects may contain a repository of the same name. You don&#39;t need to include the project if you specify a repository by ID. However, if you specify a repository by name, you must also specify the project (by name or ID.
         * @param organization The name of the Azure DevOps organization.
         * @param repositoryId Repository Id.
         * @param sha1 SHA1 hash of the tree object.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param projectId Project Id.
         * @param recursive Search recursively. Include trees underneath this tree. Default is false.
         * @param fileName Name to use if a .zip file is returned. Default is the object ID.
         * @param $Format Use &quot;zip&quot;. Defaults to the MIME type set in the Accept header.
         */
        public getTree (params: {  organization: string; repositoryId: string; sha1: string; project: string; apiVersion: string; projectId?: string; recursive?: boolean; fileName?: string; $Format?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GitTreeRef> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/git/repositories/{repositoryId}/trees/{sha1}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'repositoryId' + '}', String(params.repositoryId))
                .replace('{' + 'sha1' + '}', String(params.sha1))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTree');
            }
            // verify required parameter 'repositoryId' is set
            if (params.repositoryId == null) {
                throw new Error('Missing required parameter repositoryId when calling getTree');
            }
            // verify required parameter 'sha1' is set
            if (params.sha1 == null) {
                throw new Error('Missing required parameter sha1 when calling getTree');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTree');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTree');
            }
            if (params.projectId !== undefined) {
                queryParameters['projectId'] = params.projectId;
            }

            if (params.recursive !== undefined) {
                queryParameters['recursive'] = params.recursive;
            }

            if (params.fileName !== undefined) {
                queryParameters['fileName'] = params.fileName;
            }

            if (params.$Format !== undefined) {
                queryParameters['$format'] = params.$Format;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class TypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Retrieve a specific policy type by ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param typeId The policy ID.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPolicyType (params: {  organization: string; project: string; typeId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PolicyType> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/types/{typeId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'typeId' + '}', String(params.typeId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyType');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyType');
            }
            // verify required parameter 'typeId' is set
            if (params.typeId == null) {
                throw new Error('Missing required parameter typeId when calling getPolicyType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Retrieve all available policy types.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPolicyTypes (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<PolicyType>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/policy/types'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPolicyTypes');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getPolicyTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPolicyTypes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get service endpoint types.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param type Type of service endpoint.
         * @param scheme Scheme of service endpoint.
         */
        public getServiceEndpointTypes (params: {  organization: string; apiVersion: string; type?: string; scheme?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ServiceEndpointType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/serviceendpoint/types'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getServiceEndpointTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getServiceEndpointTypes');
            }
            if (params.type !== undefined) {
                queryParameters['type'] = params.type;
            }

            if (params.scheme !== undefined) {
                queryParameters['scheme'] = params.scheme;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UniversalApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Delete a package version from a feed&#39;s recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a package version from the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deletePackageVersionFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling deletePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deletePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Show information about a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param showDeleted True to show information for deleted versions
         */
        public getPackageVersion (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; showDeleted?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ModelPackage> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersion');
            }
            if (params.showDeleted !== undefined) {
                queryParameters['showDeleted'] = params.showDeleted;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get information about a package version in the recycle bin.
         * @param organization The name of the Azure DevOps organization.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getPackageVersionMetadataFromRecycleBin (params: {  organization: string; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UPackPackageVersionDeletionState> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getPackageVersionMetadataFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Restore a package version from the recycle bin to its associated feed.
         * @param organization The name of the Azure DevOps organization.
         * @param body Set the &#39;Deleted&#39; property to &#39;false&#39; to restore the package.
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public restorePackageVersionFromRecycleBin (params: {  organization: string; body: UPackRecycleBinPackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/RecycleBin/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling restorePackageVersionFromRecycleBin');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling restorePackageVersionFromRecycleBin');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update information for a package version.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param feedId Name or ID of the feed.
         * @param packageName Name of the package.
         * @param packageVersion Version of the package.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updatePackageVersion (params: {  organization: string; body: PackageVersionDetails; feedId: string; packageName: string; packageVersion: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/packaging/feeds/{feedId}/upack/packages/{packageName}/versions/{packageVersion}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'feedId' + '}', String(params.feedId))
                .replace('{' + 'packageName' + '}', String(params.packageName))
                .replace('{' + 'packageVersion' + '}', String(params.packageVersion));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updatePackageVersion');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updatePackageVersion');
            }
            // verify required parameter 'feedId' is set
            if (params.feedId == null) {
                throw new Error('Missing required parameter feedId when calling updatePackageVersion');
            }
            // verify required parameter 'packageName' is set
            if (params.packageName == null) {
                throw new Error('Missing required parameter packageName when calling updatePackageVersion');
            }
            // verify required parameter 'packageVersion' is set
            if (params.packageVersion == null) {
                throw new Error('Missing required parameter packageVersion when calling updatePackageVersion');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updatePackageVersion');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UpdatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Returns a single update for a work item
         * @param organization The name of the Azure DevOps organization.
         * @param id 
         * @param updateNumber 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         */
        public getUpdate (params: {  organization: string; id: number; updateNumber: number; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemUpdate> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{id}/updates/{updateNumber}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'updateNumber' + '}', String(params.updateNumber))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUpdate');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getUpdate');
            }
            // verify required parameter 'updateNumber' is set
            if (params.updateNumber == null) {
                throw new Error('Missing required parameter updateNumber when calling getUpdate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getUpdate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUpdate');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a the deltas between work item revisions
         * @param organization The name of the Azure DevOps organization.
         * @param id 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param $Top 
         * @param $Skip 
         */
        public getUpdates (params: {  organization: string; id: number; project: string; apiVersion: string; $Top?: number; $Skip?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemUpdate>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workItems/{id}/updates'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUpdates');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getUpdates');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getUpdates');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUpdates');
            }
            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.$Skip !== undefined) {
                queryParameters['$skip'] = params.$Skip;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UserEntitlementSummaryApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get summary of Licenses, Extension, Projects, Groups and their assignments in the collection.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param select Comma (&quot;,&quot;) separated list of properties to select. Supported property names are {AccessLevels, Licenses, Extensions, Projects, Groups}.
         */
        public getUsersSummary (params: {  organization: string; apiVersion: string; select?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UsersSummary> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlementsummary'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUsersSummary');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUsersSummary');
            }
            if (params.select !== undefined) {
                queryParameters['select'] = params.select;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UserEntitlementsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a user, assign license and extensions and make them a member of a project group in an account.
         * @param organization The name of the Azure DevOps organization.
         * @param body UserEntitlement object specifying License, Extensions and Project/Team groups the user should be added to.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public addUserEntitlement (params: {  organization: string; body: UserEntitlement; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UserEntitlementsPostResponse> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addUserEntitlement');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addUserEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addUserEntitlement');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a user from the account.  The delete operation includes unassigning Extensions and Licenses and removing the user from all project memberships. The user would continue to have access to the account if she is member of an AAD group, that is added directly to the account.
         * @param organization The name of the Azure DevOps organization.
         * @param userId ID of the user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteUserEntitlement (params: {  organization: string; userId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements/{userId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'userId' + '}', String(params.userId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteUserEntitlement');
            }
            // verify required parameter 'userId' is set
            if (params.userId == null) {
                throw new Error('Missing required parameter userId when calling deleteUserEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteUserEntitlement');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get User Entitlement for a user.
         * @param organization The name of the Azure DevOps organization.
         * @param userId ID of the user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getUserEntitlement (params: {  organization: string; userId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UserEntitlement> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements/{userId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'userId' + '}', String(params.userId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUserEntitlement');
            }
            // verify required parameter 'userId' is set
            if (params.userId == null) {
                throw new Error('Missing required parameter userId when calling getUserEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUserEntitlement');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a paged set of user entitlements matching the filter criteria. If no filter is is passed, a page from all the account users is returned.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param top Maximum number of the user entitlements to return. Max value is 10000. Default value is 100
         * @param skip Offset: Number of records to skip. Default value is 0
         * @param filter Comma (&quot;,&quot;) separated list of properties and their values to filter on. Currently, the API only supports filtering by ExtensionId. An example parameter would be filter&#x3D;extensionId eq search.
         * @param sortOption PropertyName and Order (separated by a space ( )) to sort on (e.g. LastAccessDate Desc)
         */
        public getUserEntitlements (params: {  organization: string; apiVersion: string; top?: number; skip?: number; filter?: string; sortOption?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<PagedGraphMemberList> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUserEntitlements');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUserEntitlements');
            }
            if (params.top !== undefined) {
                queryParameters['top'] = params.top;
            }

            if (params.skip !== undefined) {
                queryParameters['skip'] = params.skip;
            }

            if (params.filter !== undefined) {
                queryParameters['filter'] = params.filter;
            }

            if (params.sortOption !== undefined) {
                queryParameters['sortOption'] = params.sortOption;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Edit the entitlements (License, Extensions, Projects, Teams etc) for a user.
         * @param organization The name of the Azure DevOps organization.
         * @param body JsonPatchDocument containing the operations to perform on the user.
         * @param userId ID of the user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateUserEntitlement (params: {  organization: string; body: JsonPatchDocument; userId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UserEntitlementsPatchResponse> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements/{userId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'userId' + '}', String(params.userId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateUserEntitlement');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateUserEntitlement');
            }
            // verify required parameter 'userId' is set
            if (params.userId == null) {
                throw new Error('Missing required parameter userId when calling updateUserEntitlement');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateUserEntitlement');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Edit the entitlements (License, Extensions, Projects, Teams etc) for one or more users.
         * @param organization The name of the Azure DevOps organization.
         * @param body JsonPatchDocument containing the operations to perform.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param doNotSendInviteForNewUsers Whether to send email invites to new users or not
         */
        public updateUserEntitlements (params: {  organization: string; body: JsonPatchDocument; apiVersion: string; doNotSendInviteForNewUsers?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<UserEntitlementOperationReference> {
            const localVarPath = this.basePath + '/{organization}/_apis/userentitlements'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateUserEntitlements');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateUserEntitlements');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateUserEntitlements');
            }
            if (params.doNotSendInviteForNewUsers !== undefined) {
                queryParameters['doNotSendInviteForNewUsers'] = params.doNotSendInviteForNewUsers;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class UsersApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Materialize an existing AAD or MSA user into the VSTS account.  NOTE: Created users are not active in an account unless they have been explicitly assigned a parent group at creation time or have signed in   and been autolicensed through AAD group memberships.   Adding a user to an account is required before the user can be added to VSTS groups or assigned an asset.   The body of the request must be a derived type of GraphUserCreationContext:   * GraphUserMailAddressCreationContext - Create a new user using the mail address as a reference to an existing user from an external AD or AAD backed provider.   * GraphUserOriginIdCreationContext - Create a new user using the OriginID as a reference to an existing user from an external AD or AAD backed provider.   * GraphUserPrincipalNameCreationContext - Create a new user using the principal name as a reference to an existing user from an external AD or AAD backed provider.   If the user to be added corresponds to a user that was previously deleted, then that user will be restored.   Optionally, you can add the newly created user as a member of an existing VSTS group and/or specify a custom storage key for the user.
         * @param organization The name of the Azure DevOps organization.
         * @param body The subset of the full graph user used to uniquely find the graph subject in an external provider.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param groupDescriptors A comma separated list of descriptors of groups you want the graph user to join
         */
        public createUser (params: {  organization: string; body: GraphUserCreationContext; apiVersion: string; groupDescriptors?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphUser> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/users'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createUser');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createUser');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createUser');
            }
            if (params.groupDescriptors !== undefined) {
                queryParameters['groupDescriptors'] = params.groupDescriptors;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Disables a user.  The user will still be visible, but membership checks for the user will return false.”
         * @param organization The name of the Azure DevOps organization.
         * @param userDescriptor The descriptor of the user to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteUser (params: {  organization: string; userDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/users/{userDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'userDescriptor' + '}', String(params.userDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteUser');
            }
            // verify required parameter 'userDescriptor' is set
            if (params.userDescriptor == null) {
                throw new Error('Missing required parameter userDescriptor when calling deleteUser');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteUser');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a user by its descriptor.
         * @param organization The name of the Azure DevOps organization.
         * @param userDescriptor The descriptor of the desired user.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getUser (params: {  organization: string; userDescriptor: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<GraphUser> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/users/{userDescriptor}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'userDescriptor' + '}', String(params.userDescriptor));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getUser');
            }
            // verify required parameter 'userDescriptor' is set
            if (params.userDescriptor == null) {
                throw new Error('Missing required parameter userDescriptor when calling getUser');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getUser');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of all users in a given scope.  Since the list of users may be large, results are returned in pages of users.  If there are more results  than can be returned in a single page, the result set will contain a continuation token for retrieval of the  next set of results.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param subjectTypes A comma separated list of user subject subtypes to reduce the retrieved results, e.g. msa’, ‘aad’, ‘svc’ (service identity), ‘imp’ (imported identity), etc.
         * @param continuationToken An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
         */
        public listUsers (params: {  organization: string; apiVersion: string; subjectTypes?: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<GraphUser>> {
            const localVarPath = this.basePath + '/{organization}/_apis/graph/users'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling listUsers');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling listUsers');
            }
            if (params.subjectTypes !== undefined) {
                queryParameters['subjectTypes'] = params.subjectTypes;
            }

            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class VariablegroupsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Add a variable group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Variable group to add.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addVariableGroup (params: {  organization: string; body: VariableGroupParameters; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<VariableGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/variablegroups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addVariableGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addVariableGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling addVariableGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addVariableGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a variable group
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param groupId Id of the variable group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteVariableGroup (params: {  organization: string; project: string; groupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/variablegroups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteVariableGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteVariableGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling deleteVariableGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteVariableGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a variable group.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param groupId Id of the variable group.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getVariableGroup (params: {  organization: string; project: string; groupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<VariableGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/variablegroups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getVariableGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getVariableGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling getVariableGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getVariableGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get variable groups by ids.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param groupIds Comma separated list of Ids of variable groups.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getVariableGroupsById (params: {  organization: string; project: string; groupIds: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<VariableGroup>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/variablegroups'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getVariableGroupsById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getVariableGroupsById');
            }
            // verify required parameter 'groupIds' is set
            if (params.groupIds == null) {
                throw new Error('Missing required parameter groupIds when calling getVariableGroupsById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getVariableGroupsById');
            }
            if (params.groupIds !== undefined) {
                queryParameters['groupIds'] = params.groupIds;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a variable group.
         * @param organization The name of the Azure DevOps organization.
         * @param body Variable group to update.
         * @param project Project ID or project name
         * @param groupId Id of the variable group to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateVariableGroup (params: {  organization: string; body: VariableGroupParameters; project: string; groupId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<VariableGroup> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/distributedtask/variablegroups/{groupId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'groupId' + '}', String(params.groupId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateVariableGroup');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateVariableGroup');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateVariableGroup');
            }
            // verify required parameter 'groupId' is set
            if (params.groupId == null) {
                throw new Error('Missing required parameter groupId when calling updateVariableGroup');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateVariableGroup');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class VariablesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a test variable.
         * @param organization The name of the Azure DevOps organization.
         * @param body TestVariableCreateUpdateParameters
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createTestVariable (params: {  organization: string; body: TestVariableCreateUpdateParameters; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestVariable> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/variables'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createTestVariable');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createTestVariable');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createTestVariable');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createTestVariable');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete a test variable by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testVariableId ID of the test variable to delete.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteTestVariable (params: {  organization: string; project: string; testVariableId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/variables/{testVariableId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testVariableId' + '}', String(params.testVariableId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteTestVariable');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteTestVariable');
            }
            // verify required parameter 'testVariableId' is set
            if (params.testVariableId == null) {
                throw new Error('Missing required parameter testVariableId when calling deleteTestVariable');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteTestVariable');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a test variable by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param testVariableId ID of the test variable to get.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getTestVariableById (params: {  organization: string; project: string; testVariableId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestVariable> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/variables/{testVariableId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testVariableId' + '}', String(params.testVariableId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestVariableById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestVariableById');
            }
            // verify required parameter 'testVariableId' is set
            if (params.testVariableId == null) {
                throw new Error('Missing required parameter testVariableId when calling getTestVariableById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestVariableById');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of test variables.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param continuationToken If the list of variables returned is not complete, a continuation token to query next batch of variables is included in the response header as &quot;x-ms-continuationtoken&quot;. Omit this parameter to get the first batch of test variables.
         */
        public getTestVariables (params: {  organization: string; project: string; apiVersion: string; continuationToken?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<TestVariable>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/variables'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getTestVariables');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getTestVariables');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getTestVariables');
            }
            if (params.continuationToken !== undefined) {
                queryParameters['continuationToken'] = params.continuationToken;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update a test variable by its ID.
         * @param organization The name of the Azure DevOps organization.
         * @param body TestVariableCreateUpdateParameters
         * @param project Project ID or project name
         * @param testVariableId ID of the test variable to update.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateTestVariable (params: {  organization: string; body: TestVariableCreateUpdateParameters; project: string; testVariableId: number; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<TestVariable> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/testplan/variables/{testVariableId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'testVariableId' + '}', String(params.testVariableId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateTestVariable');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateTestVariable');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateTestVariable');
            }
            // verify required parameter 'testVariableId' is set
            if (params.testVariableId == null) {
                throw new Error('Missing required parameter testVariableId when calling updateTestVariable');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateTestVariable');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WidgetTypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get the widget metadata satisfying the specified contribution ID.
         * @param organization The name of the Azure DevOps organization.
         * @param contributionId The ID of Contribution for the Widget
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWidgetMetadata (params: {  organization: string; contributionId: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WidgetMetadataResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/dashboard/widgettypes/{contributionId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'contributionId' + '}', String(params.contributionId))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWidgetMetadata');
            }
            // verify required parameter 'contributionId' is set
            if (params.contributionId == null) {
                throw new Error('Missing required parameter contributionId when calling getWidgetMetadata');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWidgetMetadata');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWidgetMetadata');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get all available widget metadata in alphabetical order.
         * @param organization The name of the Azure DevOps organization.
         * @param $Scope 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWidgetTypes (params: {  organization: string; $Scope: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WidgetTypesResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/dashboard/widgettypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWidgetTypes');
            }
            // verify required parameter '$Scope' is set
            if (params.$Scope == null) {
                throw new Error('Missing required parameter $Scope when calling getWidgetTypes');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWidgetTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWidgetTypes');
            }
            if (params.$Scope !== undefined) {
                queryParameters['$scope'] = params.$Scope;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WidgetsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Create a widget on the specified dashboard.
         * @param organization The name of the Azure DevOps organization.
         * @param body State of the widget to add
         * @param project Project ID or project name
         * @param dashboardId ID of dashboard the widget will be added to.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createWidget (params: {  organization: string; body: Widget; project: string; dashboardId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Widget> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createWidget');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createWidget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createWidget');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling createWidget');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling createWidget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createWidget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Delete the specified widget.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard containing the widget.
         * @param widgetId ID of the widget to update.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteWidget (params: {  organization: string; project: string; dashboardId: string; widgetId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Dashboard> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets/{widgetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'widgetId' + '}', String(params.widgetId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteWidget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteWidget');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling deleteWidget');
            }
            // verify required parameter 'widgetId' is set
            if (params.widgetId == null) {
                throw new Error('Missing required parameter widgetId when calling deleteWidget');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling deleteWidget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteWidget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get the current state of the specified widget.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard containing the widget.
         * @param widgetId ID of the widget to read.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWidget (params: {  organization: string; project: string; dashboardId: string; widgetId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Widget> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets/{widgetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'widgetId' + '}', String(params.widgetId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWidget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWidget');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling getWidget');
            }
            // verify required parameter 'widgetId' is set
            if (params.widgetId == null) {
                throw new Error('Missing required parameter widgetId when calling getWidget');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getWidget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWidget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get widgets contained on the specified dashboard.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard to read.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param eTag Dashboard Widgets Version
         */
        public getWidgets (params: {  organization: string; project: string; dashboardId: string; team: string; apiVersion: string; eTag?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Widget>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWidgets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWidgets');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling getWidgets');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling getWidgets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWidgets');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['eTag'] = params.eTag;

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Override the  state of the specified widget.
         * @param organization The name of the Azure DevOps organization.
         * @param body State to be written for the widget.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard containing the widget.
         * @param widgetId ID of the widget to update.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public replaceWidget (params: {  organization: string; body: Widget; project: string; dashboardId: string; widgetId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Widget> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets/{widgetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'widgetId' + '}', String(params.widgetId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceWidget');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceWidget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceWidget');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling replaceWidget');
            }
            // verify required parameter 'widgetId' is set
            if (params.widgetId == null) {
                throw new Error('Missing required parameter widgetId when calling replaceWidget');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceWidget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceWidget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Replace the widgets on specified dashboard with the supplied widgets.
         * @param organization The name of the Azure DevOps organization.
         * @param body Revised state of widgets to store for the dashboard.
         * @param project Project ID or project name
         * @param dashboardId ID of the Dashboard to modify.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param eTag Dashboard Widgets Version
         */
        public replaceWidgets (params: {  organization: string; body: Array<Widget>; project: string; dashboardId: string; team: string; apiVersion: string; eTag?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Widget>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling replaceWidgets');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling replaceWidgets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling replaceWidgets');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling replaceWidgets');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling replaceWidgets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling replaceWidgets');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['eTag'] = params.eTag;

            let fetchParams = {
                method: 'PUT',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Perform a partial update of the specified widget.
         * @param organization The name of the Azure DevOps organization.
         * @param body Description of the widget changes to apply. All non-null fields will be replaced.
         * @param project Project ID or project name
         * @param dashboardId ID of the dashboard containing the widget.
         * @param widgetId ID of the widget to update.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateWidget (params: {  organization: string; body: Widget; project: string; dashboardId: string; widgetId: string; team: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Widget> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets/{widgetId}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'widgetId' + '}', String(params.widgetId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWidget');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWidget');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateWidget');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling updateWidget');
            }
            // verify required parameter 'widgetId' is set
            if (params.widgetId == null) {
                throw new Error('Missing required parameter widgetId when calling updateWidget');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateWidget');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWidget');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Update the supplied widgets on the dashboard using supplied state. State of existing Widgets not passed in the widget list is preserved.
         * @param organization The name of the Azure DevOps organization.
         * @param body The set of widget states to update on the dashboard.
         * @param project Project ID or project name
         * @param dashboardId ID of the Dashboard to modify.
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param eTag Dashboard Widgets Version
         */
        public updateWidgets (params: {  organization: string; body: Array<Widget>; project: string; dashboardId: string; team: string; apiVersion: string; eTag?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<Widget>> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/dashboard/dashboards/{dashboardId}/widgets'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'dashboardId' + '}', String(params.dashboardId))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWidgets');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWidgets');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateWidgets');
            }
            // verify required parameter 'dashboardId' is set
            if (params.dashboardId == null) {
                throw new Error('Missing required parameter dashboardId when calling updateWidgets');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling updateWidgets');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWidgets');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            headerParams['eTag'] = params.eTag;

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WikiSearchResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Provides a set of results for the search request.
         * @param organization The name of the Azure DevOps organization.
         * @param body The Wiki Search Request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public fetchWikiSearchResults (params: {  organization: string; body: WikiSearchRequest; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiSearchResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/search/wikisearchresults'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling fetchWikiSearchResults');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling fetchWikiSearchResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling fetchWikiSearchResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling fetchWikiSearchResults');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WikisApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates the wiki resource.
         * @param organization The name of the Azure DevOps organization.
         * @param body Parameters for the wiki creation.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createWiki (params: {  organization: string; body: WikiCreateParametersV2; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiV2> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createWiki');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createWiki');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createWiki');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createWiki');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes the wiki corresponding to the wiki name or Id provided.
         * @param organization The name of the Azure DevOps organization.
         * @param wikiIdentifier Wiki name or Id.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteWiki (params: {  organization: string; wikiIdentifier: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiV2> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteWiki');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling deleteWiki');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteWiki');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteWiki');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets all wikis in a project or collection.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getAllWikis (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WikiV2>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getAllWikis');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getAllWikis');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getAllWikis');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the wiki corresponding to the wiki name or Id provided.
         * @param organization The name of the Azure DevOps organization.
         * @param wikiIdentifier Wiki name or id.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWiki (params: {  organization: string; wikiIdentifier: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiV2> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWiki');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling getWiki');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWiki');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWiki');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates the wiki corresponding to the wiki Id or name provided using the update parameters.
         * @param organization The name of the Azure DevOps organization.
         * @param body Update parameters.
         * @param wikiIdentifier Wiki name or Id.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateWiki (params: {  organization: string; body: WikiUpdateParameters; wikiIdentifier: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WikiV2> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wiki/wikis/{wikiIdentifier}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'wikiIdentifier' + '}', String(params.wikiIdentifier))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWiki');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWiki');
            }
            // verify required parameter 'wikiIdentifier' is set
            if (params.wikiIdentifier == null) {
                throw new Error('Missing required parameter wikiIdentifier when calling updateWiki');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateWiki');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWiki');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WiqlApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the results of the query given the query ID.
         * @param organization The name of the Azure DevOps organization.
         * @param id The query ID.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param timePrecision Whether or not to use time precision.
         * @param $Top The max number of results to return.
         */
        public queryById (params: {  organization: string; id: string; project: string; team: string; apiVersion: string; timePrecision?: boolean; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<number> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/wiql/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryById');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling queryById');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryById');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling queryById');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryById');
            }
            if (params.timePrecision !== undefined) {
                queryParameters['timePrecision'] = params.timePrecision;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'HEAD',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the results of the query given the query ID.
         * @param organization The name of the Azure DevOps organization.
         * @param id The query ID.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param timePrecision Whether or not to use time precision.
         * @param $Top The max number of results to return.
         */
        public queryById2 (params: {  organization: string; id: string; project: string; team: string; apiVersion: string; timePrecision?: boolean; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemQueryResult> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/wiql/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryById2');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling queryById2');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryById2');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling queryById2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryById2');
            }
            if (params.timePrecision !== undefined) {
                queryParameters['timePrecision'] = params.timePrecision;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the results of the query given its WIQL.
         * @param organization The name of the Azure DevOps organization.
         * @param body The query containing the WIQL.
         * @param project Project ID or project name
         * @param team Team ID or team name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param timePrecision Whether or not to use time precision.
         * @param $Top The max number of results to return.
         */
        public queryByWiql (params: {  organization: string; body: Wiql; project: string; team: string; apiVersion: string; timePrecision?: boolean; $Top?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemQueryResult> {
            const localVarPath = this.basePath + '/{organization}/{project}/{team}/_apis/wit/wiql'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'team' + '}', String(params.team));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling queryByWiql');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling queryByWiql');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling queryByWiql');
            }
            // verify required parameter 'team' is set
            if (params.team == null) {
                throw new Error('Missing required parameter team when calling queryByWiql');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling queryByWiql');
            }
            if (params.timePrecision !== undefined) {
                queryParameters['timePrecision'] = params.timePrecision;
            }

            if (params.$Top !== undefined) {
                queryParameters['$top'] = params.$Top;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemIconsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a work item icon given the friendly name and icon color.
         * @param icon The name of the icon
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param color The 6-digit hex color for the icon
         * @param v The version of the icon (used only for cache invalidation)
         */
        public getWorkItemIcon (params: {  icon: string; organization: string; apiVersion: string; color?: string; v?: number; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemIcon> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/workitemicons/{icon}'
                .replace('{' + 'icon' + '}', String(params.icon))
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'icon' is set
            if (params.icon == null) {
                throw new Error('Missing required parameter icon when calling getWorkItemIcon');
            }
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemIcon');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemIcon');
            }
            if (params.color !== undefined) {
                queryParameters['color'] = params.color;
            }

            if (params.v !== undefined) {
                queryParameters['v'] = params.v;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of all work item icons.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkItemIcons (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemIcon>> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/workitemicons'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemIcons');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemIcons');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemRelationTypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Gets the work item relation type definition.
         * @param organization The name of the Azure DevOps organization.
         * @param relation The relation name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getRelationType (params: {  organization: string; relation: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemRelationType> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/workitemrelationtypes/{relation}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'relation' + '}', String(params.relation));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRelationType');
            }
            // verify required parameter 'relation' is set
            if (params.relation == null) {
                throw new Error('Missing required parameter relation when calling getRelationType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRelationType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets the work item relation types.
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getRelationTypes (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemRelationType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/workitemrelationtypes'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getRelationTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getRelationTypes');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemSearchResultsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Provides a set of results for the search text.
         * @param organization The name of the Azure DevOps organization.
         * @param body The Work Item Search Request.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public fetchWorkItemSearchResults (params: {  organization: string; body: WorkItemSearchRequest; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemSearchResponse> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/search/workitemsearchresults'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling fetchWorkItemSearchResults');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling fetchWorkItemSearchResults');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling fetchWorkItemSearchResults');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling fetchWorkItemSearchResults');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTransitionsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Returns the next state on the given work item IDs.
         * @param organization The name of the Azure DevOps organization.
         * @param ids list of work item ids
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param action possible actions. Currently only supports checkin
         */
        public getWorkItemNextStatesOnCheckinAction (params: {  organization: string; ids: string; apiVersion: string; action?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemNextStateOnTransition>> {
            const localVarPath = this.basePath + '/{organization}/_apis/wit/workitemtransitions'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemNextStatesOnCheckinAction');
            }
            // verify required parameter 'ids' is set
            if (params.ids == null) {
                throw new Error('Missing required parameter ids when calling getWorkItemNextStatesOnCheckinAction');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemNextStatesOnCheckinAction');
            }
            if (params.ids !== undefined) {
                queryParameters['ids'] = params.ids;
            }

            if (params.action !== undefined) {
                queryParameters['action'] = params.action;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypeCategoriesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get all work item type categories.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWorkItemTypeCategories (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeCategory>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypecategories'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeCategories');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypeCategories');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeCategories');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get specific work item type category by name.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param category The category name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWorkItemTypeCategory (params: {  organization: string; project: string; category: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeCategory> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypecategories/{category}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'category' + '}', String(params.category));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeCategory');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypeCategory');
            }
            // verify required parameter 'category' is set
            if (params.category == null) {
                throw new Error('Missing required parameter category when calling getWorkItemTypeCategory');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeCategory');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypeStatesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Returns the state names and colors for a work item type.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param type The state name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkItemTypeStates (params: {  organization: string; project: string; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemStateColor>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypes/{type}/states'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeStates');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypeStates');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getWorkItemTypeStates');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeStates');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypesApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a behavior to the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addBehaviorToWorkItemType (params: {  organization: string; body: WorkItemTypeBehavior; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addBehaviorToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a work item type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process on which to create work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public createProcessWorkItemType (params: {  organization: string; body: CreateProcessWorkItemTypeRequest; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemType> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createProcessWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createProcessWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createProcessWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createProcessWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Creates a work item type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public createWorkItemType (params: {  organization: string; body: WorkItemTypeModel; processId: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling createWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a work itewm type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process.
         * @param witRefName The reference name of the work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public deleteProcessWorkItemType (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteProcessWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteProcessWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling deleteProcessWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteProcessWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a work itewm type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public deleteWorkItemType (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling deleteWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling deleteWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviorForWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefNameForBehaviors}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviorForWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all behaviors for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviorsForWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeBehavior>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviorsForWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single work item type in a process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand Flag to determine what properties of work item type to return
         */
        public getProcessWorkItemType (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemType> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getProcessWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessWorkItemType');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all work item types in a process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         * @param $Expand Flag to determine what properties of work item type to return
         */
        public getProcessWorkItemTypes (params: {  organization: string; processId: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<ProcessWorkItemType>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getProcessWorkItemTypes');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getProcessWorkItemTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getProcessWorkItemTypes');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Expand 
         */
        public getWorkItemType (params: {  organization: string; processId: string; witRefName: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling getWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemType');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a work item type definition.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param type Work item type name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWorkItemType_1 (params: {  organization: string; project: string; type: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemType> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypes/{type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemType_1');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemType_1');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getWorkItemType_1');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemType_1');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all work item types in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         * @param $Expand 
         */
        public getWorkItemTypes (params: {  organization: string; processId: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypes');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getWorkItemTypes');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypes');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns the list of work item types
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public getWorkItemTypes_2 (params: {  organization: string; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemType>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypes'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypes_2');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypes_2');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypes_2');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeBehaviorFromWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefNameForBehaviors}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeBehaviorFromWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBehaviorToWorkItemType (params: {  organization: string; body: WorkItemTypeBehavior; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBehaviorToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.2&#39; to use this version of the api.
         */
        public updateProcessWorkItemType (params: {  organization: string; body: UpdateProcessWorkItemTypeRequest; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<ProcessWorkItemType> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateProcessWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateProcessWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateProcessWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateProcessWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateProcessWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefName The reference name of the work item type
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateWorkItemType (params: {  organization: string; body: WorkItemTypeUpdateModel; processId: string; witRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workitemtypes/{witRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefName' + '}', String(params.witRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateWorkItemType');
            }
            // verify required parameter 'witRefName' is set
            if (params.witRefName == null) {
                throw new Error('Missing required parameter witRefName when calling updateWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypesBehaviorsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a behavior to the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addBehaviorToWorkItemType (params: {  organization: string; body: WorkItemTypeBehavior; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypesbehaviors/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling addBehaviorToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addBehaviorToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviorForWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypesbehaviors/{witRefNameForBehaviors}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling getBehaviorForWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviorForWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all behaviors for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getBehaviorsForWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeBehavior>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypesbehaviors/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling getBehaviorsForWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getBehaviorsForWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param behaviorRefName The reference name of the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeBehaviorFromWorkItemType (params: {  organization: string; processId: string; witRefNameForBehaviors: string; behaviorRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypesbehaviors/{witRefNameForBehaviors}/behaviors/{behaviorRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors))
                .replace('{' + 'behaviorRefName' + '}', String(params.behaviorRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'behaviorRefName' is set
            if (params.behaviorRefName == null) {
                throw new Error('Missing required parameter behaviorRefName when calling removeBehaviorFromWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeBehaviorFromWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a behavior for the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefNameForBehaviors Work item type reference name for the behavior
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public updateBehaviorToWorkItemType (params: {  organization: string; body: WorkItemTypeBehavior; processId: string; witRefNameForBehaviors: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeBehavior> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processes/{processId}/workitemtypesbehaviors/{witRefNameForBehaviors}/behaviors'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForBehaviors' + '}', String(params.witRefNameForBehaviors));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'witRefNameForBehaviors' is set
            if (params.witRefNameForBehaviors == null) {
                throw new Error('Missing required parameter witRefNameForBehaviors when calling updateBehaviorToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateBehaviorToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypesFieldApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Get a field for a work item type with detailed references.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param type Work item type.
         * @param field 
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param $Expand Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
         */
        public getWorkItemTypeFieldWithReferences (params: {  organization: string; project: string; type: string; field: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeFieldWithReferences> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypes/{type}/fields/{field}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type))
                .replace('{' + 'field' + '}', String(params.field));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeFieldWithReferences');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypeFieldWithReferences');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getWorkItemTypeFieldWithReferences');
            }
            // verify required parameter 'field' is set
            if (params.field == null) {
                throw new Error('Missing required parameter field when calling getWorkItemTypeFieldWithReferences');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeFieldWithReferences');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Get a list of fields for a work item type with detailed references.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param type Work item type.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param $Expand Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
         */
        public getWorkItemTypeFieldsWithReferences (params: {  organization: string; project: string; type: string; apiVersion: string; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeFieldWithReferences>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemtypes/{type}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeFieldsWithReferences');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTypeFieldsWithReferences');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getWorkItemTypeFieldsWithReferences');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeFieldsWithReferences');
            }
            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemTypesFieldsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Adds a field to the work item type in the process.
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param processId The ID of the process
         * @param witRefNameForFields Work item type reference name for the field
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public addFieldToWorkItemType (params: {  organization: string; body: WorkItemTypeFieldModel; processId: string; witRefNameForFields: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeFieldModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefNameForFields}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForFields' + '}', String(params.witRefNameForFields));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling addFieldToWorkItemType');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling addFieldToWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling addFieldToWorkItemType');
            }
            // verify required parameter 'witRefNameForFields' is set
            if (params.witRefNameForFields == null) {
                throw new Error('Missing required parameter witRefNameForFields when calling addFieldToWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling addFieldToWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single field in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForFields Work item type reference name for fields
         * @param fieldRefName The reference name of the field
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkItemTypeField (params: {  organization: string; processId: string; witRefNameForFields: string; fieldRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemTypeFieldModel> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefNameForFields}/fields/{fieldRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForFields' + '}', String(params.witRefNameForFields))
                .replace('{' + 'fieldRefName' + '}', String(params.fieldRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeField');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getWorkItemTypeField');
            }
            // verify required parameter 'witRefNameForFields' is set
            if (params.witRefNameForFields == null) {
                throw new Error('Missing required parameter witRefNameForFields when calling getWorkItemTypeField');
            }
            // verify required parameter 'fieldRefName' is set
            if (params.fieldRefName == null) {
                throw new Error('Missing required parameter fieldRefName when calling getWorkItemTypeField');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeField');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of all fields in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForFields Work item type reference name for fields
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkItemTypeFields (params: {  organization: string; processId: string; witRefNameForFields: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItemTypeFieldModel>> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefNameForFields}/fields'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForFields' + '}', String(params.witRefNameForFields));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTypeFields');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling getWorkItemTypeFields');
            }
            // verify required parameter 'witRefNameForFields' is set
            if (params.witRefNameForFields == null) {
                throw new Error('Missing required parameter witRefNameForFields when calling getWorkItemTypeFields');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTypeFields');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Removes a field in the work item type of the process.
         * @param organization The name of the Azure DevOps organization.
         * @param processId The ID of the process
         * @param witRefNameForFields Work item type reference name for fields
         * @param fieldRefName The reference name of the field
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public removeFieldFromWorkItemType (params: {  organization: string; processId: string; witRefNameForFields: string; fieldRefName: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<{}> {
            const localVarPath = this.basePath + '/{organization}/_apis/work/processdefinitions/{processId}/workItemTypes/{witRefNameForFields}/fields/{fieldRefName}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'processId' + '}', String(params.processId))
                .replace('{' + 'witRefNameForFields' + '}', String(params.witRefNameForFields))
                .replace('{' + 'fieldRefName' + '}', String(params.fieldRefName));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling removeFieldFromWorkItemType');
            }
            // verify required parameter 'processId' is set
            if (params.processId == null) {
                throw new Error('Missing required parameter processId when calling removeFieldFromWorkItemType');
            }
            // verify required parameter 'witRefNameForFields' is set
            if (params.witRefNameForFields == null) {
                throw new Error('Missing required parameter witRefNameForFields when calling removeFieldFromWorkItemType');
            }
            // verify required parameter 'fieldRefName' is set
            if (params.fieldRefName == null) {
                throw new Error('Missing required parameter fieldRefName when calling removeFieldFromWorkItemType');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling removeFieldFromWorkItemType');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class WorkItemsApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * Creates a single work item.
         * @param organization The name of the Azure DevOps organization.
         * @param body The JSON Patch document representing the work item
         * @param project Project ID or project name
         * @param type The work item type of the work item to create
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param validateOnly Indicate if you only want to validate the changes without saving the work item
         * @param bypassRules Do not enforce the work item type rules on this update
         * @param suppressNotifications Do not fire any notifications for this change
         * @param $Expand The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
         */
        public createWorkItem (params: {  organization: string; body: JsonPatchDocument; project: string; type: string; apiVersion: string; validateOnly?: boolean; bypassRules?: boolean; suppressNotifications?: boolean; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems/${type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling createWorkItem');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling createWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling createWorkItem');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling createWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling createWorkItem');
            }
            if (params.validateOnly !== undefined) {
                queryParameters['validateOnly'] = params.validateOnly;
            }

            if (params.bypassRules !== undefined) {
                queryParameters['bypassRules'] = params.bypassRules;
            }

            if (params.suppressNotifications !== undefined) {
                queryParameters['suppressNotifications'] = params.suppressNotifications;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Deletes the specified work item and sends it to the Recycle Bin, so that it can be restored back, if required. Optionally, if the destroy parameter has been set to true, it destroys the work item permanently.
         * @param organization The name of the Azure DevOps organization.
         * @param id ID of the work item to be deleted
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param destroy Optional parameter, if set to true, the work item is deleted permanently
         */
        public deleteWorkItem (params: {  organization: string; id: number; project: string; apiVersion: string; destroy?: boolean; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItemDelete> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling deleteWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling deleteWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling deleteWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling deleteWorkItem');
            }
            if (params.destroy !== undefined) {
                queryParameters['destroy'] = params.destroy;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'DELETE',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single work item.
         * @param organization The name of the Azure DevOps organization.
         * @param id The work item id
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fields Comma-separated list of requested fields
         * @param asOf AsOf UTC date time string
         * @param $Expand The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
         */
        public getWorkItem (params: {  organization: string; id: number; project: string; apiVersion: string; fields?: string; asOf?: Date; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling getWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItem');
            }
            if (params.fields !== undefined) {
                queryParameters['fields'] = params.fields;
            }

            if (params.asOf !== undefined) {
                queryParameters['asOf'] = params.asOf;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a single work item from a template.
         * @param organization The name of the Azure DevOps organization.
         * @param project Project ID or project name
         * @param type The work item type name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fields Comma-separated list of requested fields
         * @param asOf AsOf UTC date time string
         * @param $Expand The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
         */
        public getWorkItemTemplate (params: {  organization: string; project: string; type: string; apiVersion: string; fields?: string; asOf?: Date; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems/${type}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project))
                .replace('{' + 'type' + '}', String(params.type));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemTemplate');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemTemplate');
            }
            // verify required parameter 'type' is set
            if (params.type == null) {
                throw new Error('Missing required parameter type when calling getWorkItemTemplate');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemTemplate');
            }
            if (params.fields !== undefined) {
                queryParameters['fields'] = params.fields;
            }

            if (params.asOf !== undefined) {
                queryParameters['asOf'] = params.asOf;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Returns a list of work items (Maximum 200)
         * @param organization The name of the Azure DevOps organization.
         * @param ids The comma-separated list of requested work item ids. (Maximum 200 ids allowed).
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param fields Comma-separated list of requested fields
         * @param asOf AsOf UTC date time string
         * @param $Expand The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
         * @param errorPolicy The flag to control error policy in a bulk get work items request. Possible options are {Fail, Omit}.
         */
        public getWorkItems (params: {  organization: string; ids: string; project: string; apiVersion: string; fields?: string; asOf?: Date; $Expand?: string; errorPolicy?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItems');
            }
            // verify required parameter 'ids' is set
            if (params.ids == null) {
                throw new Error('Missing required parameter ids when calling getWorkItems');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItems');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItems');
            }
            if (params.ids !== undefined) {
                queryParameters['ids'] = params.ids;
            }

            if (params.fields !== undefined) {
                queryParameters['fields'] = params.fields;
            }

            if (params.asOf !== undefined) {
                queryParameters['asOf'] = params.asOf;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.errorPolicy !== undefined) {
                queryParameters['errorPolicy'] = params.errorPolicy;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Gets work items for a list of work item ids (Maximum 200)
         * @param organization The name of the Azure DevOps organization.
         * @param body 
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getWorkItemsBatch (params: {  organization: string; body: WorkItemBatchGetRequest; project: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<Array<WorkItem>> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitemsbatch'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getWorkItemsBatch');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling getWorkItemsBatch');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling getWorkItemsBatch');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getWorkItemsBatch');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'POST',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
        /**
         * 
         * Updates a single work item.
         * @param organization The name of the Azure DevOps organization.
         * @param body The JSON Patch document representing the update
         * @param id The id of the work item to update
         * @param project Project ID or project name
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.3&#39; to use this version of the api.
         * @param validateOnly Indicate if you only want to validate the changes without saving the work item
         * @param bypassRules Do not enforce the work item type rules on this update
         * @param suppressNotifications Do not fire any notifications for this change
         * @param $Expand The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
         */
        public updateWorkItem (params: {  organization: string; body: JsonPatchDocument; id: number; project: string; apiVersion: string; validateOnly?: boolean; bypassRules?: boolean; suppressNotifications?: boolean; $Expand?: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<WorkItem> {
            const localVarPath = this.basePath + '/{organization}/{project}/_apis/wit/workitems/{id}'
                .replace('{' + 'organization' + '}', String(params.organization))
                .replace('{' + 'id' + '}', String(params.id))
                .replace('{' + 'project' + '}', String(params.project));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            headerParams['Content-Type'] = 'application/json';

            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling updateWorkItem');
            }
            // verify required parameter 'body' is set
            if (params.body == null) {
                throw new Error('Missing required parameter body when calling updateWorkItem');
            }
            // verify required parameter 'id' is set
            if (params.id == null) {
                throw new Error('Missing required parameter id when calling updateWorkItem');
            }
            // verify required parameter 'project' is set
            if (params.project == null) {
                throw new Error('Missing required parameter project when calling updateWorkItem');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling updateWorkItem');
            }
            if (params.validateOnly !== undefined) {
                queryParameters['validateOnly'] = params.validateOnly;
            }

            if (params.bypassRules !== undefined) {
                queryParameters['bypassRules'] = params.bypassRules;
            }

            if (params.suppressNotifications !== undefined) {
                queryParameters['suppressNotifications'] = params.suppressNotifications;
            }

            if (params.$Expand !== undefined) {
                queryParameters['$expand'] = params.$Expand;
            }

            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'PATCH',
                headers: headerParams,
                body: JSON.stringify(params.body),
                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
//export namespace  {
    'use strict';

    export class YamlschemaApi {
        protected basePath = 'https://dev.azure.com/';
        public defaultHeaders : any = {};

        constructor(basePath?: string) {
            if (basePath) {
                this.basePath = basePath;
            }
        }

        /**
         * 
         * 
         * @param organization The name of the Azure DevOps organization.
         * @param apiVersion Version of the API to use.  This should be set to &#39;5.1-preview.1&#39; to use this version of the api.
         */
        public getYamlSchema (params: {  organization: string; apiVersion: string; }, extraQueryParams?: any, extraFetchParams?: any ): Promise<any> {
            const localVarPath = this.basePath + '/{organization}/_apis/distributedtask/yamlschema'
                .replace('{' + 'organization' + '}', String(params.organization));

            let queryParameters: any = assign({}, extraQueryParams);
            let headerParams: any = assign({}, this.defaultHeaders);
            // verify required parameter 'organization' is set
            if (params.organization == null) {
                throw new Error('Missing required parameter organization when calling getYamlSchema');
            }
            // verify required parameter 'apiVersion' is set
            if (params.apiVersion == null) {
                throw new Error('Missing required parameter apiVersion when calling getYamlSchema');
            }
            if (params.apiVersion !== undefined) {
                queryParameters['api-version'] = params.apiVersion;
            }

            let fetchParams = {
                method: 'GET',
                headers: headerParams,
                                
            };

            if (extraFetchParams) {
                fetchParams = assign(fetchParams, extraFetchParams);
            }

            let localVarPathWithQueryParameters = localVarPath + (localVarPath.indexOf('?') !== -1 ? '&' : '?') + querystring.stringify(queryParameters);

            return fetch(localVarPathWithQueryParameters, fetchParams).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    let error = new Error(response.statusText);
                    (error as any).response = response;
                    throw error;
                }
            });
        }
    }
//}
